---
title: network
date: 2022-01-26 14:18:12
cover: https://s4.ax1x.com/2022/01/26/7LPKsg.png
tags: 
- 网络
- JS
---

## 网络基本知识

### 一、从输入URL到浏览器显示页面发生了什么
三个方面  
一、网络篇  
互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方法进行通信。分层由高到底分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接受端从数据链路层往上走。如图所示
![](https://s4.ax1x.com/2022/01/26/7LMBv9.png)
__1、输入URL__  
__2、应用层DNS解析域名(找到域名对应IP)__
客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直到找到活到根节点。  
__3、应用层客户端发送HTTP请求__
HTTP请求包括请求头和请求体，其中请求头包含了请求方法、目标URL、协议、cookie、缓存等  
__4、传输层TCP传输报文__  
位于传输层的TCP协议为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文
段为单位的数据包进行管理，并为他们编号，方便服务器接收时能准确地还原报文信息。TCP
协议通过"三次握手"等方法保证传输的安全可靠。  
“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复，接收端
收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有
ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内
没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。  
![](https://s4.ax1x.com/2022/02/14/Hy3DWq.png)
__5、网络层IP协议查询MAC地址__  
IP协议的作用是把TCP分割好的各种数据包发送给接收方。而要保证确实能闯到接收方还需要接收方的MAC地址，也就是物理地址。IP地址
和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议
可以将IP地址解析成对应的MAC地址。  
__6、数据到达数据链路层__  
在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束  
__7、服务器接收数据__  
接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据
包重新组成原来的HTTP请求报文  
__8、服务器响应请求__  
服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息-状态码。状态码
由三位数字组成。  
__9、服务器返回相应的文件__  
请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。  
__10、页面渲染__  
html解析成DOM树，CSS解析成CSSOM树，DOM树和CSSOM树结合生成渲染树（Render Tree）,生成布局，将布局绘制在屏幕上  

### 二、状态码分析
200：响应成功，301：永久重定向，302：临时重定向，304：资源缓存，403：服务器禁止访问，404：服务器资源未找到，500-502：服务器内部错误，504：服务器繁忙  
1xx 信息状态码 接收请求正在处理  
2xx 成功状态码 请求正常处理完毕  
3xx 重定向状态码 需要附加操作已完成请求  
4xx 客户端错误状态码 服务器无法处理请求  
5xx 服务器错误状态码 服务器处理请求出错  

### 三、HTTP四次挥手
第一次：当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求；  
第二次：主机B收到FIN后对其作出响应，确认这一方向上的TCP的连接将关闭，将ACK置1；  
第三次：由主机B再提出反方向的关闭请求，将FIN置1；  
第四次：主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。  

### 四、http和https区别
1、http的URL是以http://开头，而https的URL是以https://开头  
2、http是不安全的，而https是安全的  
3、http标准端口80，而https的标准端口是443  
4、在OSI网络模型中，http工作于应用层，而https的安全传输机制工作在传输层  
5、http无法加密，而https对传输的数据进行加密  
6、http无需证书，而https需要CA机构颁发的SSL证书  

### 五、GET和POST的区别
1、GET在浏览器回退不会再次请求，POST会再次请求  
2、GET请求会被浏览器主动缓存，POST不会，要手动设置  
3、GET请求在URL中传递的参数有长度限制的，而POST中的参数不会  
4、GET参数通过URL传递，POST放在Request body中  
5、GET参数暴露在地址栏不安全，POST放在报文内部更安全  
6、GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作  
7、GET产生一个TCP数据包，POST产生两个TCP数据包  

### 六、理解xss、csrf、ddos攻击原理以及避免方式
1、XSS，跨站脚本攻击，是一种代码注入攻击。攻击者在网络上注入恶意代码，当被攻击者登录网站时
就会执行这些恶意代码，这些脚本可以读取cookie,session或者其他敏感的网络信息，对用户发起欺诈，甚至发起蠕虫攻击等。  

XSS避免的方式：  
1、URL参数使用encodeURIComponent方式转义  
2、尽量不使用InnerHtml插入HTML内容  
3、使用特殊符号、标签转义符  

2、CSRF，跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台
的用户验证，达到冒充用户对被攻击的网站进行某项操作的目的。  

CSRF避免的方式：
1、添加验证码  
2、使用token

3、DDos又叫分布式拒绝服务，原理就是利用大量的请求造成资源过载，导致服务器不可用。  

DDos避免的方式：  
1、限制单IP的请求评率  
2、防火墙等防护设置禁止ICMP  
3、检查特权端口的开放  

### 七、http如何实现缓存
先去内存（from memory cache）找，有直接加载，没有去硬盘找（from disk cache），如果有加载，没有则进行网络请求。  

memory cache在浏览器关闭后会清除，disk cache不会。  

__web服务器通过2种方式判断浏览器缓存是否是最新的：__  
1、浏览器把缓存文件的最后修改时间通过header中“if-Modified-Since”来告诉web服务器。  
2、浏览器把缓存文件的ETag,通过header ”if-None-Match“,来告诉web服务器  

__通过最后修改时间来判断缓存新鲜度__  
Last-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。  
1、浏览器客户端想请求一个文档，首先检查本地缓存，发现存在这个文档的缓存，获取缓存文件的最后修改时间，通过：if-Modified-Since,发送request给web服务器。  
2、web服务器收到Request,将服务器的文档修改时间（Last-Modified）:跟request header中的，if-Modified-Since相对比较，如果时间一样的，说明缓存还是最新的，web
服务器将发送304 Not Modified给浏览器客户端，告诉客户端直接使用缓存里的版本。  
3、假如该文档已经更新了，web服务器将发送该文档的最新版本给浏览器客户端。

__通过Etag来判断缓存新鲜度__  
Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。  
1、当资源过期时，（使用Cache-Control标识的max-age）,发现资源具有Etag声明，则再次想web服务器请求时带上If-None-Match(Etag的值)。  
2、web服务器收到请求后发现header中有If-None-Match则与被请求资源的相应校验串(etag)进行比对，决定返回200或者304  

__为何有Last-Modified，还需要Etag？__  
1 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间  
2 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存  
3 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形  
4、Last-Modified与Etag一起使用时，服务器会优先验证Etag  

__cache-control和Expires__  
Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间(绝对时间)前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  

Cache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期（相对时间），控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。  

__cache-control的值__  
1 Public指示响应可被任何缓存区缓存。
2 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
3 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~
4 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。
5 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
6 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
7 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。

__浏览器缓存流程__  
![](https://s4.ax1x.com/2022/02/14/H6nSFP.png)



