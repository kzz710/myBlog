{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/flex-block/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/flex-block/source/icons-512.png","path":"icons-512.png","modified":0,"renderable":1},{"_id":"themes/flex-block/source/icons-192.png","path":"icons-192.png","modified":0,"renderable":1},{"_id":"themes/flex-block/source/manifest.json","path":"manifest.json","modified":0,"renderable":1},{"_id":"themes/flex-block/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/flex-block/source/js/script.js","path":"js/script.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/vue.md","hash":"dc65812a208229b494e94806d540413463f5d4f0","modified":1629364069814},{"_id":"source/_posts/hello-world.md","hash":"9047894e329a8ce8f1de13895888b95692911d5e","modified":1629965108493},{"_id":"source/_posts/vueRouter.md","hash":"776058165b7d3cf918b1efe41e879666b29231ba","modified":1629964862207},{"_id":"source/tags/index.md","hash":"77738dafd6e79edc4816aca40d2bfd706905450b","modified":1629254533479},{"_id":"source/categories/index.md","hash":"30e8b5db11dfd7b1e5e881fe97f29334d8a34e22","modified":1629190388612},{"_id":"themes/flex-block/.gitignore","hash":"705b1b2062454bbf1210389b79ba6e61c3534417","modified":1629269481784},{"_id":"themes/flex-block/LICENSE","hash":"b39804556d3cc20997aca34c37ff896235078e86","modified":1629269481784},{"_id":"themes/flex-block/README.md","hash":"a73f77abcc04864be5fb8070a0e65f49ebe90a56","modified":1629269481784},{"_id":"themes/flex-block/_config.yml","hash":"7515addb052a7b5e205699c050b1af8d201aff59","modified":1629360435963},{"_id":"themes/flex-block/layout/archive.ejs","hash":"31199b59d95f43e89c78df799735bb03b4f2cdc6","modified":1629269481793},{"_id":"themes/flex-block/layout/category.ejs","hash":"5551f6309ac4f835bd135ebb35fd40ba961f09b3","modified":1629269481794},{"_id":"themes/flex-block/layout/index.ejs","hash":"b2d5cf681e351c2cdfd5f549bddc4f428812fd36","modified":1629269481794},{"_id":"themes/flex-block/layout/layout.ejs","hash":"0024457e6e44e810e5cc62e6d571d64c0ec36e33","modified":1629269481794},{"_id":"themes/flex-block/layout/page.ejs","hash":"4aaf6496c9e4c61355bbed51ea0bf15023d8bcf3","modified":1629269481794},{"_id":"themes/flex-block/layout/post.ejs","hash":"f4de584f9181669b301e43c4f30439f57c959108","modified":1629269481794},{"_id":"themes/flex-block/layout/tag.ejs","hash":"4621d964e6505fdc19ae270918ea08356cc5c789","modified":1629269481794},{"_id":"themes/flex-block/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1629269481785},{"_id":"themes/flex-block/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1629269481785},{"_id":"themes/flex-block/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1629269481785},{"_id":"themes/flex-block/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1629269481785},{"_id":"themes/flex-block/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1629269481785},{"_id":"themes/flex-block/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1629269481786},{"_id":"themes/flex-block/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1629269481786},{"_id":"themes/flex-block/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1629269481786},{"_id":"themes/flex-block/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1629269481786},{"_id":"themes/flex-block/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1629269481787},{"_id":"themes/flex-block/languages/zh-CN.yml","hash":"fb8f221242b3997833189f11cd14407a867de3b8","modified":1629269481787},{"_id":"themes/flex-block/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1629269481787},{"_id":"themes/flex-block/source/favicon.ico","hash":"cd1b610096d9c5c780fd2a7e24baaa78dada3163","modified":1629269481806},{"_id":"themes/flex-block/source/icons-192.png","hash":"8cd106d9039f1d5aa8163ecd4a5e352058a0f6cf","modified":1629269481806},{"_id":"themes/flex-block/source/manifest.json","hash":"6689646167bbe5bc836615a0c2019ea9aaa9e015","modified":1629269481808},{"_id":"themes/flex-block/scripts/index.js","hash":"80eb0126ace5be17be33f4ee1442061e79aa9e8f","modified":1629269481801},{"_id":"themes/flex-block/layout/_partial/article-list.ejs","hash":"33ce0492d8b3731d99f4ddf98664841770400777","modified":1629269481787},{"_id":"themes/flex-block/layout/_partial/footer-other.ejs","hash":"9e93e20f3e3ded687abe00a6478e3c4dbfff479e","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/content.ejs","hash":"ff5fb3bd02681529ce3f6f52d74e11c951bc5e83","modified":1629269481787},{"_id":"themes/flex-block/layout/_partial/footer-script.ejs","hash":"2af1fd98adfd3beafcbaf5555781fcccb910451c","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/footer.ejs","hash":"1dc4ef7064687955c3e37d79597258166c33110c","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/header.ejs","hash":"903c358d8f46488110a6462bc710546a755c50ba","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/nav.ejs","hash":"e58516a49b3997d9f2fe2bcd6bcced97b3e6ecd6","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/page.ejs","hash":"75cb1422782f264a1e3e3dc407ba26d2510595c3","modified":1629269481789},{"_id":"themes/flex-block/layout/_partial/pagination.ejs","hash":"22d60f90cf93b7a80ab1dc044fbf5808a723872a","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-article.svg","hash":"f89ab250586cf0bd8108b77e48a5288f1d0dd512","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-categories.svg","hash":"cfe4012051132281255e211c28971e05726cdc43","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-tags.svg","hash":"0d974ce6d089d08ef009ad56d1b5d66bf9c2c1e6","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/icon-notice.svg","hash":"0d2f705ca65673eda3d38420aa512d83fcbc1e72","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-toc.svg","hash":"05d2eecfb27deade461f25b2a396c230e18cd6b4","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-github.svg","hash":"880c135b980866f77047cd4507f5bf8671934333","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-ins.svg","hash":"aad8cb2136a7c8af682d9c9dae726b80ee1b57dd","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-twitter.svg","hash":"acb180ecf694e6b91a309e9247d691200f5540ac","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-weibo.svg","hash":"a10c19805388d60e9532a44db09f4d117fb4f1cf","modified":1629269481791},{"_id":"themes/flex-block/layout/_svg/social-zhihu.svg","hash":"9f46e99ec2a82ab4d85f38a6771378cddd83a70a","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/article-nav.ejs","hash":"8df3b527e6153323c8ded33768bd5e5267dfa422","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/category.ejs","hash":"488d6e93a6240d00d0c60c9f104f4304400415ba","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/date.ejs","hash":"5c275ec71f7ce628599683393ae71cf95196f71f","modified":1629269481792},{"_id":"themes/flex-block/layout/_widget/comment.ejs","hash":"1764ba8abe7ba34748e3603fc536a73404037964","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/tag.ejs","hash":"2a1642735fe62363cee1eeeb09a3d36c2e8ac00e","modified":1629269481792},{"_id":"themes/flex-block/layout/_widget/widget-author.ejs","hash":"d3bb8143f405d39734b28216f31a5a7b26691bab","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-categorys.ejs","hash":"588237737f87a0ff69d00605c868c1297054d573","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-notice.ejs","hash":"0a1ec45028b2abd123bb6a96017168fd55759971","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-tags.ejs","hash":"8c360bf72e85a4cf48c6064b44a64828d059285a","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-toc.ejs","hash":"0607e05641735d1fea7c74bc3c5b5f41f3bfb16f","modified":1629269481793},{"_id":"themes/flex-block/layout/plug-in/aplayer.ejs","hash":"438336577656019044851a9fd534b42f954aa51d","modified":1629269481794},{"_id":"themes/flex-block/layout/plug-in/dplayer.ejs","hash":"b328a419bdfee2fa96d8b64805db854d069d35ea","modified":1629269481794},{"_id":"themes/flex-block/source/css/style.styl","hash":"c56dc27939e0ca92b2e3f3e6119eeb654a198ec6","modified":1629269481806},{"_id":"themes/flex-block/source/js/script.js","hash":"df8e22b2f98a9c9c4547f1bb0cc73f37180ff790","modified":1629269481808},{"_id":"themes/flex-block/source/css/_partial/card.styl","hash":"4046ffdbd5f7bae5e0b5a5472e3d2a7bce91ba06","modified":1629358679749},{"_id":"themes/flex-block/source/css/_partial/content.styl","hash":"6417486290b19661228f6cced736ccbc10fdd3e5","modified":1629269481803},{"_id":"themes/flex-block/source/css/_partial/header.styl","hash":"60d4d83db131c23eb1089d4c0f6541e0f61ef19a","modified":1629358778725},{"_id":"themes/flex-block/source/css/_partial/footer.styl","hash":"11cf25e1999463aeec061c23ca7d32ee7dbc783d","modified":1629269481804},{"_id":"themes/flex-block/source/css/_partial/nav.styl","hash":"4aa5bf72c910dcc85f40e67202c1cc1929571401","modified":1629358576236},{"_id":"themes/flex-block/source/css/_partial/page.styl","hash":"cfc59a5969a140997dbe7b5a97e816b5f54d4a03","modified":1629269481804},{"_id":"themes/flex-block/source/css/_partial/pagination.styl","hash":"268bb486fc8682aa7e8e2417211c84cd1d5da264","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/mixins.styl","hash":"2189d5e686410ecc79c4e8e357dc0737965d295d","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/theme.styl","hash":"68fea7a3bf7d2e5cad165fb096efa74bcc8f3023","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/variables.styl","hash":"1c086d4ad292550acfa1e291f4dfa355c97f506e","modified":1629269481805},{"_id":"themes/flex-block/source/icons-512.png","hash":"c2cd59a7712738831ee0cca4338343d407777a4b","modified":1629269481807},{"_id":"themes/flex-block/screenshots/flex-block--post.jpeg","hash":"bc607db875e42fe2c82ed5130c07d67cca5adc41","modified":1629269481799},{"_id":"themes/flex-block/screenshots/flex-block--home.jpeg","hash":"7f6c738298108020ab2e4918592007a2d4bcb9d8","modified":1629269481797},{"_id":"themes/flex-block/screenshots/flex-block.png","hash":"93a5456d4f3a51f5e9fd4a957b85584273083fe6","modified":1629269481801},{"_id":"public/tags/index.html","hash":"f82c614e3018a5886d74a5a321536c99d094dbe7","modified":1629970386080},{"_id":"public/categories/index.html","hash":"583c9e3970c9f444c0a2b5c581e4c39fea5b6a2a","modified":1629970386080},{"_id":"public/categories/小技术/index.html","hash":"4b1b119a988cb82f458c1fc36ad3a07e203bf1ad","modified":1629970386080},{"_id":"public/index.html","hash":"67ebbca0ea8d75c6cf1b3caeb495d1da793a321e","modified":1629970386080},{"_id":"public/archives/index.html","hash":"cefcdedc3b823a1b7caf376af2db171a49bc4a62","modified":1629970386080},{"_id":"public/archives/2021/index.html","hash":"cefcdedc3b823a1b7caf376af2db171a49bc4a62","modified":1629970386080},{"_id":"public/archives/2021/08/index.html","hash":"cefcdedc3b823a1b7caf376af2db171a49bc4a62","modified":1629970386080},{"_id":"public/tags/vue/index.html","hash":"33bdd1b07976a6a8d8b92aa1b2df7f8280872c20","modified":1629970386080},{"_id":"public/tags/双向绑定/index.html","hash":"9b1aeb134b73cc514544079d77aaf5afc0cd7c9c","modified":1629970386080},{"_id":"public/tags/观察者模式/index.html","hash":"a9196f2e484f9fda2b217d3d3ef1f3440611350b","modified":1629970386080},{"_id":"public/tags/单页面/index.html","hash":"0cc2d0c00ed9323d5e6bf994dcb0b806e111bea8","modified":1629970386080},{"_id":"public/2021/08/18/vueRouter/index.html","hash":"72a6b37abdd0d98f4859a63cf563709805982b09","modified":1629453111693},{"_id":"public/2021/08/17/vue/index.html","hash":"547fe90c2cdf31ea4b96423c71ce4c346bdf856f","modified":1629970386080},{"_id":"public/2021/08/17/hello-world/index.html","hash":"aa2c4d59a8666c371a44aa4abb16eb0f11b720c6","modified":1629364501628},{"_id":"public/tags/路由/index.html","hash":"e6cd94acfc61765c1ff8f7bb5682c241f81530c5","modified":1629970386080},{"_id":"public/favicon.ico","hash":"cd1b610096d9c5c780fd2a7e24baaa78dada3163","modified":1629970386080},{"_id":"public/icons-192.png","hash":"8cd106d9039f1d5aa8163ecd4a5e352058a0f6cf","modified":1629970386080},{"_id":"public/icons-512.png","hash":"c2cd59a7712738831ee0cca4338343d407777a4b","modified":1629970386080},{"_id":"public/manifest.json","hash":"70ae21c5c320fbc0df5922a4baf3fa73d5343959","modified":1629970386080},{"_id":"public/js/script.js","hash":"8f0900b1b6bbd1fdc463fbc77f3deb5e598c9871","modified":1629970386080},{"_id":"public/css/style.css","hash":"13a3ef529ebae9ef63ce4f363dd8be7f4d0c0b33","modified":1629970386080},{"_id":"source/_posts/promise.md","hash":"32f19d9c59ab517dc0191123a5d920b84dd2c256","modified":1629970218909},{"_id":"public/tags/promise/index.html","hash":"f9a72f2b1ba130375b17c033728c8d2be3fd179e","modified":1629970386080},{"_id":"public/2021/08/16/promise/index.html","hash":"24b736573e9f2e15cde3fd21738d9ff42a102145","modified":1629453111693},{"_id":"public/2021/08/15/hello-world/index.html","hash":"be614a3f8930184d6b9a47d338b64a5821e8e0d5","modified":1629453111693},{"_id":"public/2021/08/13/vueRouter/index.html","hash":"bca217547aabe933eda38a6e2882ab59915e49c0","modified":1629970386080},{"_id":"public/2021/08/10/promise/index.html","hash":"f099e06bd5a3e71333dde79c91462dd15b8b2d02","modified":1629970386080},{"_id":"public/2021/08/08/hello-world/index.html","hash":"1f412fe49b5168e1b663e3d2ec355ba8cf7c0100","modified":1629970386080}],"Category":[{"name":"小技术","_id":"cksipd6qg00066cvmhp8we2tb"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---","date":"2021-08-18T02:42:13.489Z","updated":"2021-08-18T02:42:13.479Z","path":"tags/index.html","comments":1,"_id":"cksipd6q400006cvm3bv74hec","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"categories\"\nlayout: \"categories\"\n---\n","date":"2021-08-17T08:55:35.446Z","updated":"2021-08-17T08:53:08.612Z","path":"categories/index.html","comments":1,"_id":"cksipd6qb00026cvmbjyz7xdy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"vue响应式原理剖析及模拟实现","date":"2021-08-17T10:39:37.000Z","cover":"http://i0.hdslb.com/bfs/article/62ab79fcd20d1368b8039a78f16adbaa1e9b8d35.jpg","_content":"## vue响应式原理分析\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png)\n1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。  \n2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。  \n3、通过compiler对象解析模板和指令，即差值表达式和v-指令。  \n4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。  \n5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图\n\n## vue代码模拟实现\n### 1、项目结构\n![](https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png)\n#### myVue.html代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>差值表达式</div>\n        <div>{{name}}</div>\n        <div>{{age}}</div>\n        <div>v-text</div>\n        <div v-text=\"name\"></div>\n        <div v-text=\"age\"></div>\n        <div>v-html</div>\n        <div v-html=\"name\"></div>\n        <div v-html=\"age\"></div>\n        <div>v-model</div>\n        <input type=\"text\" v-model=\"name\">\n        <input type=\"text\" v-model=\"age\">\n    </div>\n    <script src=\"./js/dep.js\"></script>\n    <script src=\"./js/watcher.js\"></script>\n    <script src=\"./js/compiler.js\"></script>\n    <script src=\"./js/observer.js\"></script>\n    <script src=\"./js/myVue.js\"></script>\n<script>\n    const vm = new MyVue({\n        el: '#app',\n        data: {\n            name: '张三',\n            age: 50,\n            son: {\n                name: '李四',\n                age: 25\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n#### 页面展现\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png)\n### 2、myVue类实现\njs/myVue.js\n```javascript\nclass MyVue {\n  constructor(options) {\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || {};\n      this.$data = options.data || {};\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  }\n  _proxyData(data) {\n      Object.keys(data).forEach(key => {\n          Object.defineProperty(this, key, {\n              enumerable: true,\n              configurable: true,\n              set(v) {\n                  if (v === data[key]) return;\n                  data[key] = v;\n              },\n              get() {\n                  return data[key];\n              }\n          })\n      })\n  }\n}\n```\n### 3、Observer类实现\njs/Observer.js\n```javascript\nclass Observer {\n  constructor(data) {\n      this.walk(data);\n  }\n  walk(data) {\n      if (!data || typeof data !== 'object') return;\n      Object.keys(data).forEach(key => {\n          this.defineReactive(data, key, data[key]);\n      })\n  }\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) {\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, {\n          enumerable: true,\n          configurable: true,\n          set(v) {\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          },\n          get() {\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target && dep.subs.push(Dep.target);\n              return val;\n          }\n      })\n  }\n}\n```\n### 4、Compiler类实现\njs/compiler.js\n```javascript\nclass Compiler {\n    constructor(vm) {\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    }\n    compile(el) {\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node => {\n            if (this.isTextNode(node)) {\n                this.compileText(node);\n            } else if (this.isElementNode(node))  {\n                this.compileElement(node);\n            }\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes && node.childNodes.length) {\n                this.compile(node);\n            }\n        })\n    }\n    // 处理文本节点差值表达式\n    compileText(node) {\n        let reg = /\\{\\{(.+?)\\}\\}/; // 正则匹配差值表达是{{ xxx }}\n        let value = node.textContent;\n        if (reg.test(value)) {\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue => {\n                node.textContent = newValue;\n            });\n        }\n    }\n    // 处理元素节点\n    compileElement(node) {\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) {\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            }\n        })\n    }\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) {\n        let updateFn = this[attrName + 'Updater'];\n        updateFn && updateFn.call(this, node, this.vm[key], key);\n    }\n    // 处理v-text\n    textUpdater(node, val, key) {\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.textContent = newValue;\n        })\n    }\n    // 处理v-html\n    htmlUpdater(node, val, key) {\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue => {\n            node.innerHTML = newValue;\n        })\n    }\n    // 处理v-model\n    modelUpdater(node, val, key) {\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.value = newValue;\n        })\n        // 双向数据绑定\n        node.addEventListener('input', () => {\n            this.vm[key] = node.value;\n        })\n    }\n    // 判断当前节点是否是文本节点\n    isTextNode(node) {\n        return node.nodeType === 3;\n    }\n    // 判断当前节点是否是元素节点\n    isElementNode(node) {\n        return node.nodeType === 1;\n    }\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) {\n        return attrName.startsWith('v-');\n    }\n}\n```\n### 5、发布者Dep类实现\njs/dep.js\n```javascript\nclass Dep {\n    constructor() {\n        // 存储订阅者\n        this.subs = [];\n    }\n    // 添加订阅者\n    addSub(sub) {\n        // 订阅者都有一个update方法\n        if (sub && sub.update) {\n            this.subs.push(sub);\n        } \n    }\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() {\n        this.subs.forEach(sub => {\n            sub.update();\n        })\n    }\n}\n```\n### 6、订阅者Watcher类实现\njs/watcher.js\n```javascript\nclass Watcher {\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) {\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    }\n    update() {\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    }\n}\n```\n### 7、最终效果\n![image.png](https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png)\n\n![image.png](https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png)\n\n![image.png](https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png)\n\n## 结语\n本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术","source":"_posts/vue.md","raw":"---\ntitle: vue响应式原理剖析及模拟实现\ndate: 2021-08-17 18:39:37\ntags:\n - vue\n - 双向绑定\n - 观察者模式\ncover: http://i0.hdslb.com/bfs/article/62ab79fcd20d1368b8039a78f16adbaa1e9b8d35.jpg\n---\n## vue响应式原理分析\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png)\n1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。  \n2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。  \n3、通过compiler对象解析模板和指令，即差值表达式和v-指令。  \n4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。  \n5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图\n\n## vue代码模拟实现\n### 1、项目结构\n![](https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png)\n#### myVue.html代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>差值表达式</div>\n        <div>{{name}}</div>\n        <div>{{age}}</div>\n        <div>v-text</div>\n        <div v-text=\"name\"></div>\n        <div v-text=\"age\"></div>\n        <div>v-html</div>\n        <div v-html=\"name\"></div>\n        <div v-html=\"age\"></div>\n        <div>v-model</div>\n        <input type=\"text\" v-model=\"name\">\n        <input type=\"text\" v-model=\"age\">\n    </div>\n    <script src=\"./js/dep.js\"></script>\n    <script src=\"./js/watcher.js\"></script>\n    <script src=\"./js/compiler.js\"></script>\n    <script src=\"./js/observer.js\"></script>\n    <script src=\"./js/myVue.js\"></script>\n<script>\n    const vm = new MyVue({\n        el: '#app',\n        data: {\n            name: '张三',\n            age: 50,\n            son: {\n                name: '李四',\n                age: 25\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n#### 页面展现\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png)\n### 2、myVue类实现\njs/myVue.js\n```javascript\nclass MyVue {\n  constructor(options) {\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || {};\n      this.$data = options.data || {};\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  }\n  _proxyData(data) {\n      Object.keys(data).forEach(key => {\n          Object.defineProperty(this, key, {\n              enumerable: true,\n              configurable: true,\n              set(v) {\n                  if (v === data[key]) return;\n                  data[key] = v;\n              },\n              get() {\n                  return data[key];\n              }\n          })\n      })\n  }\n}\n```\n### 3、Observer类实现\njs/Observer.js\n```javascript\nclass Observer {\n  constructor(data) {\n      this.walk(data);\n  }\n  walk(data) {\n      if (!data || typeof data !== 'object') return;\n      Object.keys(data).forEach(key => {\n          this.defineReactive(data, key, data[key]);\n      })\n  }\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) {\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, {\n          enumerable: true,\n          configurable: true,\n          set(v) {\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          },\n          get() {\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target && dep.subs.push(Dep.target);\n              return val;\n          }\n      })\n  }\n}\n```\n### 4、Compiler类实现\njs/compiler.js\n```javascript\nclass Compiler {\n    constructor(vm) {\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    }\n    compile(el) {\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node => {\n            if (this.isTextNode(node)) {\n                this.compileText(node);\n            } else if (this.isElementNode(node))  {\n                this.compileElement(node);\n            }\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes && node.childNodes.length) {\n                this.compile(node);\n            }\n        })\n    }\n    // 处理文本节点差值表达式\n    compileText(node) {\n        let reg = /\\{\\{(.+?)\\}\\}/; // 正则匹配差值表达是{{ xxx }}\n        let value = node.textContent;\n        if (reg.test(value)) {\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue => {\n                node.textContent = newValue;\n            });\n        }\n    }\n    // 处理元素节点\n    compileElement(node) {\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) {\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            }\n        })\n    }\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) {\n        let updateFn = this[attrName + 'Updater'];\n        updateFn && updateFn.call(this, node, this.vm[key], key);\n    }\n    // 处理v-text\n    textUpdater(node, val, key) {\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.textContent = newValue;\n        })\n    }\n    // 处理v-html\n    htmlUpdater(node, val, key) {\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue => {\n            node.innerHTML = newValue;\n        })\n    }\n    // 处理v-model\n    modelUpdater(node, val, key) {\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.value = newValue;\n        })\n        // 双向数据绑定\n        node.addEventListener('input', () => {\n            this.vm[key] = node.value;\n        })\n    }\n    // 判断当前节点是否是文本节点\n    isTextNode(node) {\n        return node.nodeType === 3;\n    }\n    // 判断当前节点是否是元素节点\n    isElementNode(node) {\n        return node.nodeType === 1;\n    }\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) {\n        return attrName.startsWith('v-');\n    }\n}\n```\n### 5、发布者Dep类实现\njs/dep.js\n```javascript\nclass Dep {\n    constructor() {\n        // 存储订阅者\n        this.subs = [];\n    }\n    // 添加订阅者\n    addSub(sub) {\n        // 订阅者都有一个update方法\n        if (sub && sub.update) {\n            this.subs.push(sub);\n        } \n    }\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() {\n        this.subs.forEach(sub => {\n            sub.update();\n        })\n    }\n}\n```\n### 6、订阅者Watcher类实现\njs/watcher.js\n```javascript\nclass Watcher {\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) {\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    }\n    update() {\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    }\n}\n```\n### 7、最终效果\n![image.png](https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png)\n\n![image.png](https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png)\n\n![image.png](https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png)\n\n## 结语\n本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术","slug":"vue","published":1,"updated":"2021-08-19T09:07:49.814Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cksipd6q700016cvmclixdteq","content":"<h2 id=\"vue响应式原理分析\"><a href=\"#vue响应式原理分析\" class=\"headerlink\" title=\"vue响应式原理分析\"></a>vue响应式原理分析</h2><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png\"><br>1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。<br>2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。<br>3、通过compiler对象解析模板和指令，即差值表达式和v-指令。<br>4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。<br>5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图</p>\n<h2 id=\"vue代码模拟实现\"><a href=\"#vue代码模拟实现\" class=\"headerlink\" title=\"vue代码模拟实现\"></a>vue代码模拟实现</h2><h3 id=\"1、项目结构\"><a href=\"#1、项目结构\" class=\"headerlink\" title=\"1、项目结构\"></a>1、项目结构</h3><p><img src=\"https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png\"></p>\n<h4 id=\"myVue-html代码\"><a href=\"#myVue-html代码\" class=\"headerlink\" title=\"myVue.html代码\"></a>myVue.html代码</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;div&gt;差值表达式&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;v-text&lt;/div&gt;\n        &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-text=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-html&lt;/div&gt;\n        &lt;div v-html=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-html=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-model&lt;/div&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;./js/dep.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/compiler.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/myVue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    const vm = new MyVue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;张三&#39;,\n            age: 50,\n            son: &#123;\n                name: &#39;李四&#39;,\n                age: 25\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"页面展现\"><a href=\"#页面展现\" class=\"headerlink\" title=\"页面展现\"></a>页面展现</h4><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png\"></p>\n<h3 id=\"2、myVue类实现\"><a href=\"#2、myVue类实现\" class=\"headerlink\" title=\"2、myVue类实现\"></a>2、myVue类实现</h3><p>js/myVue.js</p>\n<pre><code class=\"javascript\">class MyVue &#123;\n  constructor(options) &#123;\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || &#123;&#125;;\n      this.$data = options.data || &#123;&#125;;\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === &#39;string&#39; ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  &#125;\n  _proxyData(data) &#123;\n      Object.keys(data).forEach(key =&gt; &#123;\n          Object.defineProperty(this, key, &#123;\n              enumerable: true,\n              configurable: true,\n              set(v) &#123;\n                  if (v === data[key]) return;\n                  data[key] = v;\n              &#125;,\n              get() &#123;\n                  return data[key];\n              &#125;\n          &#125;)\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"3、Observer类实现\"><a href=\"#3、Observer类实现\" class=\"headerlink\" title=\"3、Observer类实现\"></a>3、Observer类实现</h3><p>js/Observer.js</p>\n<pre><code class=\"javascript\">class Observer &#123;\n  constructor(data) &#123;\n      this.walk(data);\n  &#125;\n  walk(data) &#123;\n      if (!data || typeof data !== &#39;object&#39;) return;\n      Object.keys(data).forEach(key =&gt; &#123;\n          this.defineReactive(data, key, data[key]);\n      &#125;)\n  &#125;\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) &#123;\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, &#123;\n          enumerable: true,\n          configurable: true,\n          set(v) &#123;\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          &#125;,\n          get() &#123;\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target &amp;&amp; dep.subs.push(Dep.target);\n              return val;\n          &#125;\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4、Compiler类实现\"><a href=\"#4、Compiler类实现\" class=\"headerlink\" title=\"4、Compiler类实现\"></a>4、Compiler类实现</h3><p>js/compiler.js</p>\n<pre><code class=\"javascript\">class Compiler &#123;\n    constructor(vm) &#123;\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    &#125;\n    compile(el) &#123;\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node =&gt; &#123;\n            if (this.isTextNode(node)) &#123;\n                this.compileText(node);\n            &#125; else if (this.isElementNode(node))  &#123;\n                this.compileElement(node);\n            &#125;\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;\n                this.compile(node);\n            &#125;\n        &#125;)\n    &#125;\n    // 处理文本节点差值表达式\n    compileText(node) &#123;\n        let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/; // 正则匹配差值表达是&#123;&#123; xxx &#125;&#125;\n        let value = node.textContent;\n        if (reg.test(value)) &#123;\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue =&gt; &#123;\n                node.textContent = newValue;\n            &#125;);\n        &#125;\n    &#125;\n    // 处理元素节点\n    compileElement(node) &#123;\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr =&gt; &#123;\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) &#123;\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            &#125;\n        &#125;)\n    &#125;\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) &#123;\n        let updateFn = this[attrName + &#39;Updater&#39;];\n        updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key);\n    &#125;\n    // 处理v-text\n    textUpdater(node, val, key) &#123;\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.textContent = newValue;\n        &#125;)\n    &#125;\n    // 处理v-html\n    htmlUpdater(node, val, key) &#123;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.innerHTML = newValue;\n        &#125;)\n    &#125;\n    // 处理v-model\n    modelUpdater(node, val, key) &#123;\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.value = newValue;\n        &#125;)\n        // 双向数据绑定\n        node.addEventListener(&#39;input&#39;, () =&gt; &#123;\n            this.vm[key] = node.value;\n        &#125;)\n    &#125;\n    // 判断当前节点是否是文本节点\n    isTextNode(node) &#123;\n        return node.nodeType === 3;\n    &#125;\n    // 判断当前节点是否是元素节点\n    isElementNode(node) &#123;\n        return node.nodeType === 1;\n    &#125;\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) &#123;\n        return attrName.startsWith(&#39;v-&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5、发布者Dep类实现\"><a href=\"#5、发布者Dep类实现\" class=\"headerlink\" title=\"5、发布者Dep类实现\"></a>5、发布者Dep类实现</h3><p>js/dep.js</p>\n<pre><code class=\"javascript\">class Dep &#123;\n    constructor() &#123;\n        // 存储订阅者\n        this.subs = [];\n    &#125;\n    // 添加订阅者\n    addSub(sub) &#123;\n        // 订阅者都有一个update方法\n        if (sub &amp;&amp; sub.update) &#123;\n            this.subs.push(sub);\n        &#125; \n    &#125;\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() &#123;\n        this.subs.forEach(sub =&gt; &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"6、订阅者Watcher类实现\"><a href=\"#6、订阅者Watcher类实现\" class=\"headerlink\" title=\"6、订阅者Watcher类实现\"></a>6、订阅者Watcher类实现</h3><p>js/watcher.js</p>\n<pre><code class=\"javascript\">class Watcher &#123;\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) &#123;\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    &#125;\n    update() &#123;\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"7、最终效果\"><a href=\"#7、最终效果\" class=\"headerlink\" title=\"7、最终效果\"></a>7、最终效果</h3><p><img src=\"https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png\" alt=\"image.png\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue响应式原理分析\"><a href=\"#vue响应式原理分析\" class=\"headerlink\" title=\"vue响应式原理分析\"></a>vue响应式原理分析</h2><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png\"><br>1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。<br>2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。<br>3、通过compiler对象解析模板和指令，即差值表达式和v-指令。<br>4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。<br>5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图</p>\n<h2 id=\"vue代码模拟实现\"><a href=\"#vue代码模拟实现\" class=\"headerlink\" title=\"vue代码模拟实现\"></a>vue代码模拟实现</h2><h3 id=\"1、项目结构\"><a href=\"#1、项目结构\" class=\"headerlink\" title=\"1、项目结构\"></a>1、项目结构</h3><p><img src=\"https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png\"></p>\n<h4 id=\"myVue-html代码\"><a href=\"#myVue-html代码\" class=\"headerlink\" title=\"myVue.html代码\"></a>myVue.html代码</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;div&gt;差值表达式&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;v-text&lt;/div&gt;\n        &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-text=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-html&lt;/div&gt;\n        &lt;div v-html=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-html=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-model&lt;/div&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;./js/dep.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/compiler.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/myVue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    const vm = new MyVue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;张三&#39;,\n            age: 50,\n            son: &#123;\n                name: &#39;李四&#39;,\n                age: 25\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"页面展现\"><a href=\"#页面展现\" class=\"headerlink\" title=\"页面展现\"></a>页面展现</h4><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png\"></p>\n<h3 id=\"2、myVue类实现\"><a href=\"#2、myVue类实现\" class=\"headerlink\" title=\"2、myVue类实现\"></a>2、myVue类实现</h3><p>js/myVue.js</p>\n<pre><code class=\"javascript\">class MyVue &#123;\n  constructor(options) &#123;\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || &#123;&#125;;\n      this.$data = options.data || &#123;&#125;;\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === &#39;string&#39; ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  &#125;\n  _proxyData(data) &#123;\n      Object.keys(data).forEach(key =&gt; &#123;\n          Object.defineProperty(this, key, &#123;\n              enumerable: true,\n              configurable: true,\n              set(v) &#123;\n                  if (v === data[key]) return;\n                  data[key] = v;\n              &#125;,\n              get() &#123;\n                  return data[key];\n              &#125;\n          &#125;)\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"3、Observer类实现\"><a href=\"#3、Observer类实现\" class=\"headerlink\" title=\"3、Observer类实现\"></a>3、Observer类实现</h3><p>js/Observer.js</p>\n<pre><code class=\"javascript\">class Observer &#123;\n  constructor(data) &#123;\n      this.walk(data);\n  &#125;\n  walk(data) &#123;\n      if (!data || typeof data !== &#39;object&#39;) return;\n      Object.keys(data).forEach(key =&gt; &#123;\n          this.defineReactive(data, key, data[key]);\n      &#125;)\n  &#125;\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) &#123;\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, &#123;\n          enumerable: true,\n          configurable: true,\n          set(v) &#123;\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          &#125;,\n          get() &#123;\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target &amp;&amp; dep.subs.push(Dep.target);\n              return val;\n          &#125;\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4、Compiler类实现\"><a href=\"#4、Compiler类实现\" class=\"headerlink\" title=\"4、Compiler类实现\"></a>4、Compiler类实现</h3><p>js/compiler.js</p>\n<pre><code class=\"javascript\">class Compiler &#123;\n    constructor(vm) &#123;\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    &#125;\n    compile(el) &#123;\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node =&gt; &#123;\n            if (this.isTextNode(node)) &#123;\n                this.compileText(node);\n            &#125; else if (this.isElementNode(node))  &#123;\n                this.compileElement(node);\n            &#125;\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;\n                this.compile(node);\n            &#125;\n        &#125;)\n    &#125;\n    // 处理文本节点差值表达式\n    compileText(node) &#123;\n        let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/; // 正则匹配差值表达是&#123;&#123; xxx &#125;&#125;\n        let value = node.textContent;\n        if (reg.test(value)) &#123;\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue =&gt; &#123;\n                node.textContent = newValue;\n            &#125;);\n        &#125;\n    &#125;\n    // 处理元素节点\n    compileElement(node) &#123;\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr =&gt; &#123;\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) &#123;\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            &#125;\n        &#125;)\n    &#125;\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) &#123;\n        let updateFn = this[attrName + &#39;Updater&#39;];\n        updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key);\n    &#125;\n    // 处理v-text\n    textUpdater(node, val, key) &#123;\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.textContent = newValue;\n        &#125;)\n    &#125;\n    // 处理v-html\n    htmlUpdater(node, val, key) &#123;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.innerHTML = newValue;\n        &#125;)\n    &#125;\n    // 处理v-model\n    modelUpdater(node, val, key) &#123;\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.value = newValue;\n        &#125;)\n        // 双向数据绑定\n        node.addEventListener(&#39;input&#39;, () =&gt; &#123;\n            this.vm[key] = node.value;\n        &#125;)\n    &#125;\n    // 判断当前节点是否是文本节点\n    isTextNode(node) &#123;\n        return node.nodeType === 3;\n    &#125;\n    // 判断当前节点是否是元素节点\n    isElementNode(node) &#123;\n        return node.nodeType === 1;\n    &#125;\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) &#123;\n        return attrName.startsWith(&#39;v-&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5、发布者Dep类实现\"><a href=\"#5、发布者Dep类实现\" class=\"headerlink\" title=\"5、发布者Dep类实现\"></a>5、发布者Dep类实现</h3><p>js/dep.js</p>\n<pre><code class=\"javascript\">class Dep &#123;\n    constructor() &#123;\n        // 存储订阅者\n        this.subs = [];\n    &#125;\n    // 添加订阅者\n    addSub(sub) &#123;\n        // 订阅者都有一个update方法\n        if (sub &amp;&amp; sub.update) &#123;\n            this.subs.push(sub);\n        &#125; \n    &#125;\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() &#123;\n        this.subs.forEach(sub =&gt; &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"6、订阅者Watcher类实现\"><a href=\"#6、订阅者Watcher类实现\" class=\"headerlink\" title=\"6、订阅者Watcher类实现\"></a>6、订阅者Watcher类实现</h3><p>js/watcher.js</p>\n<pre><code class=\"javascript\">class Watcher &#123;\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) &#123;\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    &#125;\n    update() &#123;\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"7、最终效果\"><a href=\"#7、最终效果\" class=\"headerlink\" title=\"7、最终效果\"></a>7、最终效果</h3><p><img src=\"https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png\" alt=\"image.png\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术</p>\n"},{"title":"blog搭建流程","date":"2021-08-08T00:00:00.000Z","cover":"http://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3d63e3c569d0a304e251f5847.jpg","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### 云游的小安利搭建详细教程\n[云游的小安利搭建详细教程](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n","source":"_posts/hello-world.md","raw":"---\ntitle: blog搭建流程\ncategories: 小技术\ndate: '2021-08-08'\ncover: http://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3d63e3c569d0a304e251f5847.jpg\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### 云游的小安利搭建详细教程\n[云游的小安利搭建详细教程](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n","slug":"hello-world","published":1,"updated":"2021-08-26T08:05:08.493Z","_id":"cksipd6qb00036cvmfdc54s6o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"云游的小安利搭建详细教程\"><a href=\"#云游的小安利搭建详细教程\" class=\"headerlink\" title=\"云游的小安利搭建详细教程\"></a>云游的小安利搭建详细教程</h3><p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">云游的小安利搭建详细教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"云游的小安利搭建详细教程\"><a href=\"#云游的小安利搭建详细教程\" class=\"headerlink\" title=\"云游的小安利搭建详细教程\"></a>云游的小安利搭建详细教程</h3><p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">云游的小安利搭建详细教程</a></p>\n"},{"title":"vueRouter原理剖析","date":"2021-08-13T10:39:37.000Z","cover":"http://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3ef5ed4599c0a304e251f586a.jpg","_content":"## 原理分析\n1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install  \n2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换  \n3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  \n\n## 代码实现\n```javascript\nlet _Vue = null;\nexport default class VueRouter {\n    // 供Vue.use调用\n    static install(Vue) {\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) {\n            return;\n        } \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin({\n            beforeCreate() {\n                // 此处的this指向Vue实例\n                if (this.$options.router) { // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                } \n            }\n        })\n     }\n     constructor(options) {\n        this.options = options;\n        this.routeMap = {};\n        this.data = _Vue.observable({ // 将data中属性变为响应式数据\n            current: '/'\n        })\n    }\n    init() {\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    }\n    createRouteMap() {\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component;\n        })\n    }\n    initComponents() {\n        let self = this;\n        // 定义router-link组件\n        _Vue.component('router-link', {\n            props: { // 接受的参数\n                to: String\n            },\n            render(h) { // 渲染模板，渲染成a标签\n                return h('a', {\n                    attrs: {\n                        href: this.to\n                    },\n                    on: {\n                        click: this.clickHandle\n                    }\n                }, [this.$slots.default]) // router-link中的内容\n            },\n            methods: {\n                 clickHandle(e) {\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState({}, '', this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 }\n            }\n        });\n        // 定义router-view\n        _Vue.component('router-view', {\n            render(h) { // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            }\n        })\n    }\n    initEvent() {\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener('popstate', () => {\n            this.data.current = window.location.pathname;\n        })\n    }\n}\n```\n## 代码验证\n1、使用Vue脚手架工具，构建一个带有vueRouter的项目\n```bash\nnpm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n> Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n>(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n > 2.x\n   3.x\n\n```\n2、将实现代码写入myViewRouter.js中\n3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter\n```javascript\nimport VueRouter from '../myViewRouter/myViewRouter' // 引入自己的路径\n```\n4、开始运行模拟实现\n\n","source":"_posts/vueRouter.md","raw":"---\ntitle: vueRouter原理剖析\ndate: 2021-08-13 18:39:37\ntags: \n    - vue \n    - 单页面 \n    - 路由\ncover: http://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3ef5ed4599c0a304e251f586a.jpg\n---\n## 原理分析\n1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install  \n2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换  \n3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  \n\n## 代码实现\n```javascript\nlet _Vue = null;\nexport default class VueRouter {\n    // 供Vue.use调用\n    static install(Vue) {\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) {\n            return;\n        } \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin({\n            beforeCreate() {\n                // 此处的this指向Vue实例\n                if (this.$options.router) { // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                } \n            }\n        })\n     }\n     constructor(options) {\n        this.options = options;\n        this.routeMap = {};\n        this.data = _Vue.observable({ // 将data中属性变为响应式数据\n            current: '/'\n        })\n    }\n    init() {\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    }\n    createRouteMap() {\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component;\n        })\n    }\n    initComponents() {\n        let self = this;\n        // 定义router-link组件\n        _Vue.component('router-link', {\n            props: { // 接受的参数\n                to: String\n            },\n            render(h) { // 渲染模板，渲染成a标签\n                return h('a', {\n                    attrs: {\n                        href: this.to\n                    },\n                    on: {\n                        click: this.clickHandle\n                    }\n                }, [this.$slots.default]) // router-link中的内容\n            },\n            methods: {\n                 clickHandle(e) {\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState({}, '', this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 }\n            }\n        });\n        // 定义router-view\n        _Vue.component('router-view', {\n            render(h) { // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            }\n        })\n    }\n    initEvent() {\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener('popstate', () => {\n            this.data.current = window.location.pathname;\n        })\n    }\n}\n```\n## 代码验证\n1、使用Vue脚手架工具，构建一个带有vueRouter的项目\n```bash\nnpm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n> Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n>(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n > 2.x\n   3.x\n\n```\n2、将实现代码写入myViewRouter.js中\n3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter\n```javascript\nimport VueRouter from '../myViewRouter/myViewRouter' // 引入自己的路径\n```\n4、开始运行模拟实现\n\n","slug":"vueRouter","published":1,"updated":"2021-08-26T08:01:02.207Z","_id":"ckssmzt2e001gb0vm6vxo5nyw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install<br>2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换<br>3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  </p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"javascript\">let _Vue = null;\nexport default class VueRouter &#123;\n    // 供Vue.use调用\n    static install(Vue) &#123;\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) &#123;\n            return;\n        &#125; \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin(&#123;\n            beforeCreate() &#123;\n                // 此处的this指向Vue实例\n                if (this.$options.router) &#123; // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                &#125; \n            &#125;\n        &#125;)\n     &#125;\n     constructor(options) &#123;\n        this.options = options;\n        this.routeMap = &#123;&#125;;\n        this.data = _Vue.observable(&#123; // 将data中属性变为响应式数据\n            current: &#39;/&#39;\n        &#125;)\n    &#125;\n    init() &#123;\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    &#125;\n    createRouteMap() &#123;\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route =&gt; &#123;\n            this.routeMap[route.path] = route.component;\n        &#125;)\n    &#125;\n    initComponents() &#123;\n        let self = this;\n        // 定义router-link组件\n        _Vue.component(&#39;router-link&#39;, &#123;\n            props: &#123; // 接受的参数\n                to: String\n            &#125;,\n            render(h) &#123; // 渲染模板，渲染成a标签\n                return h(&#39;a&#39;, &#123;\n                    attrs: &#123;\n                        href: this.to\n                    &#125;,\n                    on: &#123;\n                        click: this.clickHandle\n                    &#125;\n                &#125;, [this.$slots.default]) // router-link中的内容\n            &#125;,\n            methods: &#123;\n                 clickHandle(e) &#123;\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState(&#123;&#125;, &#39;&#39;, this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 &#125;\n            &#125;\n        &#125;);\n        // 定义router-view\n        _Vue.component(&#39;router-view&#39;, &#123;\n            render(h) &#123; // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            &#125;\n        &#125;)\n    &#125;\n    initEvent() &#123;\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener(&#39;popstate&#39;, () =&gt; &#123;\n            this.data.current = window.location.pathname;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"代码验证\"><a href=\"#代码验证\" class=\"headerlink\" title=\"代码验证\"></a>代码验证</h2><p>1、使用Vue脚手架工具，构建一个带有vueRouter的项目</p>\n<pre><code class=\"bash\">npm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n&gt;(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n &gt; 2.x\n   3.x\n</code></pre>\n<p>2、将实现代码写入myViewRouter.js中<br>3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter</p>\n<pre><code class=\"javascript\">import VueRouter from &#39;../myViewRouter/myViewRouter&#39; // 引入自己的路径\n</code></pre>\n<p>4、开始运行模拟实现</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install<br>2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换<br>3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  </p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"javascript\">let _Vue = null;\nexport default class VueRouter &#123;\n    // 供Vue.use调用\n    static install(Vue) &#123;\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) &#123;\n            return;\n        &#125; \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin(&#123;\n            beforeCreate() &#123;\n                // 此处的this指向Vue实例\n                if (this.$options.router) &#123; // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                &#125; \n            &#125;\n        &#125;)\n     &#125;\n     constructor(options) &#123;\n        this.options = options;\n        this.routeMap = &#123;&#125;;\n        this.data = _Vue.observable(&#123; // 将data中属性变为响应式数据\n            current: &#39;/&#39;\n        &#125;)\n    &#125;\n    init() &#123;\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    &#125;\n    createRouteMap() &#123;\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route =&gt; &#123;\n            this.routeMap[route.path] = route.component;\n        &#125;)\n    &#125;\n    initComponents() &#123;\n        let self = this;\n        // 定义router-link组件\n        _Vue.component(&#39;router-link&#39;, &#123;\n            props: &#123; // 接受的参数\n                to: String\n            &#125;,\n            render(h) &#123; // 渲染模板，渲染成a标签\n                return h(&#39;a&#39;, &#123;\n                    attrs: &#123;\n                        href: this.to\n                    &#125;,\n                    on: &#123;\n                        click: this.clickHandle\n                    &#125;\n                &#125;, [this.$slots.default]) // router-link中的内容\n            &#125;,\n            methods: &#123;\n                 clickHandle(e) &#123;\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState(&#123;&#125;, &#39;&#39;, this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 &#125;\n            &#125;\n        &#125;);\n        // 定义router-view\n        _Vue.component(&#39;router-view&#39;, &#123;\n            render(h) &#123; // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            &#125;\n        &#125;)\n    &#125;\n    initEvent() &#123;\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener(&#39;popstate&#39;, () =&gt; &#123;\n            this.data.current = window.location.pathname;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"代码验证\"><a href=\"#代码验证\" class=\"headerlink\" title=\"代码验证\"></a>代码验证</h2><p>1、使用Vue脚手架工具，构建一个带有vueRouter的项目</p>\n<pre><code class=\"bash\">npm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n&gt;(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n &gt; 2.x\n   3.x\n</code></pre>\n<p>2、将实现代码写入myViewRouter.js中<br>3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter</p>\n<pre><code class=\"javascript\">import VueRouter from &#39;../myViewRouter/myViewRouter&#39; // 引入自己的路径\n</code></pre>\n<p>4、开始运行模拟实现</p>\n"},{"title":"promise原理剖析及模拟实现","date":"2021-08-10T10:39:37.000Z","cover":"http://ww3.sinaimg.cn/large/d2e27164gw1fbmwbgf0mij21hc0u0487.jpg","_content":"\n## promise原理解析及模拟实现\n### promise原理\n1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法  \n2、执行器方法接收两个参数，分别是resolve方法和reject方法  \n3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending  \n4、Promise的resolve、reject方法是用来改变状态的 resolve: pending => fulfilled, reject: pending => rejected，一旦状态确定就不可修改\n5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调  \n6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因\n\n### 代码实现\n#### 1、初步实现\n```javascript\n// --------------Promise代码--------------\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        resolve(i);\n    } else {\n        reject('不是偶数')\n    }\n})\npromise.then((val) => {\n    console.log(val);\n}, (reason) => {\n    console.log(reason);\n})\n```\n思考：  \n1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程  \n2、如果resolve和reject是异步调用，那多次执行then方法  \n上面代码是否满足这两种情况？\n\n#### 2、二次实现\n```javascript\n// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback && this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback && this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        } else { // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        setTimeout(() => {\n            resolve(i);\n        }, 2000)\n    } else {\n        setTimeout(() => {\n            reject('不是偶数');\n        }, 2000)\n    }\n})\npromise.then((val) => {\n    console.log('第一次',val);\n}, (reason) => {\n    console.log(reason);\n})\npromise.then((val) => {\n    console.log('第二次',val);\n}, (reason) => {\n    console.log('第二次', reason);\n})\n```\n思考：  \n1、then方法链式调用  \n2、then方法链式调用可以不传回调  \n上面代码是否满足？ \n\n```javascript\n// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n```\n\n\n\n\n","source":"_posts/promise.md","raw":"---\ntitle: promise原理剖析及模拟实现\ndate: 2021-08-10 18:39:37\ntags: \n    - promise \ncover: http://ww3.sinaimg.cn/large/d2e27164gw1fbmwbgf0mij21hc0u0487.jpg\n---\n\n## promise原理解析及模拟实现\n### promise原理\n1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法  \n2、执行器方法接收两个参数，分别是resolve方法和reject方法  \n3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending  \n4、Promise的resolve、reject方法是用来改变状态的 resolve: pending => fulfilled, reject: pending => rejected，一旦状态确定就不可修改\n5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调  \n6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因\n\n### 代码实现\n#### 1、初步实现\n```javascript\n// --------------Promise代码--------------\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        resolve(i);\n    } else {\n        reject('不是偶数')\n    }\n})\npromise.then((val) => {\n    console.log(val);\n}, (reason) => {\n    console.log(reason);\n})\n```\n思考：  \n1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程  \n2、如果resolve和reject是异步调用，那多次执行then方法  \n上面代码是否满足这两种情况？\n\n#### 2、二次实现\n```javascript\n// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback && this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback && this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        } else { // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        setTimeout(() => {\n            resolve(i);\n        }, 2000)\n    } else {\n        setTimeout(() => {\n            reject('不是偶数');\n        }, 2000)\n    }\n})\npromise.then((val) => {\n    console.log('第一次',val);\n}, (reason) => {\n    console.log(reason);\n})\npromise.then((val) => {\n    console.log('第二次',val);\n}, (reason) => {\n    console.log('第二次', reason);\n})\n```\n思考：  \n1、then方法链式调用  \n2、then方法链式调用可以不传回调  \n上面代码是否满足？ \n\n```javascript\n// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n```\n\n\n\n\n","slug":"promise","published":1,"updated":"2021-08-26T09:30:18.909Z","_id":"cksspqlja001kb0vm992ncjf5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"promise原理解析及模拟实现\"><a href=\"#promise原理解析及模拟实现\" class=\"headerlink\" title=\"promise原理解析及模拟实现\"></a>promise原理解析及模拟实现</h2><h3 id=\"promise原理\"><a href=\"#promise原理\" class=\"headerlink\" title=\"promise原理\"></a>promise原理</h3><p>1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法<br>2、执行器方法接收两个参数，分别是resolve方法和reject方法<br>3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending<br>4、Promise的resolve、reject方法是用来改变状态的 resolve: pending =&gt; fulfilled, reject: pending =&gt; rejected，一旦状态确定就不可修改<br>5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调<br>6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"1、初步实现\"><a href=\"#1、初步实现\" class=\"headerlink\" title=\"1、初步实现\"></a>1、初步实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        resolve(i);\n    &#125; else &#123;\n        reject(&#39;不是偶数&#39;)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程<br>2、如果resolve和reject是异步调用，那多次执行then方法<br>上面代码是否满足这两种情况？</p>\n<h4 id=\"2、二次实现\"><a href=\"#2、二次实现\" class=\"headerlink\" title=\"2、二次实现\"></a>2、二次实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback &amp;&amp; this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback &amp;&amp; this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125; else &#123; // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(i);\n        &#125;, 2000)\n    &#125; else &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;不是偶数&#39;);\n        &#125;, 2000)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第一次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第二次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(&#39;第二次&#39;, reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、then方法链式调用<br>2、then方法链式调用可以不传回调<br>上面代码是否满足？ </p>\n<pre><code class=\"javascript\">// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"promise原理解析及模拟实现\"><a href=\"#promise原理解析及模拟实现\" class=\"headerlink\" title=\"promise原理解析及模拟实现\"></a>promise原理解析及模拟实现</h2><h3 id=\"promise原理\"><a href=\"#promise原理\" class=\"headerlink\" title=\"promise原理\"></a>promise原理</h3><p>1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法<br>2、执行器方法接收两个参数，分别是resolve方法和reject方法<br>3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending<br>4、Promise的resolve、reject方法是用来改变状态的 resolve: pending =&gt; fulfilled, reject: pending =&gt; rejected，一旦状态确定就不可修改<br>5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调<br>6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"1、初步实现\"><a href=\"#1、初步实现\" class=\"headerlink\" title=\"1、初步实现\"></a>1、初步实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        resolve(i);\n    &#125; else &#123;\n        reject(&#39;不是偶数&#39;)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程<br>2、如果resolve和reject是异步调用，那多次执行then方法<br>上面代码是否满足这两种情况？</p>\n<h4 id=\"2、二次实现\"><a href=\"#2、二次实现\" class=\"headerlink\" title=\"2、二次实现\"></a>2、二次实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback &amp;&amp; this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback &amp;&amp; this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125; else &#123; // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(i);\n        &#125;, 2000)\n    &#125; else &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;不是偶数&#39;);\n        &#125;, 2000)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第一次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第二次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(&#39;第二次&#39;, reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、then方法链式调用<br>2、then方法链式调用可以不传回调<br>上面代码是否满足？ </p>\n<pre><code class=\"javascript\">// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cksipd6qb00036cvmfdc54s6o","category_id":"cksipd6qg00066cvmhp8we2tb","_id":"cksipd6qi00096cvmammaf1b7"}],"PostTag":[{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qd00046cvmdqkocyb1","_id":"cksipd6qk000b6cvmgqgd6lsq"},{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qh00076cvmhr7t6j01","_id":"cksipd6qk000c6cvm8ehx4ijz"},{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qi00086cvmgb3r9av0","_id":"cksipd6qk000e6cvm9tn12ikz"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qd00046cvmdqkocyb1","_id":"ckssmzt2g001hb0vmbkeufe88"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qk000d6cvm1ftv1q54","_id":"ckssmzt2g001ib0vm5rp92ll4"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qk000f6cvm5rdy2kxg","_id":"ckssmzt2h001jb0vmdf5m31fk"},{"post_id":"cksspqlja001kb0vm992ncjf5","tag_id":"cksk3oveu0001cwvmcrak8r91","_id":"cksspqljb001lb0vm88whahsz"}],"Tag":[{"name":"vue","_id":"cksipd6qd00046cvmdqkocyb1"},{"name":"双向绑定","_id":"cksipd6qh00076cvmhr7t6j01"},{"name":"观察者模式","_id":"cksipd6qi00086cvmgb3r9av0"},{"name":"单页面","_id":"cksipd6qk000d6cvm1ftv1q54"},{"name":"路由","_id":"cksipd6qk000f6cvm5rdy2kxg"},{"name":"promise","_id":"cksk3oveu0001cwvmcrak8r91"}]}}