{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/flex-block/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/flex-block/source/icons-192.png","path":"icons-192.png","modified":0,"renderable":1},{"_id":"themes/flex-block/source/icons-512.png","path":"icons-512.png","modified":0,"renderable":1},{"_id":"themes/flex-block/source/manifest.json","path":"manifest.json","modified":0,"renderable":1},{"_id":"themes/flex-block/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/flex-block/source/js/script.js","path":"js/script.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/vue.md","hash":"12a9209267ff683d25b798c14659cba46a936a52","modified":1641785128348},{"_id":"source/_posts/hello-world.md","hash":"fa765ca05e7ed58d7c12ae5f646907d5a1843363","modified":1641785128347},{"_id":"source/_posts/vueRouter.md","hash":"420909d12e84f7c41bec61aa5675efe0e13b959c","modified":1641785128348},{"_id":"source/tags/index.md","hash":"77738dafd6e79edc4816aca40d2bfd706905450b","modified":1629254533479},{"_id":"source/categories/index.md","hash":"30e8b5db11dfd7b1e5e881fe97f29334d8a34e22","modified":1629190388612},{"_id":"themes/flex-block/.gitignore","hash":"705b1b2062454bbf1210389b79ba6e61c3534417","modified":1629269481784},{"_id":"themes/flex-block/LICENSE","hash":"b39804556d3cc20997aca34c37ff896235078e86","modified":1629269481784},{"_id":"themes/flex-block/README.md","hash":"a73f77abcc04864be5fb8070a0e65f49ebe90a56","modified":1629269481784},{"_id":"themes/flex-block/_config.yml","hash":"fc9d59e0a9784adf462d2e04a285dd15d3526222","modified":1641789531358},{"_id":"themes/flex-block/layout/archive.ejs","hash":"31199b59d95f43e89c78df799735bb03b4f2cdc6","modified":1629269481793},{"_id":"themes/flex-block/layout/category.ejs","hash":"5551f6309ac4f835bd135ebb35fd40ba961f09b3","modified":1629269481794},{"_id":"themes/flex-block/layout/index.ejs","hash":"b2d5cf681e351c2cdfd5f549bddc4f428812fd36","modified":1629269481794},{"_id":"themes/flex-block/layout/layout.ejs","hash":"0024457e6e44e810e5cc62e6d571d64c0ec36e33","modified":1629269481794},{"_id":"themes/flex-block/layout/page.ejs","hash":"4aaf6496c9e4c61355bbed51ea0bf15023d8bcf3","modified":1629269481794},{"_id":"themes/flex-block/layout/post.ejs","hash":"f4de584f9181669b301e43c4f30439f57c959108","modified":1629269481794},{"_id":"themes/flex-block/layout/tag.ejs","hash":"4621d964e6505fdc19ae270918ea08356cc5c789","modified":1629269481794},{"_id":"themes/flex-block/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1629269481785},{"_id":"themes/flex-block/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1629269481785},{"_id":"themes/flex-block/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1629269481785},{"_id":"themes/flex-block/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1629269481785},{"_id":"themes/flex-block/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1629269481785},{"_id":"themes/flex-block/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1629269481786},{"_id":"themes/flex-block/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1629269481786},{"_id":"themes/flex-block/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1629269481786},{"_id":"themes/flex-block/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1629269481786},{"_id":"themes/flex-block/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1629269481787},{"_id":"themes/flex-block/languages/zh-CN.yml","hash":"fb8f221242b3997833189f11cd14407a867de3b8","modified":1629269481787},{"_id":"themes/flex-block/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1629269481787},{"_id":"themes/flex-block/source/favicon.ico","hash":"cd1b610096d9c5c780fd2a7e24baaa78dada3163","modified":1629269481806},{"_id":"themes/flex-block/source/icons-192.png","hash":"8cd106d9039f1d5aa8163ecd4a5e352058a0f6cf","modified":1629269481806},{"_id":"themes/flex-block/source/manifest.json","hash":"6689646167bbe5bc836615a0c2019ea9aaa9e015","modified":1629269481808},{"_id":"themes/flex-block/scripts/index.js","hash":"80eb0126ace5be17be33f4ee1442061e79aa9e8f","modified":1629269481801},{"_id":"themes/flex-block/layout/_partial/article-list.ejs","hash":"33ce0492d8b3731d99f4ddf98664841770400777","modified":1629269481787},{"_id":"themes/flex-block/layout/_partial/footer-other.ejs","hash":"9e93e20f3e3ded687abe00a6478e3c4dbfff479e","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/content.ejs","hash":"ff5fb3bd02681529ce3f6f52d74e11c951bc5e83","modified":1629269481787},{"_id":"themes/flex-block/layout/_partial/footer-script.ejs","hash":"2af1fd98adfd3beafcbaf5555781fcccb910451c","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/footer.ejs","hash":"1dc4ef7064687955c3e37d79597258166c33110c","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/header.ejs","hash":"903c358d8f46488110a6462bc710546a755c50ba","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/nav.ejs","hash":"e58516a49b3997d9f2fe2bcd6bcced97b3e6ecd6","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/page.ejs","hash":"75cb1422782f264a1e3e3dc407ba26d2510595c3","modified":1629269481789},{"_id":"themes/flex-block/layout/_partial/pagination.ejs","hash":"22d60f90cf93b7a80ab1dc044fbf5808a723872a","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-article.svg","hash":"f89ab250586cf0bd8108b77e48a5288f1d0dd512","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-categories.svg","hash":"cfe4012051132281255e211c28971e05726cdc43","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-tags.svg","hash":"0d974ce6d089d08ef009ad56d1b5d66bf9c2c1e6","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/icon-notice.svg","hash":"0d2f705ca65673eda3d38420aa512d83fcbc1e72","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-toc.svg","hash":"05d2eecfb27deade461f25b2a396c230e18cd6b4","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-github.svg","hash":"880c135b980866f77047cd4507f5bf8671934333","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-ins.svg","hash":"aad8cb2136a7c8af682d9c9dae726b80ee1b57dd","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-twitter.svg","hash":"acb180ecf694e6b91a309e9247d691200f5540ac","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-weibo.svg","hash":"a10c19805388d60e9532a44db09f4d117fb4f1cf","modified":1629269481791},{"_id":"themes/flex-block/layout/_svg/social-zhihu.svg","hash":"9f46e99ec2a82ab4d85f38a6771378cddd83a70a","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/article-nav.ejs","hash":"8df3b527e6153323c8ded33768bd5e5267dfa422","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/category.ejs","hash":"488d6e93a6240d00d0c60c9f104f4304400415ba","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/date.ejs","hash":"5c275ec71f7ce628599683393ae71cf95196f71f","modified":1629269481792},{"_id":"themes/flex-block/layout/_widget/comment.ejs","hash":"1764ba8abe7ba34748e3603fc536a73404037964","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/tag.ejs","hash":"2a1642735fe62363cee1eeeb09a3d36c2e8ac00e","modified":1629269481792},{"_id":"themes/flex-block/layout/_widget/widget-author.ejs","hash":"d3bb8143f405d39734b28216f31a5a7b26691bab","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-categorys.ejs","hash":"588237737f87a0ff69d00605c868c1297054d573","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-notice.ejs","hash":"0a1ec45028b2abd123bb6a96017168fd55759971","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-tags.ejs","hash":"8c360bf72e85a4cf48c6064b44a64828d059285a","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-toc.ejs","hash":"0607e05641735d1fea7c74bc3c5b5f41f3bfb16f","modified":1629269481793},{"_id":"themes/flex-block/layout/plug-in/aplayer.ejs","hash":"438336577656019044851a9fd534b42f954aa51d","modified":1629269481794},{"_id":"themes/flex-block/layout/plug-in/dplayer.ejs","hash":"b328a419bdfee2fa96d8b64805db854d069d35ea","modified":1629269481794},{"_id":"themes/flex-block/source/css/style.styl","hash":"c56dc27939e0ca92b2e3f3e6119eeb654a198ec6","modified":1629269481806},{"_id":"themes/flex-block/source/js/script.js","hash":"df8e22b2f98a9c9c4547f1bb0cc73f37180ff790","modified":1629269481808},{"_id":"themes/flex-block/source/css/_partial/card.styl","hash":"458daa8aec35a5352d82bcd42ea68ac13a875b75","modified":1641789531380},{"_id":"themes/flex-block/source/css/_partial/content.styl","hash":"6417486290b19661228f6cced736ccbc10fdd3e5","modified":1629269481803},{"_id":"themes/flex-block/source/css/_partial/header.styl","hash":"c657c1bfbf984e14f1e593a89fab330d442971be","modified":1641789531381},{"_id":"themes/flex-block/source/css/_partial/footer.styl","hash":"11cf25e1999463aeec061c23ca7d32ee7dbc783d","modified":1629269481804},{"_id":"themes/flex-block/source/css/_partial/nav.styl","hash":"891257e01cc805a5cfbf7298b44f24616a22d8fb","modified":1641789531381},{"_id":"themes/flex-block/source/css/_partial/page.styl","hash":"cfc59a5969a140997dbe7b5a97e816b5f54d4a03","modified":1629269481804},{"_id":"themes/flex-block/source/css/_partial/pagination.styl","hash":"268bb486fc8682aa7e8e2417211c84cd1d5da264","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/mixins.styl","hash":"2189d5e686410ecc79c4e8e357dc0737965d295d","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/theme.styl","hash":"68fea7a3bf7d2e5cad165fb096efa74bcc8f3023","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/variables.styl","hash":"1c086d4ad292550acfa1e291f4dfa355c97f506e","modified":1629269481805},{"_id":"themes/flex-block/source/icons-512.png","hash":"c2cd59a7712738831ee0cca4338343d407777a4b","modified":1629269481807},{"_id":"themes/flex-block/screenshots/flex-block--post.jpeg","hash":"bc607db875e42fe2c82ed5130c07d67cca5adc41","modified":1629269481799},{"_id":"themes/flex-block/screenshots/flex-block--home.jpeg","hash":"7f6c738298108020ab2e4918592007a2d4bcb9d8","modified":1629269481797},{"_id":"themes/flex-block/screenshots/flex-block.png","hash":"93a5456d4f3a51f5e9fd4a957b85584273083fe6","modified":1629269481801},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/categories/小技术/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/archives/2021/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/archives/2021/08/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/tags/vue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/tags/双向绑定/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/tags/观察者模式/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/tags/单页面/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/2021/08/18/vueRouter/index.html","hash":"72a6b37abdd0d98f4859a63cf563709805982b09","modified":1629453111693},{"_id":"public/2021/08/17/vue/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/2021/08/17/hello-world/index.html","hash":"aa2c4d59a8666c371a44aa4abb16eb0f11b720c6","modified":1629364501628},{"_id":"public/tags/路由/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/favicon.ico","hash":"cd1b610096d9c5c780fd2a7e24baaa78dada3163","modified":1629970386080},{"_id":"public/icons-192.png","hash":"8cd106d9039f1d5aa8163ecd4a5e352058a0f6cf","modified":1629970386080},{"_id":"public/icons-512.png","hash":"c2cd59a7712738831ee0cca4338343d407777a4b","modified":1629970386080},{"_id":"public/manifest.json","hash":"70ae21c5c320fbc0df5922a4baf3fa73d5343959","modified":1629970386080},{"_id":"public/js/script.js","hash":"8f0900b1b6bbd1fdc463fbc77f3deb5e598c9871","modified":1629970386080},{"_id":"public/css/style.css","hash":"13a3ef529ebae9ef63ce4f363dd8be7f4d0c0b33","modified":1629970386080},{"_id":"source/_posts/promise.md","hash":"9919d0cdc8709a4710ef1682589eaca536403328","modified":1641785128347},{"_id":"public/tags/promise/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/2021/08/16/promise/index.html","hash":"24b736573e9f2e15cde3fd21738d9ff42a102145","modified":1629453111693},{"_id":"public/2021/08/15/hello-world/index.html","hash":"be614a3f8930184d6b9a47d338b64a5821e8e0d5","modified":1629453111693},{"_id":"public/2021/08/13/vueRouter/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/2021/08/10/promise/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"public/2021/08/08/hello-world/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1641785854639},{"_id":"source/html/index.md","hash":"6ef0de12b8f811a36651b1f85bfb943b57071b4a","modified":1641796530722},{"_id":"source/_posts/htmlAndCss.md","hash":"9b873c68990e3ad2795e4a5653bd636b07aa16f7","modified":1641809031146},{"_id":"themes/landscape/.npmignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1641785128350},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1641785128350},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1641785128351},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1641785128350},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1641785128351},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1641785128363},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1641785128351},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1641785128352},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1641785128352},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1641785128352},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1641785128352},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1641785128352},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1641785128353},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1641785128352},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1641785128353},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1641785128353},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1641785128353},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1641785128354},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1641785128361},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1641785128361},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1641785128362},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1641785128362},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1641785128362},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1641785128362},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1641785128363},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1641785128363},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1641785128354},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1641785128356},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1641785128356},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1641785128356},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1641785128357},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1641785128357},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1641785128359},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1641785128359},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1641785128361},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1641785128361},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1641785128361},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1641785128361},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1641785128364},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1641785128368},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1641785128374},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1641785128375},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1641785128375},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1641785128377},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1641785128377},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1641785128380},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1641785128380},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1641785128381},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1641785128381},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1641785128357},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1641785128359},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1641785128364},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1641785128365},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1641785128365},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1641785128365},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1641785128367},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1641785128367},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1641785128367},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1641785128368},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1641785128369},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1641785128370},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1641785128372},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1641785128379},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1641785128379},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1641785128379},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1641785128380},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1641785128372},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1641785128371},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1641785128374}],"Category":[{"name":"小技术","_id":"cksipd6qg00066cvmhp8we2tb"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---","date":"2021-08-18T02:42:13.489Z","updated":"2021-08-18T02:42:13.479Z","path":"tags/index.html","comments":1,"_id":"cksipd6q400006cvm3bv74hec","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"categories\"\nlayout: \"categories\"\n---\n","date":"2021-08-17T08:55:35.446Z","updated":"2021-08-17T08:53:08.612Z","path":"categories/index.html","comments":1,"_id":"cksipd6qb00026cvmbjyz7xdy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"html","date":"2022-01-10T06:35:30.000Z","_content":"","source":"html/index.md","raw":"---\ntitle: html\ndate: 2022-01-10 14:35:30\n---\n","updated":"2022-01-10T06:35:30.722Z","path":"html/index.html","comments":1,"layout":"page","_id":"cky8ba2mh0000ykv4b6spcpwk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"vue响应式原理剖析及模拟实现","date":"2021-08-17T10:39:37.000Z","cover":"http://i0.hdslb.com/bfs/article/62ab79fcd20d1368b8039a78f16adbaa1e9b8d35.jpg","_content":"## vue响应式原理分析\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png)\n1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。  \n2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。  \n3、通过compiler对象解析模板和指令，即差值表达式和v-指令。  \n4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。  \n5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图\n\n## vue代码模拟实现\n### 1、项目结构\n![](https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png)\n#### myVue.html代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>差值表达式</div>\n        <div>{{name}}</div>\n        <div>{{age}}</div>\n        <div>v-text</div>\n        <div v-text=\"name\"></div>\n        <div v-text=\"age\"></div>\n        <div>v-html</div>\n        <div v-html=\"name\"></div>\n        <div v-html=\"age\"></div>\n        <div>v-model</div>\n        <input type=\"text\" v-model=\"name\">\n        <input type=\"text\" v-model=\"age\">\n    </div>\n    <script src=\"./js/dep.js\"></script>\n    <script src=\"./js/watcher.js\"></script>\n    <script src=\"./js/compiler.js\"></script>\n    <script src=\"./js/observer.js\"></script>\n    <script src=\"./js/myVue.js\"></script>\n<script>\n    const vm = new MyVue({\n        el: '#app',\n        data: {\n            name: '张三',\n            age: 50,\n            son: {\n                name: '李四',\n                age: 25\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n#### 页面展现\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png)\n### 2、myVue类实现\njs/myVue.js\n```javascript\nclass MyVue {\n  constructor(options) {\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || {};\n      this.$data = options.data || {};\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  }\n  _proxyData(data) {\n      Object.keys(data).forEach(key => {\n          Object.defineProperty(this, key, {\n              enumerable: true,\n              configurable: true,\n              set(v) {\n                  if (v === data[key]) return;\n                  data[key] = v;\n              },\n              get() {\n                  return data[key];\n              }\n          })\n      })\n  }\n}\n```\n### 3、Observer类实现\njs/Observer.js\n```javascript\nclass Observer {\n  constructor(data) {\n      this.walk(data);\n  }\n  walk(data) {\n      if (!data || typeof data !== 'object') return;\n      Object.keys(data).forEach(key => {\n          this.defineReactive(data, key, data[key]);\n      })\n  }\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) {\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, {\n          enumerable: true,\n          configurable: true,\n          set(v) {\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          },\n          get() {\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target && dep.subs.push(Dep.target);\n              return val;\n          }\n      })\n  }\n}\n```\n### 4、Compiler类实现\njs/compiler.js\n```javascript\nclass Compiler {\n    constructor(vm) {\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    }\n    compile(el) {\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node => {\n            if (this.isTextNode(node)) {\n                this.compileText(node);\n            } else if (this.isElementNode(node))  {\n                this.compileElement(node);\n            }\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes && node.childNodes.length) {\n                this.compile(node);\n            }\n        })\n    }\n    // 处理文本节点差值表达式\n    compileText(node) {\n        let reg = /\\{\\{(.+?)\\}\\}/; // 正则匹配差值表达是{{ xxx }}\n        let value = node.textContent;\n        if (reg.test(value)) {\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue => {\n                node.textContent = newValue;\n            });\n        }\n    }\n    // 处理元素节点\n    compileElement(node) {\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) {\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            }\n        })\n    }\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) {\n        let updateFn = this[attrName + 'Updater'];\n        updateFn && updateFn.call(this, node, this.vm[key], key);\n    }\n    // 处理v-text\n    textUpdater(node, val, key) {\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.textContent = newValue;\n        })\n    }\n    // 处理v-html\n    htmlUpdater(node, val, key) {\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue => {\n            node.innerHTML = newValue;\n        })\n    }\n    // 处理v-model\n    modelUpdater(node, val, key) {\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.value = newValue;\n        })\n        // 双向数据绑定\n        node.addEventListener('input', () => {\n            this.vm[key] = node.value;\n        })\n    }\n    // 判断当前节点是否是文本节点\n    isTextNode(node) {\n        return node.nodeType === 3;\n    }\n    // 判断当前节点是否是元素节点\n    isElementNode(node) {\n        return node.nodeType === 1;\n    }\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) {\n        return attrName.startsWith('v-');\n    }\n}\n```\n### 5、发布者Dep类实现\njs/dep.js\n```javascript\nclass Dep {\n    constructor() {\n        // 存储订阅者\n        this.subs = [];\n    }\n    // 添加订阅者\n    addSub(sub) {\n        // 订阅者都有一个update方法\n        if (sub && sub.update) {\n            this.subs.push(sub);\n        } \n    }\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() {\n        this.subs.forEach(sub => {\n            sub.update();\n        })\n    }\n}\n```\n### 6、订阅者Watcher类实现\njs/watcher.js\n```javascript\nclass Watcher {\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) {\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    }\n    update() {\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    }\n}\n```\n### 7、最终效果\n![image.png](https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png)\n\n![image.png](https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png)\n\n![image.png](https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png)\n\n## 结语\n本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术","source":"_posts/vue.md","raw":"---\ntitle: vue响应式原理剖析及模拟实现\ndate: 2021-08-17 18:39:37\ntags:\n - vue\n - 双向绑定\n - 观察者模式\ncover: http://i0.hdslb.com/bfs/article/62ab79fcd20d1368b8039a78f16adbaa1e9b8d35.jpg\n---\n## vue响应式原理分析\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png)\n1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。  \n2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。  \n3、通过compiler对象解析模板和指令，即差值表达式和v-指令。  \n4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。  \n5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图\n\n## vue代码模拟实现\n### 1、项目结构\n![](https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png)\n#### myVue.html代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>差值表达式</div>\n        <div>{{name}}</div>\n        <div>{{age}}</div>\n        <div>v-text</div>\n        <div v-text=\"name\"></div>\n        <div v-text=\"age\"></div>\n        <div>v-html</div>\n        <div v-html=\"name\"></div>\n        <div v-html=\"age\"></div>\n        <div>v-model</div>\n        <input type=\"text\" v-model=\"name\">\n        <input type=\"text\" v-model=\"age\">\n    </div>\n    <script src=\"./js/dep.js\"></script>\n    <script src=\"./js/watcher.js\"></script>\n    <script src=\"./js/compiler.js\"></script>\n    <script src=\"./js/observer.js\"></script>\n    <script src=\"./js/myVue.js\"></script>\n<script>\n    const vm = new MyVue({\n        el: '#app',\n        data: {\n            name: '张三',\n            age: 50,\n            son: {\n                name: '李四',\n                age: 25\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n#### 页面展现\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png)\n### 2、myVue类实现\njs/myVue.js\n```javascript\nclass MyVue {\n  constructor(options) {\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || {};\n      this.$data = options.data || {};\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  }\n  _proxyData(data) {\n      Object.keys(data).forEach(key => {\n          Object.defineProperty(this, key, {\n              enumerable: true,\n              configurable: true,\n              set(v) {\n                  if (v === data[key]) return;\n                  data[key] = v;\n              },\n              get() {\n                  return data[key];\n              }\n          })\n      })\n  }\n}\n```\n### 3、Observer类实现\njs/Observer.js\n```javascript\nclass Observer {\n  constructor(data) {\n      this.walk(data);\n  }\n  walk(data) {\n      if (!data || typeof data !== 'object') return;\n      Object.keys(data).forEach(key => {\n          this.defineReactive(data, key, data[key]);\n      })\n  }\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) {\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, {\n          enumerable: true,\n          configurable: true,\n          set(v) {\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          },\n          get() {\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target && dep.subs.push(Dep.target);\n              return val;\n          }\n      })\n  }\n}\n```\n### 4、Compiler类实现\njs/compiler.js\n```javascript\nclass Compiler {\n    constructor(vm) {\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    }\n    compile(el) {\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node => {\n            if (this.isTextNode(node)) {\n                this.compileText(node);\n            } else if (this.isElementNode(node))  {\n                this.compileElement(node);\n            }\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes && node.childNodes.length) {\n                this.compile(node);\n            }\n        })\n    }\n    // 处理文本节点差值表达式\n    compileText(node) {\n        let reg = /\\{\\{(.+?)\\}\\}/; // 正则匹配差值表达是{{ xxx }}\n        let value = node.textContent;\n        if (reg.test(value)) {\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue => {\n                node.textContent = newValue;\n            });\n        }\n    }\n    // 处理元素节点\n    compileElement(node) {\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) {\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            }\n        })\n    }\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) {\n        let updateFn = this[attrName + 'Updater'];\n        updateFn && updateFn.call(this, node, this.vm[key], key);\n    }\n    // 处理v-text\n    textUpdater(node, val, key) {\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.textContent = newValue;\n        })\n    }\n    // 处理v-html\n    htmlUpdater(node, val, key) {\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue => {\n            node.innerHTML = newValue;\n        })\n    }\n    // 处理v-model\n    modelUpdater(node, val, key) {\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.value = newValue;\n        })\n        // 双向数据绑定\n        node.addEventListener('input', () => {\n            this.vm[key] = node.value;\n        })\n    }\n    // 判断当前节点是否是文本节点\n    isTextNode(node) {\n        return node.nodeType === 3;\n    }\n    // 判断当前节点是否是元素节点\n    isElementNode(node) {\n        return node.nodeType === 1;\n    }\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) {\n        return attrName.startsWith('v-');\n    }\n}\n```\n### 5、发布者Dep类实现\njs/dep.js\n```javascript\nclass Dep {\n    constructor() {\n        // 存储订阅者\n        this.subs = [];\n    }\n    // 添加订阅者\n    addSub(sub) {\n        // 订阅者都有一个update方法\n        if (sub && sub.update) {\n            this.subs.push(sub);\n        } \n    }\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() {\n        this.subs.forEach(sub => {\n            sub.update();\n        })\n    }\n}\n```\n### 6、订阅者Watcher类实现\njs/watcher.js\n```javascript\nclass Watcher {\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) {\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    }\n    update() {\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    }\n}\n```\n### 7、最终效果\n![image.png](https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png)\n\n![image.png](https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png)\n\n![image.png](https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png)\n\n## 结语\n本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术","slug":"vue","published":1,"updated":"2022-01-10T03:25:28.348Z","_id":"cksipd6q700016cvmclixdteq","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"vue响应式原理分析\"><a href=\"#vue响应式原理分析\" class=\"headerlink\" title=\"vue响应式原理分析\"></a>vue响应式原理分析</h2><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png\"><br>1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。<br>2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。<br>3、通过compiler对象解析模板和指令，即差值表达式和v-指令。<br>4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。<br>5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图</p>\n<h2 id=\"vue代码模拟实现\"><a href=\"#vue代码模拟实现\" class=\"headerlink\" title=\"vue代码模拟实现\"></a>vue代码模拟实现</h2><h3 id=\"1、项目结构\"><a href=\"#1、项目结构\" class=\"headerlink\" title=\"1、项目结构\"></a>1、项目结构</h3><p><img src=\"https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png\"></p>\n<h4 id=\"myVue-html代码\"><a href=\"#myVue-html代码\" class=\"headerlink\" title=\"myVue.html代码\"></a>myVue.html代码</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;div&gt;差值表达式&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;v-text&lt;/div&gt;\n        &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-text=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-html&lt;/div&gt;\n        &lt;div v-html=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-html=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-model&lt;/div&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;./js/dep.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/compiler.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/myVue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    const vm = new MyVue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;张三&#39;,\n            age: 50,\n            son: &#123;\n                name: &#39;李四&#39;,\n                age: 25\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"页面展现\"><a href=\"#页面展现\" class=\"headerlink\" title=\"页面展现\"></a>页面展现</h4><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png\"></p>\n<h3 id=\"2、myVue类实现\"><a href=\"#2、myVue类实现\" class=\"headerlink\" title=\"2、myVue类实现\"></a>2、myVue类实现</h3><p>js/myVue.js</p>\n<pre><code class=\"javascript\">class MyVue &#123;\n  constructor(options) &#123;\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || &#123;&#125;;\n      this.$data = options.data || &#123;&#125;;\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === &#39;string&#39; ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  &#125;\n  _proxyData(data) &#123;\n      Object.keys(data).forEach(key =&gt; &#123;\n          Object.defineProperty(this, key, &#123;\n              enumerable: true,\n              configurable: true,\n              set(v) &#123;\n                  if (v === data[key]) return;\n                  data[key] = v;\n              &#125;,\n              get() &#123;\n                  return data[key];\n              &#125;\n          &#125;)\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"3、Observer类实现\"><a href=\"#3、Observer类实现\" class=\"headerlink\" title=\"3、Observer类实现\"></a>3、Observer类实现</h3><p>js/Observer.js</p>\n<pre><code class=\"javascript\">class Observer &#123;\n  constructor(data) &#123;\n      this.walk(data);\n  &#125;\n  walk(data) &#123;\n      if (!data || typeof data !== &#39;object&#39;) return;\n      Object.keys(data).forEach(key =&gt; &#123;\n          this.defineReactive(data, key, data[key]);\n      &#125;)\n  &#125;\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) &#123;\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, &#123;\n          enumerable: true,\n          configurable: true,\n          set(v) &#123;\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          &#125;,\n          get() &#123;\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target &amp;&amp; dep.subs.push(Dep.target);\n              return val;\n          &#125;\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4、Compiler类实现\"><a href=\"#4、Compiler类实现\" class=\"headerlink\" title=\"4、Compiler类实现\"></a>4、Compiler类实现</h3><p>js/compiler.js</p>\n<pre><code class=\"javascript\">class Compiler &#123;\n    constructor(vm) &#123;\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    &#125;\n    compile(el) &#123;\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node =&gt; &#123;\n            if (this.isTextNode(node)) &#123;\n                this.compileText(node);\n            &#125; else if (this.isElementNode(node))  &#123;\n                this.compileElement(node);\n            &#125;\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;\n                this.compile(node);\n            &#125;\n        &#125;)\n    &#125;\n    // 处理文本节点差值表达式\n    compileText(node) &#123;\n        let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/; // 正则匹配差值表达是&#123;&#123; xxx &#125;&#125;\n        let value = node.textContent;\n        if (reg.test(value)) &#123;\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue =&gt; &#123;\n                node.textContent = newValue;\n            &#125;);\n        &#125;\n    &#125;\n    // 处理元素节点\n    compileElement(node) &#123;\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr =&gt; &#123;\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) &#123;\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            &#125;\n        &#125;)\n    &#125;\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) &#123;\n        let updateFn = this[attrName + &#39;Updater&#39;];\n        updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key);\n    &#125;\n    // 处理v-text\n    textUpdater(node, val, key) &#123;\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.textContent = newValue;\n        &#125;)\n    &#125;\n    // 处理v-html\n    htmlUpdater(node, val, key) &#123;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.innerHTML = newValue;\n        &#125;)\n    &#125;\n    // 处理v-model\n    modelUpdater(node, val, key) &#123;\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.value = newValue;\n        &#125;)\n        // 双向数据绑定\n        node.addEventListener(&#39;input&#39;, () =&gt; &#123;\n            this.vm[key] = node.value;\n        &#125;)\n    &#125;\n    // 判断当前节点是否是文本节点\n    isTextNode(node) &#123;\n        return node.nodeType === 3;\n    &#125;\n    // 判断当前节点是否是元素节点\n    isElementNode(node) &#123;\n        return node.nodeType === 1;\n    &#125;\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) &#123;\n        return attrName.startsWith(&#39;v-&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5、发布者Dep类实现\"><a href=\"#5、发布者Dep类实现\" class=\"headerlink\" title=\"5、发布者Dep类实现\"></a>5、发布者Dep类实现</h3><p>js/dep.js</p>\n<pre><code class=\"javascript\">class Dep &#123;\n    constructor() &#123;\n        // 存储订阅者\n        this.subs = [];\n    &#125;\n    // 添加订阅者\n    addSub(sub) &#123;\n        // 订阅者都有一个update方法\n        if (sub &amp;&amp; sub.update) &#123;\n            this.subs.push(sub);\n        &#125; \n    &#125;\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() &#123;\n        this.subs.forEach(sub =&gt; &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"6、订阅者Watcher类实现\"><a href=\"#6、订阅者Watcher类实现\" class=\"headerlink\" title=\"6、订阅者Watcher类实现\"></a>6、订阅者Watcher类实现</h3><p>js/watcher.js</p>\n<pre><code class=\"javascript\">class Watcher &#123;\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) &#123;\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    &#125;\n    update() &#123;\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"7、最终效果\"><a href=\"#7、最终效果\" class=\"headerlink\" title=\"7、最终效果\"></a>7、最终效果</h3><p><img src=\"https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png\" alt=\"image.png\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue响应式原理分析\"><a href=\"#vue响应式原理分析\" class=\"headerlink\" title=\"vue响应式原理分析\"></a>vue响应式原理分析</h2><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png\"><br>1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。<br>2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。<br>3、通过compiler对象解析模板和指令，即差值表达式和v-指令。<br>4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。<br>5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图</p>\n<h2 id=\"vue代码模拟实现\"><a href=\"#vue代码模拟实现\" class=\"headerlink\" title=\"vue代码模拟实现\"></a>vue代码模拟实现</h2><h3 id=\"1、项目结构\"><a href=\"#1、项目结构\" class=\"headerlink\" title=\"1、项目结构\"></a>1、项目结构</h3><p><img src=\"https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png\"></p>\n<h4 id=\"myVue-html代码\"><a href=\"#myVue-html代码\" class=\"headerlink\" title=\"myVue.html代码\"></a>myVue.html代码</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;div&gt;差值表达式&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;v-text&lt;/div&gt;\n        &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-text=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-html&lt;/div&gt;\n        &lt;div v-html=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-html=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-model&lt;/div&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;./js/dep.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/compiler.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/myVue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    const vm = new MyVue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;张三&#39;,\n            age: 50,\n            son: &#123;\n                name: &#39;李四&#39;,\n                age: 25\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"页面展现\"><a href=\"#页面展现\" class=\"headerlink\" title=\"页面展现\"></a>页面展现</h4><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png\"></p>\n<h3 id=\"2、myVue类实现\"><a href=\"#2、myVue类实现\" class=\"headerlink\" title=\"2、myVue类实现\"></a>2、myVue类实现</h3><p>js/myVue.js</p>\n<pre><code class=\"javascript\">class MyVue &#123;\n  constructor(options) &#123;\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || &#123;&#125;;\n      this.$data = options.data || &#123;&#125;;\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === &#39;string&#39; ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  &#125;\n  _proxyData(data) &#123;\n      Object.keys(data).forEach(key =&gt; &#123;\n          Object.defineProperty(this, key, &#123;\n              enumerable: true,\n              configurable: true,\n              set(v) &#123;\n                  if (v === data[key]) return;\n                  data[key] = v;\n              &#125;,\n              get() &#123;\n                  return data[key];\n              &#125;\n          &#125;)\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"3、Observer类实现\"><a href=\"#3、Observer类实现\" class=\"headerlink\" title=\"3、Observer类实现\"></a>3、Observer类实现</h3><p>js/Observer.js</p>\n<pre><code class=\"javascript\">class Observer &#123;\n  constructor(data) &#123;\n      this.walk(data);\n  &#125;\n  walk(data) &#123;\n      if (!data || typeof data !== &#39;object&#39;) return;\n      Object.keys(data).forEach(key =&gt; &#123;\n          this.defineReactive(data, key, data[key]);\n      &#125;)\n  &#125;\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) &#123;\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, &#123;\n          enumerable: true,\n          configurable: true,\n          set(v) &#123;\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          &#125;,\n          get() &#123;\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target &amp;&amp; dep.subs.push(Dep.target);\n              return val;\n          &#125;\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4、Compiler类实现\"><a href=\"#4、Compiler类实现\" class=\"headerlink\" title=\"4、Compiler类实现\"></a>4、Compiler类实现</h3><p>js/compiler.js</p>\n<pre><code class=\"javascript\">class Compiler &#123;\n    constructor(vm) &#123;\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    &#125;\n    compile(el) &#123;\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node =&gt; &#123;\n            if (this.isTextNode(node)) &#123;\n                this.compileText(node);\n            &#125; else if (this.isElementNode(node))  &#123;\n                this.compileElement(node);\n            &#125;\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;\n                this.compile(node);\n            &#125;\n        &#125;)\n    &#125;\n    // 处理文本节点差值表达式\n    compileText(node) &#123;\n        let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/; // 正则匹配差值表达是&#123;&#123; xxx &#125;&#125;\n        let value = node.textContent;\n        if (reg.test(value)) &#123;\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue =&gt; &#123;\n                node.textContent = newValue;\n            &#125;);\n        &#125;\n    &#125;\n    // 处理元素节点\n    compileElement(node) &#123;\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr =&gt; &#123;\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) &#123;\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            &#125;\n        &#125;)\n    &#125;\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) &#123;\n        let updateFn = this[attrName + &#39;Updater&#39;];\n        updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key);\n    &#125;\n    // 处理v-text\n    textUpdater(node, val, key) &#123;\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.textContent = newValue;\n        &#125;)\n    &#125;\n    // 处理v-html\n    htmlUpdater(node, val, key) &#123;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.innerHTML = newValue;\n        &#125;)\n    &#125;\n    // 处理v-model\n    modelUpdater(node, val, key) &#123;\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.value = newValue;\n        &#125;)\n        // 双向数据绑定\n        node.addEventListener(&#39;input&#39;, () =&gt; &#123;\n            this.vm[key] = node.value;\n        &#125;)\n    &#125;\n    // 判断当前节点是否是文本节点\n    isTextNode(node) &#123;\n        return node.nodeType === 3;\n    &#125;\n    // 判断当前节点是否是元素节点\n    isElementNode(node) &#123;\n        return node.nodeType === 1;\n    &#125;\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) &#123;\n        return attrName.startsWith(&#39;v-&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5、发布者Dep类实现\"><a href=\"#5、发布者Dep类实现\" class=\"headerlink\" title=\"5、发布者Dep类实现\"></a>5、发布者Dep类实现</h3><p>js/dep.js</p>\n<pre><code class=\"javascript\">class Dep &#123;\n    constructor() &#123;\n        // 存储订阅者\n        this.subs = [];\n    &#125;\n    // 添加订阅者\n    addSub(sub) &#123;\n        // 订阅者都有一个update方法\n        if (sub &amp;&amp; sub.update) &#123;\n            this.subs.push(sub);\n        &#125; \n    &#125;\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() &#123;\n        this.subs.forEach(sub =&gt; &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"6、订阅者Watcher类实现\"><a href=\"#6、订阅者Watcher类实现\" class=\"headerlink\" title=\"6、订阅者Watcher类实现\"></a>6、订阅者Watcher类实现</h3><p>js/watcher.js</p>\n<pre><code class=\"javascript\">class Watcher &#123;\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) &#123;\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    &#125;\n    update() &#123;\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"7、最终效果\"><a href=\"#7、最终效果\" class=\"headerlink\" title=\"7、最终效果\"></a>7、最终效果</h3><p><img src=\"https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png\" alt=\"image.png\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术</p>\n"},{"title":"blog搭建流程","date":"2021-08-08T00:00:00.000Z","cover":"http://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3d63e3c569d0a304e251f5847.jpg","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### 云游的小安利搭建详细教程\n[云游的小安利搭建详细教程](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n","source":"_posts/hello-world.md","raw":"---\ntitle: blog搭建流程\ncategories: 小技术\ndate: '2021-08-08'\ncover: http://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3d63e3c569d0a304e251f5847.jpg\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### 云游的小安利搭建详细教程\n[云游的小安利搭建详细教程](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n","slug":"hello-world","published":1,"updated":"2022-01-10T03:25:28.347Z","_id":"cksipd6qb00036cvmfdc54s6o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"云游的小安利搭建详细教程\"><a href=\"#云游的小安利搭建详细教程\" class=\"headerlink\" title=\"云游的小安利搭建详细教程\"></a>云游的小安利搭建详细教程</h3><p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">云游的小安利搭建详细教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"云游的小安利搭建详细教程\"><a href=\"#云游的小安利搭建详细教程\" class=\"headerlink\" title=\"云游的小安利搭建详细教程\"></a>云游的小安利搭建详细教程</h3><p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">云游的小安利搭建详细教程</a></p>\n"},{"title":"vueRouter原理剖析","date":"2021-08-13T10:39:37.000Z","cover":"http://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3ef5ed4599c0a304e251f586a.jpg","_content":"## 原理分析\n1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install  \n2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换  \n3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  \n\n## 代码实现\n```javascript\nlet _Vue = null;\nexport default class VueRouter {\n    // 供Vue.use调用\n    static install(Vue) {\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) {\n            return;\n        } \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin({\n            beforeCreate() {\n                // 此处的this指向Vue实例\n                if (this.$options.router) { // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                } \n            }\n        })\n     }\n     constructor(options) {\n        this.options = options;\n        this.routeMap = {};\n        this.data = _Vue.observable({ // 将data中属性变为响应式数据\n            current: '/'\n        })\n    }\n    init() {\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    }\n    createRouteMap() {\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component;\n        })\n    }\n    initComponents() {\n        let self = this;\n        // 定义router-link组件\n        _Vue.component('router-link', {\n            props: { // 接受的参数\n                to: String\n            },\n            render(h) { // 渲染模板，渲染成a标签\n                return h('a', {\n                    attrs: {\n                        href: this.to\n                    },\n                    on: {\n                        click: this.clickHandle\n                    }\n                }, [this.$slots.default]) // router-link中的内容\n            },\n            methods: {\n                 clickHandle(e) {\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState({}, '', this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 }\n            }\n        });\n        // 定义router-view\n        _Vue.component('router-view', {\n            render(h) { // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            }\n        })\n    }\n    initEvent() {\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener('popstate', () => {\n            this.data.current = window.location.pathname;\n        })\n    }\n}\n```\n## 代码验证\n1、使用Vue脚手架工具，构建一个带有vueRouter的项目\n```bash\nnpm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n> Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n>(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n > 2.x\n   3.x\n\n```\n2、将实现代码写入myViewRouter.js中\n3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter\n```javascript\nimport VueRouter from '../myViewRouter/myViewRouter' // 引入自己的路径\n```\n4、开始运行模拟实现\n\n","source":"_posts/vueRouter.md","raw":"---\ntitle: vueRouter原理剖析\ndate: 2021-08-13 18:39:37\ntags: \n    - vue \n    - 单页面 \n    - 路由\ncover: http://gss0.baidu.com/9fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/32fa828ba61ea8d3ef5ed4599c0a304e251f586a.jpg\n---\n## 原理分析\n1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install  \n2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换  \n3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  \n\n## 代码实现\n```javascript\nlet _Vue = null;\nexport default class VueRouter {\n    // 供Vue.use调用\n    static install(Vue) {\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) {\n            return;\n        } \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin({\n            beforeCreate() {\n                // 此处的this指向Vue实例\n                if (this.$options.router) { // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                } \n            }\n        })\n     }\n     constructor(options) {\n        this.options = options;\n        this.routeMap = {};\n        this.data = _Vue.observable({ // 将data中属性变为响应式数据\n            current: '/'\n        })\n    }\n    init() {\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    }\n    createRouteMap() {\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component;\n        })\n    }\n    initComponents() {\n        let self = this;\n        // 定义router-link组件\n        _Vue.component('router-link', {\n            props: { // 接受的参数\n                to: String\n            },\n            render(h) { // 渲染模板，渲染成a标签\n                return h('a', {\n                    attrs: {\n                        href: this.to\n                    },\n                    on: {\n                        click: this.clickHandle\n                    }\n                }, [this.$slots.default]) // router-link中的内容\n            },\n            methods: {\n                 clickHandle(e) {\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState({}, '', this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 }\n            }\n        });\n        // 定义router-view\n        _Vue.component('router-view', {\n            render(h) { // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            }\n        })\n    }\n    initEvent() {\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener('popstate', () => {\n            this.data.current = window.location.pathname;\n        })\n    }\n}\n```\n## 代码验证\n1、使用Vue脚手架工具，构建一个带有vueRouter的项目\n```bash\nnpm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n> Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n>(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n > 2.x\n   3.x\n\n```\n2、将实现代码写入myViewRouter.js中\n3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter\n```javascript\nimport VueRouter from '../myViewRouter/myViewRouter' // 引入自己的路径\n```\n4、开始运行模拟实现\n\n","slug":"vueRouter","published":1,"updated":"2022-01-10T03:25:28.348Z","_id":"ckssmzt2e001gb0vm6vxo5nyw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install<br>2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换<br>3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  </p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"javascript\">let _Vue = null;\nexport default class VueRouter &#123;\n    // 供Vue.use调用\n    static install(Vue) &#123;\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) &#123;\n            return;\n        &#125; \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin(&#123;\n            beforeCreate() &#123;\n                // 此处的this指向Vue实例\n                if (this.$options.router) &#123; // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                &#125; \n            &#125;\n        &#125;)\n     &#125;\n     constructor(options) &#123;\n        this.options = options;\n        this.routeMap = &#123;&#125;;\n        this.data = _Vue.observable(&#123; // 将data中属性变为响应式数据\n            current: &#39;/&#39;\n        &#125;)\n    &#125;\n    init() &#123;\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    &#125;\n    createRouteMap() &#123;\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route =&gt; &#123;\n            this.routeMap[route.path] = route.component;\n        &#125;)\n    &#125;\n    initComponents() &#123;\n        let self = this;\n        // 定义router-link组件\n        _Vue.component(&#39;router-link&#39;, &#123;\n            props: &#123; // 接受的参数\n                to: String\n            &#125;,\n            render(h) &#123; // 渲染模板，渲染成a标签\n                return h(&#39;a&#39;, &#123;\n                    attrs: &#123;\n                        href: this.to\n                    &#125;,\n                    on: &#123;\n                        click: this.clickHandle\n                    &#125;\n                &#125;, [this.$slots.default]) // router-link中的内容\n            &#125;,\n            methods: &#123;\n                 clickHandle(e) &#123;\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState(&#123;&#125;, &#39;&#39;, this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 &#125;\n            &#125;\n        &#125;);\n        // 定义router-view\n        _Vue.component(&#39;router-view&#39;, &#123;\n            render(h) &#123; // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            &#125;\n        &#125;)\n    &#125;\n    initEvent() &#123;\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener(&#39;popstate&#39;, () =&gt; &#123;\n            this.data.current = window.location.pathname;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"代码验证\"><a href=\"#代码验证\" class=\"headerlink\" title=\"代码验证\"></a>代码验证</h2><p>1、使用Vue脚手架工具，构建一个带有vueRouter的项目</p>\n<pre><code class=\"bash\">npm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n&gt;(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n &gt; 2.x\n   3.x\n</code></pre>\n<p>2、将实现代码写入myViewRouter.js中<br>3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter</p>\n<pre><code class=\"javascript\">import VueRouter from &#39;../myViewRouter/myViewRouter&#39; // 引入自己的路径\n</code></pre>\n<p>4、开始运行模拟实现</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install<br>2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换<br>3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  </p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"javascript\">let _Vue = null;\nexport default class VueRouter &#123;\n    // 供Vue.use调用\n    static install(Vue) &#123;\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) &#123;\n            return;\n        &#125; \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin(&#123;\n            beforeCreate() &#123;\n                // 此处的this指向Vue实例\n                if (this.$options.router) &#123; // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                &#125; \n            &#125;\n        &#125;)\n     &#125;\n     constructor(options) &#123;\n        this.options = options;\n        this.routeMap = &#123;&#125;;\n        this.data = _Vue.observable(&#123; // 将data中属性变为响应式数据\n            current: &#39;/&#39;\n        &#125;)\n    &#125;\n    init() &#123;\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    &#125;\n    createRouteMap() &#123;\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route =&gt; &#123;\n            this.routeMap[route.path] = route.component;\n        &#125;)\n    &#125;\n    initComponents() &#123;\n        let self = this;\n        // 定义router-link组件\n        _Vue.component(&#39;router-link&#39;, &#123;\n            props: &#123; // 接受的参数\n                to: String\n            &#125;,\n            render(h) &#123; // 渲染模板，渲染成a标签\n                return h(&#39;a&#39;, &#123;\n                    attrs: &#123;\n                        href: this.to\n                    &#125;,\n                    on: &#123;\n                        click: this.clickHandle\n                    &#125;\n                &#125;, [this.$slots.default]) // router-link中的内容\n            &#125;,\n            methods: &#123;\n                 clickHandle(e) &#123;\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState(&#123;&#125;, &#39;&#39;, this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 &#125;\n            &#125;\n        &#125;);\n        // 定义router-view\n        _Vue.component(&#39;router-view&#39;, &#123;\n            render(h) &#123; // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            &#125;\n        &#125;)\n    &#125;\n    initEvent() &#123;\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener(&#39;popstate&#39;, () =&gt; &#123;\n            this.data.current = window.location.pathname;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"代码验证\"><a href=\"#代码验证\" class=\"headerlink\" title=\"代码验证\"></a>代码验证</h2><p>1、使用Vue脚手架工具，构建一个带有vueRouter的项目</p>\n<pre><code class=\"bash\">npm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n&gt;(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n &gt; 2.x\n   3.x\n</code></pre>\n<p>2、将实现代码写入myViewRouter.js中<br>3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter</p>\n<pre><code class=\"javascript\">import VueRouter from &#39;../myViewRouter/myViewRouter&#39; // 引入自己的路径\n</code></pre>\n<p>4、开始运行模拟实现</p>\n"},{"title":"promise原理剖析及模拟实现","date":"2021-08-10T10:39:37.000Z","cover":"http://ww3.sinaimg.cn/large/d2e27164gw1fbmwbgf0mij21hc0u0487.jpg","_content":"\n## promise原理解析及模拟实现\n### promise原理\n1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法  \n2、执行器方法接收两个参数，分别是resolve方法和reject方法  \n3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending  \n4、Promise的resolve、reject方法是用来改变状态的 resolve: pending => fulfilled, reject: pending => rejected，一旦状态确定就不可修改\n5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调  \n6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因\n\n### 代码实现\n#### 1、初步实现\n```javascript\n// --------------Promise代码--------------\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        resolve(i);\n    } else {\n        reject('不是偶数')\n    }\n})\npromise.then((val) => {\n    console.log(val);\n}, (reason) => {\n    console.log(reason);\n})\n```\n思考：  \n1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程  \n2、如果resolve和reject是异步调用，那多次执行then方法  \n上面代码是否满足这两种情况？\n\n#### 2、二次实现\n```javascript\n// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback && this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback && this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        } else { // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        setTimeout(() => {\n            resolve(i);\n        }, 2000)\n    } else {\n        setTimeout(() => {\n            reject('不是偶数');\n        }, 2000)\n    }\n})\npromise.then((val) => {\n    console.log('第一次',val);\n}, (reason) => {\n    console.log(reason);\n})\npromise.then((val) => {\n    console.log('第二次',val);\n}, (reason) => {\n    console.log('第二次', reason);\n})\n```\n思考：  \n1、then方法链式调用  \n2、then方法链式调用可以不传回调  \n上面代码是否满足？ \n\n```javascript\n// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n```\n\n\n\n\n","source":"_posts/promise.md","raw":"---\ntitle: promise原理剖析及模拟实现\ndate: 2021-08-10 18:39:37\ntags: \n    - promise \ncover: http://ww3.sinaimg.cn/large/d2e27164gw1fbmwbgf0mij21hc0u0487.jpg\n---\n\n## promise原理解析及模拟实现\n### promise原理\n1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法  \n2、执行器方法接收两个参数，分别是resolve方法和reject方法  \n3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending  \n4、Promise的resolve、reject方法是用来改变状态的 resolve: pending => fulfilled, reject: pending => rejected，一旦状态确定就不可修改\n5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调  \n6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因\n\n### 代码实现\n#### 1、初步实现\n```javascript\n// --------------Promise代码--------------\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        resolve(i);\n    } else {\n        reject('不是偶数')\n    }\n})\npromise.then((val) => {\n    console.log(val);\n}, (reason) => {\n    console.log(reason);\n})\n```\n思考：  \n1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程  \n2、如果resolve和reject是异步调用，那多次执行then方法  \n上面代码是否满足这两种情况？\n\n#### 2、二次实现\n```javascript\n// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback && this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback && this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        } else { // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        setTimeout(() => {\n            resolve(i);\n        }, 2000)\n    } else {\n        setTimeout(() => {\n            reject('不是偶数');\n        }, 2000)\n    }\n})\npromise.then((val) => {\n    console.log('第一次',val);\n}, (reason) => {\n    console.log(reason);\n})\npromise.then((val) => {\n    console.log('第二次',val);\n}, (reason) => {\n    console.log('第二次', reason);\n})\n```\n思考：  \n1、then方法链式调用  \n2、then方法链式调用可以不传回调  \n上面代码是否满足？ \n\n```javascript\n// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n```\n\n\n\n\n","slug":"promise","published":1,"updated":"2022-01-10T03:25:28.347Z","_id":"cksspqlja001kb0vm992ncjf5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"promise原理解析及模拟实现\"><a href=\"#promise原理解析及模拟实现\" class=\"headerlink\" title=\"promise原理解析及模拟实现\"></a>promise原理解析及模拟实现</h2><h3 id=\"promise原理\"><a href=\"#promise原理\" class=\"headerlink\" title=\"promise原理\"></a>promise原理</h3><p>1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法<br>2、执行器方法接收两个参数，分别是resolve方法和reject方法<br>3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending<br>4、Promise的resolve、reject方法是用来改变状态的 resolve: pending =&gt; fulfilled, reject: pending =&gt; rejected，一旦状态确定就不可修改<br>5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调<br>6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"1、初步实现\"><a href=\"#1、初步实现\" class=\"headerlink\" title=\"1、初步实现\"></a>1、初步实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        resolve(i);\n    &#125; else &#123;\n        reject(&#39;不是偶数&#39;)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程<br>2、如果resolve和reject是异步调用，那多次执行then方法<br>上面代码是否满足这两种情况？</p>\n<h4 id=\"2、二次实现\"><a href=\"#2、二次实现\" class=\"headerlink\" title=\"2、二次实现\"></a>2、二次实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback &amp;&amp; this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback &amp;&amp; this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125; else &#123; // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(i);\n        &#125;, 2000)\n    &#125; else &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;不是偶数&#39;);\n        &#125;, 2000)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第一次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第二次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(&#39;第二次&#39;, reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、then方法链式调用<br>2、then方法链式调用可以不传回调<br>上面代码是否满足？ </p>\n<pre><code class=\"javascript\">// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"promise原理解析及模拟实现\"><a href=\"#promise原理解析及模拟实现\" class=\"headerlink\" title=\"promise原理解析及模拟实现\"></a>promise原理解析及模拟实现</h2><h3 id=\"promise原理\"><a href=\"#promise原理\" class=\"headerlink\" title=\"promise原理\"></a>promise原理</h3><p>1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法<br>2、执行器方法接收两个参数，分别是resolve方法和reject方法<br>3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending<br>4、Promise的resolve、reject方法是用来改变状态的 resolve: pending =&gt; fulfilled, reject: pending =&gt; rejected，一旦状态确定就不可修改<br>5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调<br>6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"1、初步实现\"><a href=\"#1、初步实现\" class=\"headerlink\" title=\"1、初步实现\"></a>1、初步实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        resolve(i);\n    &#125; else &#123;\n        reject(&#39;不是偶数&#39;)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程<br>2、如果resolve和reject是异步调用，那多次执行then方法<br>上面代码是否满足这两种情况？</p>\n<h4 id=\"2、二次实现\"><a href=\"#2、二次实现\" class=\"headerlink\" title=\"2、二次实现\"></a>2、二次实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback &amp;&amp; this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback &amp;&amp; this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125; else &#123; // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(i);\n        &#125;, 2000)\n    &#125; else &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;不是偶数&#39;);\n        &#125;, 2000)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第一次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第二次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(&#39;第二次&#39;, reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、then方法链式调用<br>2、then方法链式调用可以不传回调<br>上面代码是否满足？ </p>\n<pre><code class=\"javascript\">// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n</code></pre>\n"},{"title":"htmlAndCss知识","date":"2022-01-10T06:37:16.000Z","cover":"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn.sinaimg.cn%2Fsinakd20123%2F600%2Fw1920h1080%2F20210730%2F2026-bbf1e288e62fde3aa78a69e6da74dea0.jpg&refer=http%3A%2F%2Fn.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644388782&t=a875106d13ed8d655541100a3419694e","_content":"\n## htmlAndCss知识\n### 1、html5新特性、语义化\nhtml5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用  \n语义化标签: header、nav、main、article、section、aside、footer  \n语义化的优点有：  \n1.代码结构清晰，易于阅读，利与开发和维护  \n2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页  \n3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  \n\n### 2、浏览器渲染机制、重绘、重排\n#### 网页生产过程：  \n1.HTML被HTML解析器解析成DOM树  \n2.CSS则被CSS解析器解析成CSSOM树  \n3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）  \n4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成  \n5.将布局绘制（paint）在屏幕上\n\n#### 重排（回流）\n当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。  \n触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变---边距、填充、边框、宽度和高度\n\n#### 重绘\n当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。  \n触发：改变元素的color、background、box-shadow等属性\n\n#### 重排优化建议\n1.分离读写操作  \n2.样式集中修改  \n3.缓存需要修改的DOM元素  \n4.尽量只修改position:absolute或fixed元素，对其他元素影响不大  \n5、动画开始GPU加速，translate使用3D变化  \n\ntransform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。\n当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧\n\n### CSS盒子模型(box-sizing)\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。  \nborder-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分  \ncontent-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充\n\n### CSS样式优先级\n!important>style>id>class\n\n### 什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\n#### 什么是BFC\nFormatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） \n\n具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把\nBFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n#### 触发BFC\n1.body根元素  \n2.浮动元素：float除none以外的值\n3.绝对定位元素：position(absolut,fixed)  \n4.display为inline-block、table-cells,flex  \n5.overflow除了visible以外的值(hidden,auto,scroll)  \n\n#### BFC的特性\n__1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中__  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n    </style>\n</head>\n<body>\n    <p></p>\n    <p></p>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg)\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n首先这不是 CSS 的 bug，我们可以理解为一种规范，__如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。__\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n        div {\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n</div>\n</body>\n</html>\n```\n![](https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg)\n\n__2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）__\n浮动的元素会脱离普通文档流  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n          overflow: hidden;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png)\n\n__3.BFC可以阻止元素被浮动的元素覆盖__  \n文字环绕效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png)\n\n这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发\n第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue;\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee;overflow: hidden\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg)\n\n### DOM、BOM对象\njavascript由ECMAScript、BOM、DOM组成。  \n\nBOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  \n\nDOM（Document Object Model）是指文档对象模型，通过他\n可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  \n\nECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。\n\n\n\n\n\n\n","source":"_posts/htmlAndCss.md","raw":"---\ntitle: htmlAndCss知识\ndate: 2022-01-10 14:37:16\ntags: \n- html\ncover: https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn.sinaimg.cn%2Fsinakd20123%2F600%2Fw1920h1080%2F20210730%2F2026-bbf1e288e62fde3aa78a69e6da74dea0.jpg&refer=http%3A%2F%2Fn.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1644388782&t=a875106d13ed8d655541100a3419694e\n---\n\n## htmlAndCss知识\n### 1、html5新特性、语义化\nhtml5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用  \n语义化标签: header、nav、main、article、section、aside、footer  \n语义化的优点有：  \n1.代码结构清晰，易于阅读，利与开发和维护  \n2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页  \n3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  \n\n### 2、浏览器渲染机制、重绘、重排\n#### 网页生产过程：  \n1.HTML被HTML解析器解析成DOM树  \n2.CSS则被CSS解析器解析成CSSOM树  \n3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）  \n4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成  \n5.将布局绘制（paint）在屏幕上\n\n#### 重排（回流）\n当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。  \n触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变---边距、填充、边框、宽度和高度\n\n#### 重绘\n当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。  \n触发：改变元素的color、background、box-shadow等属性\n\n#### 重排优化建议\n1.分离读写操作  \n2.样式集中修改  \n3.缓存需要修改的DOM元素  \n4.尽量只修改position:absolute或fixed元素，对其他元素影响不大  \n5、动画开始GPU加速，translate使用3D变化  \n\ntransform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。\n当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧\n\n### CSS盒子模型(box-sizing)\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。  \nborder-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分  \ncontent-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充\n\n### CSS样式优先级\n!important>style>id>class\n\n### 什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\n#### 什么是BFC\nFormatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） \n\n具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把\nBFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n#### 触发BFC\n1.body根元素  \n2.浮动元素：float除none以外的值\n3.绝对定位元素：position(absolut,fixed)  \n4.display为inline-block、table-cells,flex  \n5.overflow除了visible以外的值(hidden,auto,scroll)  \n\n#### BFC的特性\n__1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中__  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n    </style>\n</head>\n<body>\n    <p></p>\n    <p></p>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg)\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n首先这不是 CSS 的 bug，我们可以理解为一种规范，__如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。__\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n        div {\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n</div>\n</body>\n</html>\n```\n![](https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg)\n\n__2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）__\n浮动的元素会脱离普通文档流  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n          overflow: hidden;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png)\n\n__3.BFC可以阻止元素被浮动的元素覆盖__  \n文字环绕效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png)\n\n这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发\n第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue;\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee;overflow: hidden\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg)\n\n### DOM、BOM对象\njavascript由ECMAScript、BOM、DOM组成。  \n\nBOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  \n\nDOM（Document Object Model）是指文档对象模型，通过他\n可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  \n\nECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。\n\n\n\n\n\n\n","slug":"htmlAndCss","published":1,"updated":"2022-01-10T10:03:51.146Z","_id":"cky8bbvpt00008wv4742mb6jl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"htmlAndCss知识\"><a href=\"#htmlAndCss知识\" class=\"headerlink\" title=\"htmlAndCss知识\"></a>htmlAndCss知识</h2><h3 id=\"1、html5新特性、语义化\"><a href=\"#1、html5新特性、语义化\" class=\"headerlink\" title=\"1、html5新特性、语义化\"></a>1、html5新特性、语义化</h3><p>html5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用<br>语义化标签: header、nav、main、article、section、aside、footer<br>语义化的优点有：<br>1.代码结构清晰，易于阅读，利与开发和维护<br>2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页<br>3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  </p>\n<h3 id=\"2、浏览器渲染机制、重绘、重排\"><a href=\"#2、浏览器渲染机制、重绘、重排\" class=\"headerlink\" title=\"2、浏览器渲染机制、重绘、重排\"></a>2、浏览器渲染机制、重绘、重排</h3><h4 id=\"网页生产过程：\"><a href=\"#网页生产过程：\" class=\"headerlink\" title=\"网页生产过程：\"></a>网页生产过程：</h4><p>1.HTML被HTML解析器解析成DOM树<br>2.CSS则被CSS解析器解析成CSSOM树<br>3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）<br>4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成<br>5.将布局绘制（paint）在屏幕上</p>\n<h4 id=\"重排（回流）\"><a href=\"#重排（回流）\" class=\"headerlink\" title=\"重排（回流）\"></a>重排（回流）</h4><p>当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。<br>触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变—边距、填充、边框、宽度和高度</p>\n<h4 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h4><p>当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。<br>触发：改变元素的color、background、box-shadow等属性</p>\n<h4 id=\"重排优化建议\"><a href=\"#重排优化建议\" class=\"headerlink\" title=\"重排优化建议\"></a>重排优化建议</h4><p>1.分离读写操作<br>2.样式集中修改<br>3.缓存需要修改的DOM元素<br>4.尽量只修改position:absolute或fixed元素，对其他元素影响不大<br>5、动画开始GPU加速，translate使用3D变化  </p>\n<p>transform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。<br>当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧</p>\n<h3 id=\"CSS盒子模型-box-sizing\"><a href=\"#CSS盒子模型-box-sizing\" class=\"headerlink\" title=\"CSS盒子模型(box-sizing)\"></a>CSS盒子模型(box-sizing)</h3><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。<br>border-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分<br>content-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充</p>\n<h3 id=\"CSS样式优先级\"><a href=\"#CSS样式优先级\" class=\"headerlink\" title=\"CSS样式优先级\"></a>CSS样式优先级</h3><p>!important&gt;style&gt;id&gt;class</p>\n<h3 id=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"><a href=\"#什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\" class=\"headerlink\" title=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？</h3><h4 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h4><p>Formatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） </p>\n<p>具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把<br>BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h4 id=\"触发BFC\"><a href=\"#触发BFC\" class=\"headerlink\" title=\"触发BFC\"></a>触发BFC</h4><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position(absolut,fixed)<br>4.display为inline-block、table-cells,flex<br>5.overflow除了visible以外的值(hidden,auto,scroll)  </p>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><p><strong>1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中</strong>  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg\"><br>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n        div &#123;\n            overflow: hidden;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg\"></p>\n<p><strong>2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）</strong><br>浮动的元素会脱离普通文档流  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n          overflow: hidden;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png\"></p>\n<p><strong>3.BFC可以阻止元素被浮动的元素覆盖</strong><br>文字环绕效果</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png\"></p>\n<p>这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发<br>第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue;&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee;overflow: hidden&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg\"></p>\n<h3 id=\"DOM、BOM对象\"><a href=\"#DOM、BOM对象\" class=\"headerlink\" title=\"DOM、BOM对象\"></a>DOM、BOM对象</h3><p>javascript由ECMAScript、BOM、DOM组成。  </p>\n<p>BOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  </p>\n<p>DOM（Document Object Model）是指文档对象模型，通过他<br>可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  </p>\n<p>ECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"htmlAndCss知识\"><a href=\"#htmlAndCss知识\" class=\"headerlink\" title=\"htmlAndCss知识\"></a>htmlAndCss知识</h2><h3 id=\"1、html5新特性、语义化\"><a href=\"#1、html5新特性、语义化\" class=\"headerlink\" title=\"1、html5新特性、语义化\"></a>1、html5新特性、语义化</h3><p>html5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用<br>语义化标签: header、nav、main、article、section、aside、footer<br>语义化的优点有：<br>1.代码结构清晰，易于阅读，利与开发和维护<br>2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页<br>3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  </p>\n<h3 id=\"2、浏览器渲染机制、重绘、重排\"><a href=\"#2、浏览器渲染机制、重绘、重排\" class=\"headerlink\" title=\"2、浏览器渲染机制、重绘、重排\"></a>2、浏览器渲染机制、重绘、重排</h3><h4 id=\"网页生产过程：\"><a href=\"#网页生产过程：\" class=\"headerlink\" title=\"网页生产过程：\"></a>网页生产过程：</h4><p>1.HTML被HTML解析器解析成DOM树<br>2.CSS则被CSS解析器解析成CSSOM树<br>3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）<br>4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成<br>5.将布局绘制（paint）在屏幕上</p>\n<h4 id=\"重排（回流）\"><a href=\"#重排（回流）\" class=\"headerlink\" title=\"重排（回流）\"></a>重排（回流）</h4><p>当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。<br>触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变—边距、填充、边框、宽度和高度</p>\n<h4 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h4><p>当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。<br>触发：改变元素的color、background、box-shadow等属性</p>\n<h4 id=\"重排优化建议\"><a href=\"#重排优化建议\" class=\"headerlink\" title=\"重排优化建议\"></a>重排优化建议</h4><p>1.分离读写操作<br>2.样式集中修改<br>3.缓存需要修改的DOM元素<br>4.尽量只修改position:absolute或fixed元素，对其他元素影响不大<br>5、动画开始GPU加速，translate使用3D变化  </p>\n<p>transform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。<br>当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧</p>\n<h3 id=\"CSS盒子模型-box-sizing\"><a href=\"#CSS盒子模型-box-sizing\" class=\"headerlink\" title=\"CSS盒子模型(box-sizing)\"></a>CSS盒子模型(box-sizing)</h3><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。<br>border-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分<br>content-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充</p>\n<h3 id=\"CSS样式优先级\"><a href=\"#CSS样式优先级\" class=\"headerlink\" title=\"CSS样式优先级\"></a>CSS样式优先级</h3><p>!important&gt;style&gt;id&gt;class</p>\n<h3 id=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"><a href=\"#什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\" class=\"headerlink\" title=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？</h3><h4 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h4><p>Formatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） </p>\n<p>具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把<br>BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h4 id=\"触发BFC\"><a href=\"#触发BFC\" class=\"headerlink\" title=\"触发BFC\"></a>触发BFC</h4><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position(absolut,fixed)<br>4.display为inline-block、table-cells,flex<br>5.overflow除了visible以外的值(hidden,auto,scroll)  </p>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><p><strong>1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中</strong>  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg\"><br>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n        div &#123;\n            overflow: hidden;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg\"></p>\n<p><strong>2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）</strong><br>浮动的元素会脱离普通文档流  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n          overflow: hidden;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png\"></p>\n<p><strong>3.BFC可以阻止元素被浮动的元素覆盖</strong><br>文字环绕效果</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png\"></p>\n<p>这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发<br>第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue;&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee;overflow: hidden&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg\"></p>\n<h3 id=\"DOM、BOM对象\"><a href=\"#DOM、BOM对象\" class=\"headerlink\" title=\"DOM、BOM对象\"></a>DOM、BOM对象</h3><p>javascript由ECMAScript、BOM、DOM组成。  </p>\n<p>BOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  </p>\n<p>DOM（Document Object Model）是指文档对象模型，通过他<br>可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  </p>\n<p>ECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cksipd6qb00036cvmfdc54s6o","category_id":"cksipd6qg00066cvmhp8we2tb","_id":"cksipd6qi00096cvmammaf1b7"}],"PostTag":[{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qd00046cvmdqkocyb1","_id":"cksipd6qk000b6cvmgqgd6lsq"},{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qh00076cvmhr7t6j01","_id":"cksipd6qk000c6cvm8ehx4ijz"},{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qi00086cvmgb3r9av0","_id":"cksipd6qk000e6cvm9tn12ikz"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qd00046cvmdqkocyb1","_id":"ckssmzt2g001hb0vmbkeufe88"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qk000d6cvm1ftv1q54","_id":"ckssmzt2g001ib0vm5rp92ll4"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qk000f6cvm5rdy2kxg","_id":"ckssmzt2h001jb0vmdf5m31fk"},{"post_id":"cksspqlja001kb0vm992ncjf5","tag_id":"cksk3oveu0001cwvmcrak8r91","_id":"cksspqljb001lb0vm88whahsz"},{"post_id":"cky8bbvpt00008wv4742mb6jl","tag_id":"cky8bdzpt00018wv4cjk034dr","_id":"cky8bdzpt00028wv4hf5j5yvq"}],"Tag":[{"name":"vue","_id":"cksipd6qd00046cvmdqkocyb1"},{"name":"双向绑定","_id":"cksipd6qh00076cvmhr7t6j01"},{"name":"观察者模式","_id":"cksipd6qi00086cvmgb3r9av0"},{"name":"单页面","_id":"cksipd6qk000d6cvm1ftv1q54"},{"name":"路由","_id":"cksipd6qk000f6cvm5rdy2kxg"},{"name":"promise","_id":"cksk3oveu0001cwvmcrak8r91"},{"name":"html","_id":"cky8bdzpt00018wv4cjk034dr"}]}}