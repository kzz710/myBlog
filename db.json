{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/flex-block/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/flex-block/source/icons-192.png","path":"icons-192.png","modified":0,"renderable":1},{"_id":"themes/flex-block/source/icons-512.png","path":"icons-512.png","modified":0,"renderable":1},{"_id":"themes/flex-block/source/manifest.json","path":"manifest.json","modified":0,"renderable":1},{"_id":"themes/flex-block/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/flex-block/source/js/script.js","path":"js/script.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/vue.md","hash":"36d251001f34d535428177a165fb701d62eb9c13","modified":1642063837856},{"_id":"source/_posts/hello-world.md","hash":"6ed3e572b207a53b9200ef1fcb1a91aaf9c18908","modified":1642063795974},{"_id":"source/_posts/vueRouter.md","hash":"ab6d93719fd6d26ed0ac1b2a66906add1c393f16","modified":1642063849185},{"_id":"source/tags/index.md","hash":"77738dafd6e79edc4816aca40d2bfd706905450b","modified":1629254533479},{"_id":"source/categories/index.md","hash":"30e8b5db11dfd7b1e5e881fe97f29334d8a34e22","modified":1629190388612},{"_id":"themes/flex-block/.gitignore","hash":"705b1b2062454bbf1210389b79ba6e61c3534417","modified":1629269481784},{"_id":"themes/flex-block/LICENSE","hash":"b39804556d3cc20997aca34c37ff896235078e86","modified":1629269481784},{"_id":"themes/flex-block/README.md","hash":"a73f77abcc04864be5fb8070a0e65f49ebe90a56","modified":1629269481784},{"_id":"themes/flex-block/_config.yml","hash":"90c7d2676f8cb9a5ed1a1ab484086c5748126771","modified":1641813441896},{"_id":"themes/flex-block/layout/archive.ejs","hash":"31199b59d95f43e89c78df799735bb03b4f2cdc6","modified":1629269481793},{"_id":"themes/flex-block/layout/category.ejs","hash":"5551f6309ac4f835bd135ebb35fd40ba961f09b3","modified":1629269481794},{"_id":"themes/flex-block/layout/index.ejs","hash":"b2d5cf681e351c2cdfd5f549bddc4f428812fd36","modified":1629269481794},{"_id":"themes/flex-block/layout/layout.ejs","hash":"0024457e6e44e810e5cc62e6d571d64c0ec36e33","modified":1629269481794},{"_id":"themes/flex-block/layout/page.ejs","hash":"4aaf6496c9e4c61355bbed51ea0bf15023d8bcf3","modified":1629269481794},{"_id":"themes/flex-block/layout/post.ejs","hash":"f4de584f9181669b301e43c4f30439f57c959108","modified":1629269481794},{"_id":"themes/flex-block/layout/tag.ejs","hash":"4621d964e6505fdc19ae270918ea08356cc5c789","modified":1629269481794},{"_id":"themes/flex-block/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1629269481785},{"_id":"themes/flex-block/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1629269481785},{"_id":"themes/flex-block/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1629269481785},{"_id":"themes/flex-block/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1629269481785},{"_id":"themes/flex-block/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1629269481785},{"_id":"themes/flex-block/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1629269481786},{"_id":"themes/flex-block/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1629269481786},{"_id":"themes/flex-block/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1629269481786},{"_id":"themes/flex-block/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1629269481786},{"_id":"themes/flex-block/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1629269481787},{"_id":"themes/flex-block/languages/zh-CN.yml","hash":"fb8f221242b3997833189f11cd14407a867de3b8","modified":1629269481787},{"_id":"themes/flex-block/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1629269481787},{"_id":"themes/flex-block/source/favicon.ico","hash":"cd1b610096d9c5c780fd2a7e24baaa78dada3163","modified":1629269481806},{"_id":"themes/flex-block/source/icons-192.png","hash":"8cd106d9039f1d5aa8163ecd4a5e352058a0f6cf","modified":1629269481806},{"_id":"themes/flex-block/source/manifest.json","hash":"6689646167bbe5bc836615a0c2019ea9aaa9e015","modified":1629269481808},{"_id":"themes/flex-block/scripts/index.js","hash":"80eb0126ace5be17be33f4ee1442061e79aa9e8f","modified":1629269481801},{"_id":"themes/flex-block/layout/_partial/article-list.ejs","hash":"33ce0492d8b3731d99f4ddf98664841770400777","modified":1629269481787},{"_id":"themes/flex-block/layout/_partial/footer-other.ejs","hash":"9e93e20f3e3ded687abe00a6478e3c4dbfff479e","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/content.ejs","hash":"ff5fb3bd02681529ce3f6f52d74e11c951bc5e83","modified":1629269481787},{"_id":"themes/flex-block/layout/_partial/footer-script.ejs","hash":"2af1fd98adfd3beafcbaf5555781fcccb910451c","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/footer.ejs","hash":"1dc4ef7064687955c3e37d79597258166c33110c","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/header.ejs","hash":"903c358d8f46488110a6462bc710546a755c50ba","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/nav.ejs","hash":"e58516a49b3997d9f2fe2bcd6bcced97b3e6ecd6","modified":1629269481788},{"_id":"themes/flex-block/layout/_partial/page.ejs","hash":"75cb1422782f264a1e3e3dc407ba26d2510595c3","modified":1629269481789},{"_id":"themes/flex-block/layout/_partial/pagination.ejs","hash":"22d60f90cf93b7a80ab1dc044fbf5808a723872a","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-article.svg","hash":"f89ab250586cf0bd8108b77e48a5288f1d0dd512","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-categories.svg","hash":"cfe4012051132281255e211c28971e05726cdc43","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-tags.svg","hash":"0d974ce6d089d08ef009ad56d1b5d66bf9c2c1e6","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/icon-notice.svg","hash":"0d2f705ca65673eda3d38420aa512d83fcbc1e72","modified":1629269481789},{"_id":"themes/flex-block/layout/_svg/icon-toc.svg","hash":"05d2eecfb27deade461f25b2a396c230e18cd6b4","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-github.svg","hash":"880c135b980866f77047cd4507f5bf8671934333","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-ins.svg","hash":"aad8cb2136a7c8af682d9c9dae726b80ee1b57dd","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-twitter.svg","hash":"acb180ecf694e6b91a309e9247d691200f5540ac","modified":1629269481790},{"_id":"themes/flex-block/layout/_svg/social-weibo.svg","hash":"a10c19805388d60e9532a44db09f4d117fb4f1cf","modified":1629269481791},{"_id":"themes/flex-block/layout/_svg/social-zhihu.svg","hash":"9f46e99ec2a82ab4d85f38a6771378cddd83a70a","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/article-nav.ejs","hash":"8df3b527e6153323c8ded33768bd5e5267dfa422","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/category.ejs","hash":"488d6e93a6240d00d0c60c9f104f4304400415ba","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/date.ejs","hash":"5c275ec71f7ce628599683393ae71cf95196f71f","modified":1629269481792},{"_id":"themes/flex-block/layout/_widget/comment.ejs","hash":"1764ba8abe7ba34748e3603fc536a73404037964","modified":1629269481791},{"_id":"themes/flex-block/layout/_widget/tag.ejs","hash":"2a1642735fe62363cee1eeeb09a3d36c2e8ac00e","modified":1629269481792},{"_id":"themes/flex-block/layout/_widget/widget-author.ejs","hash":"d3bb8143f405d39734b28216f31a5a7b26691bab","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-categorys.ejs","hash":"588237737f87a0ff69d00605c868c1297054d573","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-notice.ejs","hash":"0a1ec45028b2abd123bb6a96017168fd55759971","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-tags.ejs","hash":"8c360bf72e85a4cf48c6064b44a64828d059285a","modified":1629269481793},{"_id":"themes/flex-block/layout/_widget/widget-toc.ejs","hash":"0607e05641735d1fea7c74bc3c5b5f41f3bfb16f","modified":1629269481793},{"_id":"themes/flex-block/layout/plug-in/aplayer.ejs","hash":"438336577656019044851a9fd534b42f954aa51d","modified":1629269481794},{"_id":"themes/flex-block/layout/plug-in/dplayer.ejs","hash":"b328a419bdfee2fa96d8b64805db854d069d35ea","modified":1629269481794},{"_id":"themes/flex-block/source/css/style.styl","hash":"c56dc27939e0ca92b2e3f3e6119eeb654a198ec6","modified":1629269481806},{"_id":"themes/flex-block/source/js/script.js","hash":"df8e22b2f98a9c9c4547f1bb0cc73f37180ff790","modified":1629269481808},{"_id":"themes/flex-block/source/css/_partial/card.styl","hash":"458daa8aec35a5352d82bcd42ea68ac13a875b75","modified":1641789531380},{"_id":"themes/flex-block/source/css/_partial/content.styl","hash":"6417486290b19661228f6cced736ccbc10fdd3e5","modified":1629269481803},{"_id":"themes/flex-block/source/css/_partial/header.styl","hash":"c657c1bfbf984e14f1e593a89fab330d442971be","modified":1641789531381},{"_id":"themes/flex-block/source/css/_partial/footer.styl","hash":"11cf25e1999463aeec061c23ca7d32ee7dbc783d","modified":1629269481804},{"_id":"themes/flex-block/source/css/_partial/nav.styl","hash":"891257e01cc805a5cfbf7298b44f24616a22d8fb","modified":1641789531381},{"_id":"themes/flex-block/source/css/_partial/page.styl","hash":"cfc59a5969a140997dbe7b5a97e816b5f54d4a03","modified":1629269481804},{"_id":"themes/flex-block/source/css/_partial/pagination.styl","hash":"268bb486fc8682aa7e8e2417211c84cd1d5da264","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/mixins.styl","hash":"2189d5e686410ecc79c4e8e357dc0737965d295d","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/theme.styl","hash":"68fea7a3bf7d2e5cad165fb096efa74bcc8f3023","modified":1629269481805},{"_id":"themes/flex-block/source/css/_util/variables.styl","hash":"1c086d4ad292550acfa1e291f4dfa355c97f506e","modified":1629269481805},{"_id":"themes/flex-block/source/icons-512.png","hash":"c2cd59a7712738831ee0cca4338343d407777a4b","modified":1629269481807},{"_id":"themes/flex-block/screenshots/flex-block--post.jpeg","hash":"bc607db875e42fe2c82ed5130c07d67cca5adc41","modified":1629269481799},{"_id":"themes/flex-block/screenshots/flex-block--home.jpeg","hash":"7f6c738298108020ab2e4918592007a2d4bcb9d8","modified":1629269481797},{"_id":"themes/flex-block/screenshots/flex-block.png","hash":"93a5456d4f3a51f5e9fd4a957b85584273083fe6","modified":1629269481801},{"_id":"public/tags/index.html","hash":"3ea2bf07bcf3481d2aae412ae567dfb5f2831590","modified":1644835401934},{"_id":"public/categories/index.html","hash":"d8802bd99113446b25abafbb6ea0da22d0ce40d8","modified":1644835401934},{"_id":"public/categories/小技术/index.html","hash":"16a3bc667279d406d02eed8a13a44988115ffd7c","modified":1644835401934},{"_id":"public/index.html","hash":"e9d2b773ffe9ee6763d80ec12a45e3f6c430253c","modified":1644835401934},{"_id":"public/archives/index.html","hash":"36406740ddde708f4bc13e6b5e9f18f901aea93d","modified":1644835401934},{"_id":"public/archives/2021/index.html","hash":"eaa0778a257940a0abccdfa4034669b3b5311825","modified":1644835401934},{"_id":"public/archives/2021/08/index.html","hash":"eaa0778a257940a0abccdfa4034669b3b5311825","modified":1644835401934},{"_id":"public/tags/vue/index.html","hash":"b54508d9c515141ab3744a0e9108a2ad500082a8","modified":1644835401934},{"_id":"public/tags/双向绑定/index.html","hash":"d42c1a7405109c238e039141d4ba064b4378c29e","modified":1644835401934},{"_id":"public/tags/观察者模式/index.html","hash":"7477ce44ca9e4f66c813259ffdcb14d72e74f3fc","modified":1644835401934},{"_id":"public/tags/单页面/index.html","hash":"cc645ef71c2106e8e1c3401908e4a29312a4fdb9","modified":1644835401934},{"_id":"public/2021/08/18/vueRouter/index.html","hash":"72a6b37abdd0d98f4859a63cf563709805982b09","modified":1629453111693},{"_id":"public/2021/08/17/vue/index.html","hash":"f3e15871513a7644c13da21a4fc275613a72d690","modified":1644835401934},{"_id":"public/2021/08/17/hello-world/index.html","hash":"aa2c4d59a8666c371a44aa4abb16eb0f11b720c6","modified":1629364501628},{"_id":"public/tags/路由/index.html","hash":"df1d9a197ac556a28367280998ad5b5690c5e5c4","modified":1644835401934},{"_id":"public/favicon.ico","hash":"cd1b610096d9c5c780fd2a7e24baaa78dada3163","modified":1644835401934},{"_id":"public/icons-192.png","hash":"8cd106d9039f1d5aa8163ecd4a5e352058a0f6cf","modified":1644835401934},{"_id":"public/icons-512.png","hash":"c2cd59a7712738831ee0cca4338343d407777a4b","modified":1644835401934},{"_id":"public/manifest.json","hash":"70ae21c5c320fbc0df5922a4baf3fa73d5343959","modified":1644835401934},{"_id":"public/js/script.js","hash":"8f0900b1b6bbd1fdc463fbc77f3deb5e598c9871","modified":1644835401934},{"_id":"public/css/style.css","hash":"d144f2d72758599aef854441410f1dcf63bc6639","modified":1644835401934},{"_id":"source/_posts/promise.md","hash":"7a1dc5b5b2525c6e84da4d9009c66be019611d7e","modified":1642063795964},{"_id":"public/tags/promise/index.html","hash":"654e2a5ead21777f3cec0a2d9054bd26db54e114","modified":1644835401934},{"_id":"public/2021/08/16/promise/index.html","hash":"24b736573e9f2e15cde3fd21738d9ff42a102145","modified":1629453111693},{"_id":"public/2021/08/15/hello-world/index.html","hash":"be614a3f8930184d6b9a47d338b64a5821e8e0d5","modified":1629453111693},{"_id":"public/2021/08/13/vueRouter/index.html","hash":"32447b5248307df15c049b368cd28052c157f63d","modified":1644835401934},{"_id":"public/2021/08/10/promise/index.html","hash":"537cf8803b7d3bbce9e5e812509dacc31b621461","modified":1644835401934},{"_id":"public/2021/08/08/hello-world/index.html","hash":"e22dba8cb800ac984b30011ae3a57f425c3cbc92","modified":1644835401934},{"_id":"source/html/index.md","hash":"6ef0de12b8f811a36651b1f85bfb943b57071b4a","modified":1641796530722},{"_id":"source/_posts/htmlAndCss.md","hash":"5786637cd17b60ad1eb08ca816f3bf6b7fb33eeb","modified":1642383813126},{"_id":"themes/landscape/.npmignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1641785128350},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1641785128350},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1641785128351},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1641785128350},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1641785128351},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1641785128363},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1641785128351},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1641785128352},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1641785128352},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1641785128352},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1641785128352},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1641785128352},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1641785128353},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1641785128352},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1641785128353},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1641785128353},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1641785128353},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1641785128354},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1641785128361},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1641785128361},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1641785128362},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1641785128362},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1641785128362},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1641785128362},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1641785128363},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1641785128363},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"5e3b70c028d518b8f765e29a5e2020e7ba6ed589","modified":1641785128354},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1641785128355},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1641785128356},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1641785128356},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1641785128356},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1641785128357},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1641785128357},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1641785128359},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1641785128359},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1641785128361},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1641785128361},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1641785128361},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1641785128361},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1641785128364},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1641785128368},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1641785128374},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1641785128375},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1641785128375},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1641785128377},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1641785128377},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1641785128380},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1641785128380},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1641785128381},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1641785128381},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1641785128357},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1641785128358},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1641785128359},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1641785128364},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1641785128365},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1641785128365},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1641785128365},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1641785128366},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1641785128367},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1641785128367},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1641785128367},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1641785128368},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1641785128369},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1641785128370},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1641785128372},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1641785128378},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1641785128379},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1641785128379},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1641785128379},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1641785128380},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1641785128372},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1641785128371},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1641785128374},{"_id":"public/tags/html/index.html","hash":"0b164b8c17e46cb788808a362290b4030764e6c9","modified":1644835401934},{"_id":"public/archives/2022/index.html","hash":"782c1d4fa77b28223325c64c659a9e86772141e9","modified":1644835401934},{"_id":"public/archives/2022/01/index.html","hash":"782c1d4fa77b28223325c64c659a9e86772141e9","modified":1644835401934},{"_id":"public/html/index.html","hash":"7ce66e200467f9454b4e3e93904875907622f902","modified":1644835401934},{"_id":"public/2022/01/10/htmlAndCss/index.html","hash":"a018268128197a1c1758898ef916e68e70dbddb2","modified":1644835401934},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1644835401934},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1644835401934},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1644835401934},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1644835401934},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1644835401934},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1644835401934},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1644835401934},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1644835401934},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1644835401934},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1644835401934},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1644835401934},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1644835401934},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1644835401934},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1644835401934},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1644835401934},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1644835401934},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1644835401934},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1644835401934},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1644835401934},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1644835401934},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1644835401934},{"_id":"source/_posts/basicJs.md","hash":"09d2fc0e393c515af5621eded48e672c2093117e","modified":1642412573085},{"_id":"public/tags/js/index.html","hash":"f791dc4b1925d25a73c05d48dd2736bd89734aeb","modified":1644835401934},{"_id":"public/2022/01/11/basicJs/index.html","hash":"c2ac67b89f9fdc68311cbb4eee22c422c5ec35af","modified":1644835401934},{"_id":"source/_posts/es6.md","hash":"9698582cbcb27eab6a375c210bd4542da6e72432","modified":1643007717127},{"_id":"source/_posts/img2121.png","hash":"b146ea15bc4f205c54be1ed62a8f5660e447aa97","modified":1642062654571},{"_id":"public/tags/es6/index.html","hash":"1f2f461dca212c09fe39b4d40786389594f803b2","modified":1644835401934},{"_id":"public/2022/01/13/es6/index.html","hash":"e7917448fcda1ed96513a4f1333dd60f62891b1a","modified":1644835401934},{"_id":"source/_posts/network.md","hash":"34f9aba42a00cdbb02cc4c185dd4614cdb146056","modified":1644996982876},{"_id":"source/_posts/img.png","hash":"db8b35d309cd44a71c3be09f8b233916ef2f672e","modified":1644996973556},{"_id":"public/2022/01/26/network/index.html","hash":"154ea4e9cab5b6affebdd25f12b8fe6fc4782c83","modified":1644835401934},{"_id":"public/tags/网络/index.html","hash":"7fd9714429b211e4d29cee37e3574fa60b1918a7","modified":1644835401934},{"_id":"public/tags/JS/index.html","hash":"e5d799400e165d52d10482bb46fb5c7dc06008f5","modified":1644835401934},{"_id":"source/_posts/code.md","hash":"a7b64a5dfdcee6bcbcce8dc3f26ccc58fa963171","modified":1644997056235}],"Category":[{"name":"小技术","_id":"cksipd6qg00066cvmhp8we2tb"}],"Data":[],"Page":[{"title":"Tags","layout":"tags","_content":"","source":"tags/index.md","raw":"title: \"Tags\"\nlayout: \"tags\"\n---","date":"2021-08-18T02:42:13.489Z","updated":"2021-08-18T02:42:13.479Z","path":"tags/index.html","comments":1,"_id":"cksipd6q400006cvm3bv74hec","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"title: \"categories\"\nlayout: \"categories\"\n---\n","date":"2021-08-17T08:55:35.446Z","updated":"2021-08-17T08:53:08.612Z","path":"categories/index.html","comments":1,"_id":"cksipd6qb00026cvmbjyz7xdy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"html","date":"2022-01-10T06:35:30.000Z","_content":"","source":"html/index.md","raw":"---\ntitle: html\ndate: 2022-01-10 14:35:30\n---\n","updated":"2022-01-10T06:35:30.722Z","path":"html/index.html","comments":1,"layout":"page","_id":"cky8ba2mh0000ykv4b6spcpwk","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"vue响应式原理剖析及模拟实现","date":"2021-08-17T10:39:37.000Z","cover":"https://s4.ax1x.com/2022/01/13/7Qja0s.png","_content":"## vue响应式原理分析\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png)\n1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。  \n2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。  \n3、通过compiler对象解析模板和指令，即差值表达式和v-指令。  \n4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。  \n5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图\n\n## vue代码模拟实现\n### 1、项目结构\n![](https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png)\n#### myVue.html代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>差值表达式</div>\n        <div>{{name}}</div>\n        <div>{{age}}</div>\n        <div>v-text</div>\n        <div v-text=\"name\"></div>\n        <div v-text=\"age\"></div>\n        <div>v-html</div>\n        <div v-html=\"name\"></div>\n        <div v-html=\"age\"></div>\n        <div>v-model</div>\n        <input type=\"text\" v-model=\"name\">\n        <input type=\"text\" v-model=\"age\">\n    </div>\n    <script src=\"./js/dep.js\"></script>\n    <script src=\"./js/watcher.js\"></script>\n    <script src=\"./js/compiler.js\"></script>\n    <script src=\"./js/observer.js\"></script>\n    <script src=\"./js/myVue.js\"></script>\n<script>\n    const vm = new MyVue({\n        el: '#app',\n        data: {\n            name: '张三',\n            age: 50,\n            son: {\n                name: '李四',\n                age: 25\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n#### 页面展现\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png)\n### 2、myVue类实现\njs/myVue.js\n```javascript\nclass MyVue {\n  constructor(options) {\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || {};\n      this.$data = options.data || {};\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  }\n  _proxyData(data) {\n      Object.keys(data).forEach(key => {\n          Object.defineProperty(this, key, {\n              enumerable: true,\n              configurable: true,\n              set(v) {\n                  if (v === data[key]) return;\n                  data[key] = v;\n              },\n              get() {\n                  return data[key];\n              }\n          })\n      })\n  }\n}\n```\n### 3、Observer类实现\njs/Observer.js\n```javascript\nclass Observer {\n  constructor(data) {\n      this.walk(data);\n  }\n  walk(data) {\n      if (!data || typeof data !== 'object') return;\n      Object.keys(data).forEach(key => {\n          this.defineReactive(data, key, data[key]);\n      })\n  }\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) {\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, {\n          enumerable: true,\n          configurable: true,\n          set(v) {\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          },\n          get() {\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target && dep.subs.push(Dep.target);\n              return val;\n          }\n      })\n  }\n}\n```\n### 4、Compiler类实现\njs/compiler.js\n```javascript\nclass Compiler {\n    constructor(vm) {\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    }\n    compile(el) {\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node => {\n            if (this.isTextNode(node)) {\n                this.compileText(node);\n            } else if (this.isElementNode(node))  {\n                this.compileElement(node);\n            }\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes && node.childNodes.length) {\n                this.compile(node);\n            }\n        })\n    }\n    // 处理文本节点差值表达式\n    compileText(node) {\n        let reg = /\\{\\{(.+?)\\}\\}/; // 正则匹配差值表达是{{ xxx }}\n        let value = node.textContent;\n        if (reg.test(value)) {\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue => {\n                node.textContent = newValue;\n            });\n        }\n    }\n    // 处理元素节点\n    compileElement(node) {\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) {\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            }\n        })\n    }\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) {\n        let updateFn = this[attrName + 'Updater'];\n        updateFn && updateFn.call(this, node, this.vm[key], key);\n    }\n    // 处理v-text\n    textUpdater(node, val, key) {\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.textContent = newValue;\n        })\n    }\n    // 处理v-html\n    htmlUpdater(node, val, key) {\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue => {\n            node.innerHTML = newValue;\n        })\n    }\n    // 处理v-model\n    modelUpdater(node, val, key) {\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.value = newValue;\n        })\n        // 双向数据绑定\n        node.addEventListener('input', () => {\n            this.vm[key] = node.value;\n        })\n    }\n    // 判断当前节点是否是文本节点\n    isTextNode(node) {\n        return node.nodeType === 3;\n    }\n    // 判断当前节点是否是元素节点\n    isElementNode(node) {\n        return node.nodeType === 1;\n    }\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) {\n        return attrName.startsWith('v-');\n    }\n}\n```\n### 5、发布者Dep类实现\njs/dep.js\n```javascript\nclass Dep {\n    constructor() {\n        // 存储订阅者\n        this.subs = [];\n    }\n    // 添加订阅者\n    addSub(sub) {\n        // 订阅者都有一个update方法\n        if (sub && sub.update) {\n            this.subs.push(sub);\n        } \n    }\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() {\n        this.subs.forEach(sub => {\n            sub.update();\n        })\n    }\n}\n```\n### 6、订阅者Watcher类实现\njs/watcher.js\n```javascript\nclass Watcher {\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) {\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    }\n    update() {\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    }\n}\n```\n### 7、最终效果\n![image.png](https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png)\n\n![image.png](https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png)\n\n![image.png](https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png)\n\n## 结语\n本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术","source":"_posts/vue.md","raw":"---\ntitle: vue响应式原理剖析及模拟实现\ndate: 2021-08-17 18:39:37\ntags:\n - vue\n - 双向绑定\n - 观察者模式\ncover: https://s4.ax1x.com/2022/01/13/7Qja0s.png\n---\n## vue响应式原理分析\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png)\n1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。  \n2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。  \n3、通过compiler对象解析模板和指令，即差值表达式和v-指令。  \n4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。  \n5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图\n\n## vue代码模拟实现\n### 1、项目结构\n![](https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png)\n#### myVue.html代码\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <div id=\"app\">\n        <div>差值表达式</div>\n        <div>{{name}}</div>\n        <div>{{age}}</div>\n        <div>v-text</div>\n        <div v-text=\"name\"></div>\n        <div v-text=\"age\"></div>\n        <div>v-html</div>\n        <div v-html=\"name\"></div>\n        <div v-html=\"age\"></div>\n        <div>v-model</div>\n        <input type=\"text\" v-model=\"name\">\n        <input type=\"text\" v-model=\"age\">\n    </div>\n    <script src=\"./js/dep.js\"></script>\n    <script src=\"./js/watcher.js\"></script>\n    <script src=\"./js/compiler.js\"></script>\n    <script src=\"./js/observer.js\"></script>\n    <script src=\"./js/myVue.js\"></script>\n<script>\n    const vm = new MyVue({\n        el: '#app',\n        data: {\n            name: '张三',\n            age: 50,\n            son: {\n                name: '李四',\n                age: 25\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n#### 页面展现\n![](https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png)\n### 2、myVue类实现\njs/myVue.js\n```javascript\nclass MyVue {\n  constructor(options) {\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || {};\n      this.$data = options.data || {};\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === 'string' ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  }\n  _proxyData(data) {\n      Object.keys(data).forEach(key => {\n          Object.defineProperty(this, key, {\n              enumerable: true,\n              configurable: true,\n              set(v) {\n                  if (v === data[key]) return;\n                  data[key] = v;\n              },\n              get() {\n                  return data[key];\n              }\n          })\n      })\n  }\n}\n```\n### 3、Observer类实现\njs/Observer.js\n```javascript\nclass Observer {\n  constructor(data) {\n      this.walk(data);\n  }\n  walk(data) {\n      if (!data || typeof data !== 'object') return;\n      Object.keys(data).forEach(key => {\n          this.defineReactive(data, key, data[key]);\n      })\n  }\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) {\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, {\n          enumerable: true,\n          configurable: true,\n          set(v) {\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          },\n          get() {\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target && dep.subs.push(Dep.target);\n              return val;\n          }\n      })\n  }\n}\n```\n### 4、Compiler类实现\njs/compiler.js\n```javascript\nclass Compiler {\n    constructor(vm) {\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    }\n    compile(el) {\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node => {\n            if (this.isTextNode(node)) {\n                this.compileText(node);\n            } else if (this.isElementNode(node))  {\n                this.compileElement(node);\n            }\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes && node.childNodes.length) {\n                this.compile(node);\n            }\n        })\n    }\n    // 处理文本节点差值表达式\n    compileText(node) {\n        let reg = /\\{\\{(.+?)\\}\\}/; // 正则匹配差值表达是{{ xxx }}\n        let value = node.textContent;\n        if (reg.test(value)) {\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue => {\n                node.textContent = newValue;\n            });\n        }\n    }\n    // 处理元素节点\n    compileElement(node) {\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr => {\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) {\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            }\n        })\n    }\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) {\n        let updateFn = this[attrName + 'Updater'];\n        updateFn && updateFn.call(this, node, this.vm[key], key);\n    }\n    // 处理v-text\n    textUpdater(node, val, key) {\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.textContent = newValue;\n        })\n    }\n    // 处理v-html\n    htmlUpdater(node, val, key) {\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue => {\n            node.innerHTML = newValue;\n        })\n    }\n    // 处理v-model\n    modelUpdater(node, val, key) {\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue => {\n            node.value = newValue;\n        })\n        // 双向数据绑定\n        node.addEventListener('input', () => {\n            this.vm[key] = node.value;\n        })\n    }\n    // 判断当前节点是否是文本节点\n    isTextNode(node) {\n        return node.nodeType === 3;\n    }\n    // 判断当前节点是否是元素节点\n    isElementNode(node) {\n        return node.nodeType === 1;\n    }\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) {\n        return attrName.startsWith('v-');\n    }\n}\n```\n### 5、发布者Dep类实现\njs/dep.js\n```javascript\nclass Dep {\n    constructor() {\n        // 存储订阅者\n        this.subs = [];\n    }\n    // 添加订阅者\n    addSub(sub) {\n        // 订阅者都有一个update方法\n        if (sub && sub.update) {\n            this.subs.push(sub);\n        } \n    }\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() {\n        this.subs.forEach(sub => {\n            sub.update();\n        })\n    }\n}\n```\n### 6、订阅者Watcher类实现\njs/watcher.js\n```javascript\nclass Watcher {\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) {\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    }\n    update() {\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    }\n}\n```\n### 7、最终效果\n![image.png](https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png)\n\n![image.png](https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png)\n\n![image.png](https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png)\n\n## 结语\n本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术","slug":"vue","published":1,"updated":"2022-01-13T08:50:37.856Z","_id":"cksipd6q700016cvmclixdteq","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"vue响应式原理分析\"><a href=\"#vue响应式原理分析\" class=\"headerlink\" title=\"vue响应式原理分析\"></a>vue响应式原理分析</h2><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png\"><br>1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。<br>2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。<br>3、通过compiler对象解析模板和指令，即差值表达式和v-指令。<br>4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。<br>5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图</p>\n<h2 id=\"vue代码模拟实现\"><a href=\"#vue代码模拟实现\" class=\"headerlink\" title=\"vue代码模拟实现\"></a>vue代码模拟实现</h2><h3 id=\"1、项目结构\"><a href=\"#1、项目结构\" class=\"headerlink\" title=\"1、项目结构\"></a>1、项目结构</h3><p><img src=\"https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png\"></p>\n<h4 id=\"myVue-html代码\"><a href=\"#myVue-html代码\" class=\"headerlink\" title=\"myVue.html代码\"></a>myVue.html代码</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;div&gt;差值表达式&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;v-text&lt;/div&gt;\n        &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-text=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-html&lt;/div&gt;\n        &lt;div v-html=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-html=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-model&lt;/div&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;./js/dep.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/compiler.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/myVue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    const vm = new MyVue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;张三&#39;,\n            age: 50,\n            son: &#123;\n                name: &#39;李四&#39;,\n                age: 25\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"页面展现\"><a href=\"#页面展现\" class=\"headerlink\" title=\"页面展现\"></a>页面展现</h4><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png\"></p>\n<h3 id=\"2、myVue类实现\"><a href=\"#2、myVue类实现\" class=\"headerlink\" title=\"2、myVue类实现\"></a>2、myVue类实现</h3><p>js/myVue.js</p>\n<pre><code class=\"javascript\">class MyVue &#123;\n  constructor(options) &#123;\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || &#123;&#125;;\n      this.$data = options.data || &#123;&#125;;\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === &#39;string&#39; ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  &#125;\n  _proxyData(data) &#123;\n      Object.keys(data).forEach(key =&gt; &#123;\n          Object.defineProperty(this, key, &#123;\n              enumerable: true,\n              configurable: true,\n              set(v) &#123;\n                  if (v === data[key]) return;\n                  data[key] = v;\n              &#125;,\n              get() &#123;\n                  return data[key];\n              &#125;\n          &#125;)\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"3、Observer类实现\"><a href=\"#3、Observer类实现\" class=\"headerlink\" title=\"3、Observer类实现\"></a>3、Observer类实现</h3><p>js/Observer.js</p>\n<pre><code class=\"javascript\">class Observer &#123;\n  constructor(data) &#123;\n      this.walk(data);\n  &#125;\n  walk(data) &#123;\n      if (!data || typeof data !== &#39;object&#39;) return;\n      Object.keys(data).forEach(key =&gt; &#123;\n          this.defineReactive(data, key, data[key]);\n      &#125;)\n  &#125;\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) &#123;\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, &#123;\n          enumerable: true,\n          configurable: true,\n          set(v) &#123;\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          &#125;,\n          get() &#123;\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target &amp;&amp; dep.subs.push(Dep.target);\n              return val;\n          &#125;\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4、Compiler类实现\"><a href=\"#4、Compiler类实现\" class=\"headerlink\" title=\"4、Compiler类实现\"></a>4、Compiler类实现</h3><p>js/compiler.js</p>\n<pre><code class=\"javascript\">class Compiler &#123;\n    constructor(vm) &#123;\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    &#125;\n    compile(el) &#123;\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node =&gt; &#123;\n            if (this.isTextNode(node)) &#123;\n                this.compileText(node);\n            &#125; else if (this.isElementNode(node))  &#123;\n                this.compileElement(node);\n            &#125;\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;\n                this.compile(node);\n            &#125;\n        &#125;)\n    &#125;\n    // 处理文本节点差值表达式\n    compileText(node) &#123;\n        let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/; // 正则匹配差值表达是&#123;&#123; xxx &#125;&#125;\n        let value = node.textContent;\n        if (reg.test(value)) &#123;\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue =&gt; &#123;\n                node.textContent = newValue;\n            &#125;);\n        &#125;\n    &#125;\n    // 处理元素节点\n    compileElement(node) &#123;\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr =&gt; &#123;\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) &#123;\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            &#125;\n        &#125;)\n    &#125;\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) &#123;\n        let updateFn = this[attrName + &#39;Updater&#39;];\n        updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key);\n    &#125;\n    // 处理v-text\n    textUpdater(node, val, key) &#123;\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.textContent = newValue;\n        &#125;)\n    &#125;\n    // 处理v-html\n    htmlUpdater(node, val, key) &#123;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.innerHTML = newValue;\n        &#125;)\n    &#125;\n    // 处理v-model\n    modelUpdater(node, val, key) &#123;\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.value = newValue;\n        &#125;)\n        // 双向数据绑定\n        node.addEventListener(&#39;input&#39;, () =&gt; &#123;\n            this.vm[key] = node.value;\n        &#125;)\n    &#125;\n    // 判断当前节点是否是文本节点\n    isTextNode(node) &#123;\n        return node.nodeType === 3;\n    &#125;\n    // 判断当前节点是否是元素节点\n    isElementNode(node) &#123;\n        return node.nodeType === 1;\n    &#125;\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) &#123;\n        return attrName.startsWith(&#39;v-&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5、发布者Dep类实现\"><a href=\"#5、发布者Dep类实现\" class=\"headerlink\" title=\"5、发布者Dep类实现\"></a>5、发布者Dep类实现</h3><p>js/dep.js</p>\n<pre><code class=\"javascript\">class Dep &#123;\n    constructor() &#123;\n        // 存储订阅者\n        this.subs = [];\n    &#125;\n    // 添加订阅者\n    addSub(sub) &#123;\n        // 订阅者都有一个update方法\n        if (sub &amp;&amp; sub.update) &#123;\n            this.subs.push(sub);\n        &#125; \n    &#125;\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() &#123;\n        this.subs.forEach(sub =&gt; &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"6、订阅者Watcher类实现\"><a href=\"#6、订阅者Watcher类实现\" class=\"headerlink\" title=\"6、订阅者Watcher类实现\"></a>6、订阅者Watcher类实现</h3><p>js/watcher.js</p>\n<pre><code class=\"javascript\">class Watcher &#123;\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) &#123;\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    &#125;\n    update() &#123;\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"7、最终效果\"><a href=\"#7、最终效果\" class=\"headerlink\" title=\"7、最终效果\"></a>7、最终效果</h3><p><img src=\"https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png\" alt=\"image.png\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"vue响应式原理分析\"><a href=\"#vue响应式原理分析\" class=\"headerlink\" title=\"vue响应式原理分析\"></a>vue响应式原理分析</h2><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GFE0LJH.png\"><br>1、初始化Vue实例时，将初始化传入data对象属性替换成getter和setter，并注入Vue的实例。<br>2、通过Observer对象对data数据进行数据劫持，即将data所有属性通过Object的defineProperty方法都添加get和set方法，这样每当数据获取和改变就会触发get和set方法，从而做到数据监听。<br>3、通过compiler对象解析模板和指令，即差值表达式和v-指令。<br>4、在Observer给data对象注入get和set方法的同时，给每个属性都添加一个订阅者Dep对象。<br>5、在每个用到data属性的地方都添加一个观察者Watcher，每当数据发送变化，订阅者Dep通知观察者Watcher更新视图</p>\n<h2 id=\"vue代码模拟实现\"><a href=\"#vue代码模拟实现\" class=\"headerlink\" title=\"vue代码模拟实现\"></a>vue代码模拟实现</h2><h3 id=\"1、项目结构\"><a href=\"#1、项目结构\" class=\"headerlink\" title=\"1、项目结构\"></a>1、项目结构</h3><p><img src=\"https://i.loli.net/2021/08/19/3XuCZKE92zvTix5.png\"></p>\n<h4 id=\"myVue-html代码\"><a href=\"#myVue-html代码\" class=\"headerlink\" title=\"myVue.html代码\"></a>myVue.html代码</h4><pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;div&gt;差值表达式&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;&#123;&#123;age&#125;&#125;&lt;/div&gt;\n        &lt;div&gt;v-text&lt;/div&gt;\n        &lt;div v-text=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-text=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-html&lt;/div&gt;\n        &lt;div v-html=&quot;name&quot;&gt;&lt;/div&gt;\n        &lt;div v-html=&quot;age&quot;&gt;&lt;/div&gt;\n        &lt;div&gt;v-model&lt;/div&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;age&quot;&gt;\n    &lt;/div&gt;\n    &lt;script src=&quot;./js/dep.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/watcher.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/compiler.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/observer.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./js/myVue.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    const vm = new MyVue(&#123;\n        el: &#39;#app&#39;,\n        data: &#123;\n            name: &#39;张三&#39;,\n            age: 50,\n            son: &#123;\n                name: &#39;李四&#39;,\n                age: 25\n            &#125;\n        &#125;\n    &#125;)\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4 id=\"页面展现\"><a href=\"#页面展现\" class=\"headerlink\" title=\"页面展现\"></a>页面展现</h4><p><img src=\"https://img.cmvideo.cn/publish/noms/2021/08/18/1O32J6GSNVNNP.png\"></p>\n<h3 id=\"2、myVue类实现\"><a href=\"#2、myVue类实现\" class=\"headerlink\" title=\"2、myVue类实现\"></a>2、myVue类实现</h3><p>js/myVue.js</p>\n<pre><code class=\"javascript\">class MyVue &#123;\n  constructor(options) &#123;\n      // 将构建vue对象传入的参数存入vue实例\n      this.$options = options || &#123;&#125;;\n      this.$data = options.data || &#123;&#125;;\n      // el可以是dom对象也可以是字符串\n      this.$el = typeof options.el === &#39;string&#39; ? document.querySelector(options.el) : options.el;\n      // 将data中属性替换为getter，setter, 注入到vue实例中\n      this._proxyData(this.$data);\n      // 将data的属性变为响应式\n      new Observer(this.$data);\n      // 解析模板和指令\n      new Compiler(this);\n  &#125;\n  _proxyData(data) &#123;\n      Object.keys(data).forEach(key =&gt; &#123;\n          Object.defineProperty(this, key, &#123;\n              enumerable: true,\n              configurable: true,\n              set(v) &#123;\n                  if (v === data[key]) return;\n                  data[key] = v;\n              &#125;,\n              get() &#123;\n                  return data[key];\n              &#125;\n          &#125;)\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"3、Observer类实现\"><a href=\"#3、Observer类实现\" class=\"headerlink\" title=\"3、Observer类实现\"></a>3、Observer类实现</h3><p>js/Observer.js</p>\n<pre><code class=\"javascript\">class Observer &#123;\n  constructor(data) &#123;\n      this.walk(data);\n  &#125;\n  walk(data) &#123;\n      if (!data || typeof data !== &#39;object&#39;) return;\n      Object.keys(data).forEach(key =&gt; &#123;\n          this.defineReactive(data, key, data[key]);\n      &#125;)\n  &#125;\n  // 传入参数val,而不直接使用data[key]，是为了避免死循环触发get,set，导致内存溢出\n  defineReactive(data, key, val) &#123;\n      let self = this;\n      // 如果属性的值也是对象，应该将此对象的属性也变为响应式\n      this.walk(val);\n      // 给data的每一个属性创建一个发布者dep对象\n      let dep = new Dep();\n      Object.defineProperty(data, key, &#123;\n          enumerable: true,\n          configurable: true,\n          set(v) &#123;\n              if (v === val) return;\n              val = v;\n              // 如果修改的值为对象，则也需将此对象的属性转换为响应式\n              self.walk(v);\n              // data数据发生改变，触发set方法，通知发布者，执行notify方法，通知订阅者更新视图\n              dep.notify();\n          &#125;,\n          get() &#123;\n              // 订阅者watcher实例创建时，会该实例赋值给Dep的静态属性target，同时会触发data[key]的get方法\n              // 将订阅者存入该属性创建的发布者对象中\n              Dep.target &amp;&amp; dep.subs.push(Dep.target);\n              return val;\n          &#125;\n      &#125;)\n  &#125;\n&#125;\n</code></pre>\n<h3 id=\"4、Compiler类实现\"><a href=\"#4、Compiler类实现\" class=\"headerlink\" title=\"4、Compiler类实现\"></a>4、Compiler类实现</h3><p>js/compiler.js</p>\n<pre><code class=\"javascript\">class Compiler &#123;\n    constructor(vm) &#123;\n        this.vm = vm;\n        this.el = vm.$el;\n        this.compile(this.el);\n    &#125;\n    compile(el) &#123;\n        let childNodes = el.childNodes;\n        Array.from(childNodes).forEach(node =&gt; &#123;\n            if (this.isTextNode(node)) &#123;\n                this.compileText(node);\n            &#125; else if (this.isElementNode(node))  &#123;\n                this.compileElement(node);\n            &#125;\n            // 如果子节点还有子节点，需循环调用\n            if (node.childNodes &amp;&amp; node.childNodes.length) &#123;\n                this.compile(node);\n            &#125;\n        &#125;)\n    &#125;\n    // 处理文本节点差值表达式\n    compileText(node) &#123;\n        let reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/; // 正则匹配差值表达是&#123;&#123; xxx &#125;&#125;\n        let value = node.textContent;\n        if (reg.test(value)) &#123;\n            let key = RegExp.$1.trim();\n            node.textContent = value.replace(reg, this.vm[key]);\n            // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n            new Watcher(this.vm, key, newValue =&gt; &#123;\n                node.textContent = newValue;\n            &#125;);\n        &#125;\n    &#125;\n    // 处理元素节点\n    compileElement(node) &#123;\n        let attrs = node.attributes;\n        Array.from(attrs).forEach(attr =&gt; &#123;\n            let attrName = attr.name;\n            if (this.isDirective(attrName)) &#123;\n                attrName = attrName.substr(2);\n                let key = attr.value;\n                this.update(node, key, attrName);\n            &#125;\n        &#125;)\n    &#125;\n    // 这样写的好处是避免在方法里写过多的if判断，以后新增指令解析只需新增xxxUpdater方法即可\n    update(node, key, attrName) &#123;\n        let updateFn = this[attrName + &#39;Updater&#39;];\n        updateFn &amp;&amp; updateFn.call(this, node, this.vm[key], key);\n    &#125;\n    // 处理v-text\n    textUpdater(node, val, key) &#123;\n        node.textContent = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.textContent = newValue;\n        &#125;)\n    &#125;\n    // 处理v-html\n    htmlUpdater(node, val, key) &#123;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        node.innerHTML = val;\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.innerHTML = newValue;\n        &#125;)\n    &#125;\n    // 处理v-model\n    modelUpdater(node, val, key) &#123;\n        node.value = val;\n        // 为每个依赖data属性的地方，创建订阅者，当数据改变时，更新视图\n        new Watcher(this.vm, key, newValue =&gt; &#123;\n            node.value = newValue;\n        &#125;)\n        // 双向数据绑定\n        node.addEventListener(&#39;input&#39;, () =&gt; &#123;\n            this.vm[key] = node.value;\n        &#125;)\n    &#125;\n    // 判断当前节点是否是文本节点\n    isTextNode(node) &#123;\n        return node.nodeType === 3;\n    &#125;\n    // 判断当前节点是否是元素节点\n    isElementNode(node) &#123;\n        return node.nodeType === 1;\n    &#125;\n    // 判断当前元素是否是vue指令\n    isDirective(attrName) &#123;\n        return attrName.startsWith(&#39;v-&#39;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"5、发布者Dep类实现\"><a href=\"#5、发布者Dep类实现\" class=\"headerlink\" title=\"5、发布者Dep类实现\"></a>5、发布者Dep类实现</h3><p>js/dep.js</p>\n<pre><code class=\"javascript\">class Dep &#123;\n    constructor() &#123;\n        // 存储订阅者\n        this.subs = [];\n    &#125;\n    // 添加订阅者\n    addSub(sub) &#123;\n        // 订阅者都有一个update方法\n        if (sub &amp;&amp; sub.update) &#123;\n            this.subs.push(sub);\n        &#125; \n    &#125;\n    // 数据发生变化时通知当前实例存入的所有订阅者，执行订阅者的update方法\n    notify() &#123;\n        this.subs.forEach(sub =&gt; &#123;\n            sub.update();\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"6、订阅者Watcher类实现\"><a href=\"#6、订阅者Watcher类实现\" class=\"headerlink\" title=\"6、订阅者Watcher类实现\"></a>6、订阅者Watcher类实现</h3><p>js/watcher.js</p>\n<pre><code class=\"javascript\">class Watcher &#123;\n    // 创建实例接收三个参数，cb是触发update时执行的回调\n    constructor(vm, key, cb) &#123;\n        this.vm = vm;\n        this.key = key;\n        this.cb = cb;\n        // 将当前订阅者对象赋值给发布者对象的静态属性target，在执行date[key]的get方法时，将订阅者对象存入发布者对象的subs属性里\n        Dep.target = this;\n        this.oldValue = vm[key];\n        // 清空target属性，避免多次存入\n        Dep.target = null;\n    &#125;\n    update() &#123;\n        let newValue = this.vm[this.key];\n        if (newValue === this.oldValue) return;\n        this.cb(newValue);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"7、最终效果\"><a href=\"#7、最终效果\" class=\"headerlink\" title=\"7、最终效果\"></a>7、最终效果</h3><p><img src=\"https://i.loli.net/2021/08/19/j8Ssxd2IDU6R1qc.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6Ljn8AhCFVysqHk.png\" alt=\"image.png\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/BztLhRKxUVEMX5c.png\" alt=\"image.png\"></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>本次通过代码模拟了vue的响应式编程原理，其中涉及到数据劫持、双向绑定、观察者模式等技术</p>\n"},{"title":"blog搭建流程","date":"2021-08-08T00:00:00.000Z","cover":"https://s4.ax1x.com/2022/01/13/7QjtXQ.png","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### 云游的小安利搭建详细教程\n[云游的小安利搭建详细教程](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n","source":"_posts/hello-world.md","raw":"---\ntitle: blog搭建流程\ncategories: 小技术\ndate: '2021-08-08'\ncover:   https://s4.ax1x.com/2022/01/13/7QjtXQ.png\n\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n\n### 云游的小安利搭建详细教程\n[云游的小安利搭建详细教程](https://www.yunyoujun.cn/share/how-to-build-your-site/)\n","slug":"hello-world","published":1,"updated":"2022-01-13T08:49:55.974Z","_id":"cksipd6qb00036cvmfdc54s6o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"云游的小安利搭建详细教程\"><a href=\"#云游的小安利搭建详细教程\" class=\"headerlink\" title=\"云游的小安利搭建详细教程\"></a>云游的小安利搭建详细教程</h3><p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">云游的小安利搭建详细教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n<h3 id=\"云游的小安利搭建详细教程\"><a href=\"#云游的小安利搭建详细教程\" class=\"headerlink\" title=\"云游的小安利搭建详细教程\"></a>云游的小安利搭建详细教程</h3><p><a href=\"https://www.yunyoujun.cn/share/how-to-build-your-site/\">云游的小安利搭建详细教程</a></p>\n"},{"title":"vueRouter原理剖析","date":"2021-08-13T10:39:37.000Z","cover":"https://s4.ax1x.com/2022/01/13/7QjBt0.png","_content":"## 原理分析\n1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install  \n2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换  \n3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  \n\n## 代码实现\n```javascript\nlet _Vue = null;\nexport default class VueRouter {\n    // 供Vue.use调用\n    static install(Vue) {\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) {\n            return;\n        } \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin({\n            beforeCreate() {\n                // 此处的this指向Vue实例\n                if (this.$options.router) { // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                } \n            }\n        })\n     }\n     constructor(options) {\n        this.options = options;\n        this.routeMap = {};\n        this.data = _Vue.observable({ // 将data中属性变为响应式数据\n            current: '/'\n        })\n    }\n    init() {\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    }\n    createRouteMap() {\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component;\n        })\n    }\n    initComponents() {\n        let self = this;\n        // 定义router-link组件\n        _Vue.component('router-link', {\n            props: { // 接受的参数\n                to: String\n            },\n            render(h) { // 渲染模板，渲染成a标签\n                return h('a', {\n                    attrs: {\n                        href: this.to\n                    },\n                    on: {\n                        click: this.clickHandle\n                    }\n                }, [this.$slots.default]) // router-link中的内容\n            },\n            methods: {\n                 clickHandle(e) {\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState({}, '', this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 }\n            }\n        });\n        // 定义router-view\n        _Vue.component('router-view', {\n            render(h) { // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            }\n        })\n    }\n    initEvent() {\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener('popstate', () => {\n            this.data.current = window.location.pathname;\n        })\n    }\n}\n```\n## 代码验证\n1、使用Vue脚手架工具，构建一个带有vueRouter的项目\n```bash\nnpm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n> Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n>(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n > 2.x\n   3.x\n\n```\n2、将实现代码写入myViewRouter.js中\n3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter\n```javascript\nimport VueRouter from '../myViewRouter/myViewRouter' // 引入自己的路径\n```\n4、开始运行模拟实现\n\n","source":"_posts/vueRouter.md","raw":"---\ntitle: vueRouter原理剖析\ndate: 2021-08-13 18:39:37\ntags: \n    - vue \n    - 单页面 \n    - 路由\ncover:    https://s4.ax1x.com/2022/01/13/7QjBt0.png\n---\n## 原理分析\n1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install  \n2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换  \n3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  \n\n## 代码实现\n```javascript\nlet _Vue = null;\nexport default class VueRouter {\n    // 供Vue.use调用\n    static install(Vue) {\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) {\n            return;\n        } \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin({\n            beforeCreate() {\n                // 此处的this指向Vue实例\n                if (this.$options.router) { // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                } \n            }\n        })\n     }\n     constructor(options) {\n        this.options = options;\n        this.routeMap = {};\n        this.data = _Vue.observable({ // 将data中属性变为响应式数据\n            current: '/'\n        })\n    }\n    init() {\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    }\n    createRouteMap() {\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route => {\n            this.routeMap[route.path] = route.component;\n        })\n    }\n    initComponents() {\n        let self = this;\n        // 定义router-link组件\n        _Vue.component('router-link', {\n            props: { // 接受的参数\n                to: String\n            },\n            render(h) { // 渲染模板，渲染成a标签\n                return h('a', {\n                    attrs: {\n                        href: this.to\n                    },\n                    on: {\n                        click: this.clickHandle\n                    }\n                }, [this.$slots.default]) // router-link中的内容\n            },\n            methods: {\n                 clickHandle(e) {\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState({}, '', this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 }\n            }\n        });\n        // 定义router-view\n        _Vue.component('router-view', {\n            render(h) { // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            }\n        })\n    }\n    initEvent() {\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener('popstate', () => {\n            this.data.current = window.location.pathname;\n        })\n    }\n}\n```\n## 代码验证\n1、使用Vue脚手架工具，构建一个带有vueRouter的项目\n```bash\nnpm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n> Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n>(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n > 2.x\n   3.x\n\n```\n2、将实现代码写入myViewRouter.js中\n3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter\n```javascript\nimport VueRouter from '../myViewRouter/myViewRouter' // 引入自己的路径\n```\n4、开始运行模拟实现\n\n","slug":"vueRouter","published":1,"updated":"2022-01-13T08:50:37.850Z","_id":"ckssmzt2e001gb0vm6vxo5nyw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install<br>2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换<br>3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  </p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"javascript\">let _Vue = null;\nexport default class VueRouter &#123;\n    // 供Vue.use调用\n    static install(Vue) &#123;\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) &#123;\n            return;\n        &#125; \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin(&#123;\n            beforeCreate() &#123;\n                // 此处的this指向Vue实例\n                if (this.$options.router) &#123; // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                &#125; \n            &#125;\n        &#125;)\n     &#125;\n     constructor(options) &#123;\n        this.options = options;\n        this.routeMap = &#123;&#125;;\n        this.data = _Vue.observable(&#123; // 将data中属性变为响应式数据\n            current: &#39;/&#39;\n        &#125;)\n    &#125;\n    init() &#123;\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    &#125;\n    createRouteMap() &#123;\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route =&gt; &#123;\n            this.routeMap[route.path] = route.component;\n        &#125;)\n    &#125;\n    initComponents() &#123;\n        let self = this;\n        // 定义router-link组件\n        _Vue.component(&#39;router-link&#39;, &#123;\n            props: &#123; // 接受的参数\n                to: String\n            &#125;,\n            render(h) &#123; // 渲染模板，渲染成a标签\n                return h(&#39;a&#39;, &#123;\n                    attrs: &#123;\n                        href: this.to\n                    &#125;,\n                    on: &#123;\n                        click: this.clickHandle\n                    &#125;\n                &#125;, [this.$slots.default]) // router-link中的内容\n            &#125;,\n            methods: &#123;\n                 clickHandle(e) &#123;\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState(&#123;&#125;, &#39;&#39;, this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 &#125;\n            &#125;\n        &#125;);\n        // 定义router-view\n        _Vue.component(&#39;router-view&#39;, &#123;\n            render(h) &#123; // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            &#125;\n        &#125;)\n    &#125;\n    initEvent() &#123;\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener(&#39;popstate&#39;, () =&gt; &#123;\n            this.data.current = window.location.pathname;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"代码验证\"><a href=\"#代码验证\" class=\"headerlink\" title=\"代码验证\"></a>代码验证</h2><p>1、使用Vue脚手架工具，构建一个带有vueRouter的项目</p>\n<pre><code class=\"bash\">npm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n&gt;(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n &gt; 2.x\n   3.x\n</code></pre>\n<p>2、将实现代码写入myViewRouter.js中<br>3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter</p>\n<pre><code class=\"javascript\">import VueRouter from &#39;../myViewRouter/myViewRouter&#39; // 引入自己的路径\n</code></pre>\n<p>4、开始运行模拟实现</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理分析\"><a href=\"#原理分析\" class=\"headerlink\" title=\"原理分析\"></a>原理分析</h2><p>1、VueRouter是一个插件类，能够被Vue.use()调用，即类的内部有一个静态方法install<br>2、VueRouter类内部有三个成员，即options负责接收构建实例时传入的参数，routeMap负责将options中将路由规则routes以键值对的方法存起来，data中有一个current响应式属性用来改变路由切换<br>3、VueRouter类内部存在三个方法，initComponents用来解析路由指令router-link和router-view，createRouteMap负责将路由规则存储，initEvent监听浏览器的回退实现路由跳转  </p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"javascript\">let _Vue = null;\nexport default class VueRouter &#123;\n    // 供Vue.use调用\n    static install(Vue) &#123;\n        // 判断当前插件是否安装，即install方法是否被调用，若已调用则不再执行安装\n        if (VueRouter.install.installed) &#123;\n            return;\n        &#125; \n        VueRouter.install.installed = true;\n        // 将传入Vue存入到全局，方便后面方法调用\n        _Vue = Vue; \n        // 把创建Vue实例时传入的router对象注入到Vue实例上\n        // 混入\n        Vue.mixin(&#123;\n            beforeCreate() &#123;\n                // 此处的this指向Vue实例\n                if (this.$options.router) &#123; // 只在Vue构建实例时执行，在组件内部不执行\n                    Vue.prototype.$router = this.$options.router;\n                    this.$options.router.init();\n                &#125; \n            &#125;\n        &#125;)\n     &#125;\n     constructor(options) &#123;\n        this.options = options;\n        this.routeMap = &#123;&#125;;\n        this.data = _Vue.observable(&#123; // 将data中属性变为响应式数据\n            current: &#39;/&#39;\n        &#125;)\n    &#125;\n    init() &#123;\n        this.createRouteMap();\n        this.initComponents();\n        this.initEvent();\n    &#125;\n    createRouteMap() &#123;\n        // 将传入的路由规则path和组件component按照键值对的形式存入routeMap中\n        this.options.routes.forEach(route =&gt; &#123;\n            this.routeMap[route.path] = route.component;\n        &#125;)\n    &#125;\n    initComponents() &#123;\n        let self = this;\n        // 定义router-link组件\n        _Vue.component(&#39;router-link&#39;, &#123;\n            props: &#123; // 接受的参数\n                to: String\n            &#125;,\n            render(h) &#123; // 渲染模板，渲染成a标签\n                return h(&#39;a&#39;, &#123;\n                    attrs: &#123;\n                        href: this.to\n                    &#125;,\n                    on: &#123;\n                        click: this.clickHandle\n                    &#125;\n                &#125;, [this.$slots.default]) // router-link中的内容\n            &#125;,\n            methods: &#123;\n                 clickHandle(e) &#123;\n                     // 将当前路径存入浏览器历史中\n                     window.history.pushState(&#123;&#125;, &#39;&#39;, this.to);\n                     // 改变当前路径\n                     this.$router.data.current = this.to;\n                     // 阻止a标签的默认行为\n                     e.preventDefault();\n                 &#125;\n            &#125;\n        &#125;);\n        // 定义router-view\n        _Vue.component(&#39;router-view&#39;, &#123;\n            render(h) &#123; // 根据当前路径获取到当前路径对应的组件component，渲染到页面中\n                let temp = this.$router.routeMap[self.data.current];\n                return h(temp);\n            &#125;\n        &#125;)\n    &#125;\n    initEvent() &#123;\n        // 监听浏览器回退、前进按钮，获取当前路径，由于current为响应式数据，数据改变，当前组件也会改变\n        window.addEventListener(&#39;popstate&#39;, () =&gt; &#123;\n            this.data.current = window.location.pathname;\n        &#125;)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"代码验证\"><a href=\"#代码验证\" class=\"headerlink\" title=\"代码验证\"></a>代码验证</h2><p>1、使用Vue脚手架工具，构建一个带有vueRouter的项目</p>\n<pre><code class=\"bash\">npm install -g @vue/cli\n\nvue create my-router-view\n\nVue CLI v4.5.13\n? Please pick a preset:\n  Default ([Vue 2] babel, eslint)\n  Default (Vue 3) ([Vue 3] babel, eslint)\n&gt; Manually select features\n\nVue CLI v4.5.13\n? Please pick a preset: Manually select features\n? Check the features needed for your project:\n (*) Choose Vue version\n (*) Babel\n ( ) TypeScript\n ( ) Progressive Web App (PWA) Support\n&gt;(*) Router\n ( ) Vuex\n ( ) CSS Pre-processors\n (*) Linter / Formatter\n ( ) Unit Testing\n ( ) E2E Testing\n \n Vue CLI v4.5.13\n ? Please pick a preset: Manually select features\n ? Check the features needed for your project: Choose Vue version, Babel, Router, Linter\n ? Choose a version of Vue.js that you want to start the project with\n &gt; 2.x\n   3.x\n</code></pre>\n<p>2、将实现代码写入myViewRouter.js中<br>3、将router/index.js中引入VueRouter替换为自己实现的myViewRouter</p>\n<pre><code class=\"javascript\">import VueRouter from &#39;../myViewRouter/myViewRouter&#39; // 引入自己的路径\n</code></pre>\n<p>4、开始运行模拟实现</p>\n"},{"title":"promise原理剖析及模拟实现","date":"2021-08-10T10:39:37.000Z","cover":"https://s4.ax1x.com/2022/01/13/7Qjd7n.png","_content":"\n## promise原理解析及模拟实现\n### promise原理\n1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法  \n2、执行器方法接收两个参数，分别是resolve方法和reject方法  \n3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending  \n4、Promise的resolve、reject方法是用来改变状态的 resolve: pending => fulfilled, reject: pending => rejected，一旦状态确定就不可修改\n5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调  \n6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因\n\n### 代码实现\n#### 1、初步实现\n```javascript\n// --------------Promise代码--------------\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        resolve(i);\n    } else {\n        reject('不是偶数')\n    }\n})\npromise.then((val) => {\n    console.log(val);\n}, (reason) => {\n    console.log(reason);\n})\n```\n思考：  \n1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程  \n2、如果resolve和reject是异步调用，那多次执行then方法  \n上面代码是否满足这两种情况？\n\n#### 2、二次实现\n```javascript\n// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback && this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback && this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        } else { // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        setTimeout(() => {\n            resolve(i);\n        }, 2000)\n    } else {\n        setTimeout(() => {\n            reject('不是偶数');\n        }, 2000)\n    }\n})\npromise.then((val) => {\n    console.log('第一次',val);\n}, (reason) => {\n    console.log(reason);\n})\npromise.then((val) => {\n    console.log('第二次',val);\n}, (reason) => {\n    console.log('第二次', reason);\n})\n```\n思考：  \n1、then方法链式调用  \n2、then方法链式调用可以不传回调  \n上面代码是否满足？ \n\n```javascript\n// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n```\n\n\n\n\n","source":"_posts/promise.md","raw":"---\ntitle: promise原理剖析及模拟实现\ndate: 2021-08-10 18:39:37\ntags: \n    - promise \ncover: https://s4.ax1x.com/2022/01/13/7Qjd7n.png\n---\n\n## promise原理解析及模拟实现\n### promise原理\n1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法  \n2、执行器方法接收两个参数，分别是resolve方法和reject方法  \n3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending  \n4、Promise的resolve、reject方法是用来改变状态的 resolve: pending => fulfilled, reject: pending => rejected，一旦状态确定就不可修改\n5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调  \n6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因\n\n### 代码实现\n#### 1、初步实现\n```javascript\n// --------------Promise代码--------------\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        resolve(i);\n    } else {\n        reject('不是偶数')\n    }\n})\npromise.then((val) => {\n    console.log(val);\n}, (reason) => {\n    console.log(reason);\n})\n```\n思考：  \n1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程  \n2、如果resolve和reject是异步调用，那多次执行then方法  \n上面代码是否满足这两种情况？\n\n#### 2、二次实现\n```javascript\n// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\nclass MyPromise {\n    constructor(executor) {\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback && this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        }\n        this.reject = (reason) => {\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback && this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        }\n        executor(this.resolve, this.reject);\n    }\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) {\n        if (this.status === FULFILLED) {\n            successCallback(this.value);\n        } else if (this.status === REJECTED) {\n            failCallback(this.reason);\n        } else { // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        }\n    }\n}\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) => {\n    let i = 2;\n    if (i % 2 === 0) {\n        setTimeout(() => {\n            resolve(i);\n        }, 2000)\n    } else {\n        setTimeout(() => {\n            reject('不是偶数');\n        }, 2000)\n    }\n})\npromise.then((val) => {\n    console.log('第一次',val);\n}, (reason) => {\n    console.log(reason);\n})\npromise.then((val) => {\n    console.log('第二次',val);\n}, (reason) => {\n    console.log('第二次', reason);\n})\n```\n思考：  \n1、then方法链式调用  \n2、then方法链式调用可以不传回调  \n上面代码是否满足？ \n\n```javascript\n// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n```\n\n\n\n\n","slug":"promise","published":1,"updated":"2022-01-13T08:49:55.964Z","_id":"cksspqlja001kb0vm992ncjf5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"promise原理解析及模拟实现\"><a href=\"#promise原理解析及模拟实现\" class=\"headerlink\" title=\"promise原理解析及模拟实现\"></a>promise原理解析及模拟实现</h2><h3 id=\"promise原理\"><a href=\"#promise原理\" class=\"headerlink\" title=\"promise原理\"></a>promise原理</h3><p>1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法<br>2、执行器方法接收两个参数，分别是resolve方法和reject方法<br>3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending<br>4、Promise的resolve、reject方法是用来改变状态的 resolve: pending =&gt; fulfilled, reject: pending =&gt; rejected，一旦状态确定就不可修改<br>5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调<br>6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"1、初步实现\"><a href=\"#1、初步实现\" class=\"headerlink\" title=\"1、初步实现\"></a>1、初步实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        resolve(i);\n    &#125; else &#123;\n        reject(&#39;不是偶数&#39;)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程<br>2、如果resolve和reject是异步调用，那多次执行then方法<br>上面代码是否满足这两种情况？</p>\n<h4 id=\"2、二次实现\"><a href=\"#2、二次实现\" class=\"headerlink\" title=\"2、二次实现\"></a>2、二次实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback &amp;&amp; this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback &amp;&amp; this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125; else &#123; // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(i);\n        &#125;, 2000)\n    &#125; else &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;不是偶数&#39;);\n        &#125;, 2000)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第一次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第二次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(&#39;第二次&#39;, reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、then方法链式调用<br>2、then方法链式调用可以不传回调<br>上面代码是否满足？ </p>\n<pre><code class=\"javascript\">// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"promise原理解析及模拟实现\"><a href=\"#promise原理解析及模拟实现\" class=\"headerlink\" title=\"promise原理解析及模拟实现\"></a>promise原理解析及模拟实现</h2><h3 id=\"promise原理\"><a href=\"#promise原理\" class=\"headerlink\" title=\"promise原理\"></a>promise原理</h3><p>1、Promise就是一个类，在构建Promise实例时需要传递一个立即执行的执行器方法<br>2、执行器方法接收两个参数，分别是resolve方法和reject方法<br>3、Promise执行过程中，存在三种状态，分别为：成功 fulfilled，失败 rejected，等待 pending<br>4、Promise的resolve、reject方法是用来改变状态的 resolve: pending =&gt; fulfilled, reject: pending =&gt; rejected，一旦状态确定就不可修改<br>5、Promise的then方法是用来判断当前状态，成功则执行成功回调，失败则执行失败回调<br>6、then方法分别接受成功回调和失败回调两个参数，成功回调函数有一个参数，表示成功之后的值，失败回调函数有一个参数，表示失败的原因</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><h4 id=\"1、初步实现\"><a href=\"#1、初步实现\" class=\"headerlink\" title=\"1、初步实现\"></a>1、初步实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        resolve(i);\n    &#125; else &#123;\n        reject(&#39;不是偶数&#39;)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、实际应用promise大都用于请求接口，获取返回值，再resolve或reject结果，这种异步流程<br>2、如果resolve和reject是异步调用，那多次执行then方法<br>上面代码是否满足这两种情况？</p>\n<h4 id=\"2、二次实现\"><a href=\"#2、二次实现\" class=\"headerlink\" title=\"2、二次实现\"></a>2、二次实现</h4><pre><code class=\"javascript\">// --------------Promise代码--------------\n/**\n * 注释原因\n * 1、无法满足异步情况下，多次调用then方法的情况，最后一次的回调会将前面的回调覆盖\n */\n\nconst PENDING = &#39;pending&#39;;\nconst FULFILLED = &#39;fulfilled&#39;;\nconst REJECTED = &#39;rejected&#39;;\nclass MyPromise &#123;\n    constructor(executor) &#123;\n        this.status = PENDING;\n        this.value = undefined; // 执行成功后返回的值\n        this.reason = undefined; // 执行失败互殴返回的原因\n\n        // 注释原因(1)\n        // this.successCallback = undefined; // 成功的回调\n        // this.failedCallback = undefined; // 失败的回调\n\n        // 兼用异步情况下，多次调用then方法\n        this.successCallback = []; // 存入成功的回调\n        this.failedCallback = []; // 存入失败的回调\n        this.resolve = (val) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为成功\n            this.status = FULFILLED;\n            // 接受成功后传递的值\n            this.value = val;\n            // 只用在异步调用resolve时，this.successCallback才不为空，才调用\n            // 注释原因(1)\n            // this.successCallback &amp;&amp; this.successCallback(this.value);\n\n            while (this.successCallback.length) this.successCallback.shift()(this.value);\n        &#125;\n        this.reject = (reason) =&gt; &#123;\n            // 如果状态不是等待，表示状态已经改变，不可再进行修改\n            if (this.status !== PENDING) return;\n            // 将状态变为失败\n            this.status = REJECTED;\n            // 接受失败后传递的原因\n            this.reason = reason;\n            // 只用在异步调用reject时，this.failCallback才不为空，才调用\n            // 注释原因(1)\n            // this.failCallback &amp;&amp; this.failCallback(this.reason);\n\n            while (this.failedCallback.length) this.failedCallback.shift()(this.reason);\n        &#125;\n        executor(this.resolve, this.reject);\n    &#125;\n    // then方法接受成功回调和失败回调两个参数，如果调用时状态为成功则执行成功的回调，状态为失败则执行失败的回调\n    then(successCallback, failCallback) &#123;\n        if (this.status === FULFILLED) &#123;\n            successCallback(this.value);\n        &#125; else if (this.status === REJECTED) &#123;\n            failCallback(this.reason);\n        &#125; else &#123; // 异步resolve或reject时，执行then方法时，当前状态为pending\n            // 将当前回调函数先存起来，在resolve和reject执行时再调用\n\n            // 注释原因(1)\n            // this.successCallback = successCallback;\n            // this.failCallback = failCallback;\n\n            this.successCallback.push(successCallback);\n            this.failedCallback.push(failCallback);\n        &#125;\n    &#125;\n&#125;\n\n// --------------调用--------------\nlet promise = new MyPromise((resolve, reject) =&gt; &#123;\n    let i = 2;\n    if (i % 2 === 0) &#123;\n        setTimeout(() =&gt; &#123;\n            resolve(i);\n        &#125;, 2000)\n    &#125; else &#123;\n        setTimeout(() =&gt; &#123;\n            reject(&#39;不是偶数&#39;);\n        &#125;, 2000)\n    &#125;\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第一次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(reason);\n&#125;)\npromise.then((val) =&gt; &#123;\n    console.log(&#39;第二次&#39;,val);\n&#125;, (reason) =&gt; &#123;\n    console.log(&#39;第二次&#39;, reason);\n&#125;)\n</code></pre>\n<p>思考：<br>1、then方法链式调用<br>2、then方法链式调用可以不传回调<br>上面代码是否满足？ </p>\n<pre><code class=\"javascript\">// then方法链式调用，后面then执行回调都是前面then方法的返回值，看返回值是普通值还是promise对象  \n// 如果是promise需要判断promise执行resolve还是reject，来执行相应的回调\n</code></pre>\n"},{"title":"htmlAndCss知识","date":"2022-01-10T06:37:16.000Z","cover":"https://s4.ax1x.com/2022/01/13/7QjUmj.png","_content":"\n## htmlAndCss知识\n### 1、html5新特性、语义化\nhtml5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用  \n语义化标签: header、nav、main、article、section、aside、footer  \n语义化的优点有：  \n1.代码结构清晰，易于阅读，利与开发和维护  \n2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页  \n3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  \n\n### 2、浏览器渲染机制、重绘、重排\n#### 网页生产过程：  \n1.HTML被HTML解析器解析成DOM树  \n2.CSS则被CSS解析器解析成CSSOM树  \n3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）  \n4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成  \n5.将布局绘制（paint）在屏幕上\n\n#### 重排（回流）\n当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。  \n触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变---边距、填充、边框、宽度和高度\n\n#### 重绘\n当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。  \n触发：改变元素的color、background、box-shadow等属性\n\n#### 重排优化建议\n1.分离读写操作  \n2.样式集中修改  \n3.缓存需要修改的DOM元素  \n4.尽量只修改position:absolute或fixed元素，对其他元素影响不大  \n5、动画开始GPU加速，translate使用3D变化  \n\ntransform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。\n当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧\n\n### CSS盒子模型(box-sizing)\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。  \nborder-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分  \ncontent-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充\n\n### CSS样式优先级\n!important>style>id>class\n\n### 什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\n#### 什么是BFC\nFormatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） \n\n具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把\nBFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n#### 触发BFC\n1.body根元素  \n2.浮动元素：float除none以外的值\n3.绝对定位元素：position(absolut,fixed)  \n4.display为inline-block、table-cells,flex  \n5.overflow除了visible以外的值(hidden,auto,scroll)  \n\n#### BFC的特性\n__1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中__  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n    </style>\n</head>\n<body>\n    <p></p>\n    <p></p>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg)\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n首先这不是 CSS 的 bug，我们可以理解为一种规范，__如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。__\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n        div {\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n</div>\n</body>\n</html>\n```\n![](https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg)\n\n__2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）__\n浮动的元素会脱离普通文档流  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n          overflow: hidden;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png)\n\n__3.BFC可以阻止元素被浮动的元素覆盖__  \n文字环绕效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png)\n\n这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发\n第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue;\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee;overflow: hidden\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg)\n\n### 清除浮动的几种方式\n1、clear:both  \n2、浮动元素后添加一个块级元素，添加属性clear:both  \n3、利用BFC原理  \n4、利用伪元素(before、after)\n\n### DOM、BOM对象\njavascript由ECMAScript、BOM、DOM组成。  \n\nBOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  \n\nDOM（Document Object Model）是指文档对象模型，通过他\n可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  \n\nECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。\n\n\n\n\n\n\n","source":"_posts/htmlAndCss.md","raw":"---\ntitle: htmlAndCss知识\ndate: 2022-01-10 14:37:16\ntags: \n- html\ncover: https://s4.ax1x.com/2022/01/13/7QjUmj.png\n---\n\n## htmlAndCss知识\n### 1、html5新特性、语义化\nhtml5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用  \n语义化标签: header、nav、main、article、section、aside、footer  \n语义化的优点有：  \n1.代码结构清晰，易于阅读，利与开发和维护  \n2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页  \n3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  \n\n### 2、浏览器渲染机制、重绘、重排\n#### 网页生产过程：  \n1.HTML被HTML解析器解析成DOM树  \n2.CSS则被CSS解析器解析成CSSOM树  \n3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）  \n4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成  \n5.将布局绘制（paint）在屏幕上\n\n#### 重排（回流）\n当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。  \n触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变---边距、填充、边框、宽度和高度\n\n#### 重绘\n当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。  \n触发：改变元素的color、background、box-shadow等属性\n\n#### 重排优化建议\n1.分离读写操作  \n2.样式集中修改  \n3.缓存需要修改的DOM元素  \n4.尽量只修改position:absolute或fixed元素，对其他元素影响不大  \n5、动画开始GPU加速，translate使用3D变化  \n\ntransform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。\n当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧\n\n### CSS盒子模型(box-sizing)\nCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。  \nborder-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分  \ncontent-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充\n\n### CSS样式优先级\n!important>style>id>class\n\n### 什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\n#### 什么是BFC\nFormatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） \n\n具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把\nBFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\n\n#### 触发BFC\n1.body根元素  \n2.浮动元素：float除none以外的值\n3.绝对定位元素：position(absolut,fixed)  \n4.display为inline-block、table-cells,flex  \n5.overflow除了visible以外的值(hidden,auto,scroll)  \n\n#### BFC的特性\n__1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中__  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n    </style>\n</head>\n<body>\n    <p></p>\n    <p></p>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg)\n从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。\n首先这不是 CSS 的 bug，我们可以理解为一种规范，__如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。__\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        p {\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        }\n        div {\n            overflow: hidden;\n        }\n    </style>\n</head>\n<body>\n<div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n    <div class=\"div\">\n        <p></p>\n    </div>\n</div>\n</body>\n</html>\n```\n![](https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg)\n\n__2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）__\n浮动的元素会脱离普通文档流  \n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg)\n\n由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n      .div1 {\n        border: 1px solid #000;\n          overflow: hidden;\n      }\n      .div2 {\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      }\n    </style>\n</head>\n<body>\n  <div class=\"div1\">\n    <div class=\"div2\"></div>\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png)\n\n__3.BFC可以阻止元素被浮动的元素覆盖__  \n文字环绕效果\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png)\n\n这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发\n第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n  <div style=\"height: 100px;width: 100px;float: left;background: lightblue;\">我是一个左浮动的元素</div>\n  <div style=\"width: 200px; height: 200px;background: #eee;overflow: hidden\">我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  </div>\n</body>\n</html>\n```\n![](https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg)\n\n### 清除浮动的几种方式\n1、clear:both  \n2、浮动元素后添加一个块级元素，添加属性clear:both  \n3、利用BFC原理  \n4、利用伪元素(before、after)\n\n### DOM、BOM对象\njavascript由ECMAScript、BOM、DOM组成。  \n\nBOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  \n\nDOM（Document Object Model）是指文档对象模型，通过他\n可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  \n\nECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。\n\n\n\n\n\n\n","slug":"htmlAndCss","published":1,"updated":"2022-01-17T01:43:33.126Z","_id":"cky8bbvpt00008wv4742mb6jl","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"htmlAndCss知识\"><a href=\"#htmlAndCss知识\" class=\"headerlink\" title=\"htmlAndCss知识\"></a>htmlAndCss知识</h2><h3 id=\"1、html5新特性、语义化\"><a href=\"#1、html5新特性、语义化\" class=\"headerlink\" title=\"1、html5新特性、语义化\"></a>1、html5新特性、语义化</h3><p>html5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用<br>语义化标签: header、nav、main、article、section、aside、footer<br>语义化的优点有：<br>1.代码结构清晰，易于阅读，利与开发和维护<br>2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页<br>3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  </p>\n<h3 id=\"2、浏览器渲染机制、重绘、重排\"><a href=\"#2、浏览器渲染机制、重绘、重排\" class=\"headerlink\" title=\"2、浏览器渲染机制、重绘、重排\"></a>2、浏览器渲染机制、重绘、重排</h3><h4 id=\"网页生产过程：\"><a href=\"#网页生产过程：\" class=\"headerlink\" title=\"网页生产过程：\"></a>网页生产过程：</h4><p>1.HTML被HTML解析器解析成DOM树<br>2.CSS则被CSS解析器解析成CSSOM树<br>3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）<br>4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成<br>5.将布局绘制（paint）在屏幕上</p>\n<h4 id=\"重排（回流）\"><a href=\"#重排（回流）\" class=\"headerlink\" title=\"重排（回流）\"></a>重排（回流）</h4><p>当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。<br>触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变—边距、填充、边框、宽度和高度</p>\n<h4 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h4><p>当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。<br>触发：改变元素的color、background、box-shadow等属性</p>\n<h4 id=\"重排优化建议\"><a href=\"#重排优化建议\" class=\"headerlink\" title=\"重排优化建议\"></a>重排优化建议</h4><p>1.分离读写操作<br>2.样式集中修改<br>3.缓存需要修改的DOM元素<br>4.尽量只修改position:absolute或fixed元素，对其他元素影响不大<br>5、动画开始GPU加速，translate使用3D变化  </p>\n<p>transform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。<br>当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧</p>\n<h3 id=\"CSS盒子模型-box-sizing\"><a href=\"#CSS盒子模型-box-sizing\" class=\"headerlink\" title=\"CSS盒子模型(box-sizing)\"></a>CSS盒子模型(box-sizing)</h3><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。<br>border-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分<br>content-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充</p>\n<h3 id=\"CSS样式优先级\"><a href=\"#CSS样式优先级\" class=\"headerlink\" title=\"CSS样式优先级\"></a>CSS样式优先级</h3><p>!important&gt;style&gt;id&gt;class</p>\n<h3 id=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"><a href=\"#什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\" class=\"headerlink\" title=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？</h3><h4 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h4><p>Formatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） </p>\n<p>具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把<br>BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h4 id=\"触发BFC\"><a href=\"#触发BFC\" class=\"headerlink\" title=\"触发BFC\"></a>触发BFC</h4><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position(absolut,fixed)<br>4.display为inline-block、table-cells,flex<br>5.overflow除了visible以外的值(hidden,auto,scroll)  </p>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><p><strong>1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中</strong>  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg\"><br>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n        div &#123;\n            overflow: hidden;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg\"></p>\n<p><strong>2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）</strong><br>浮动的元素会脱离普通文档流  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n          overflow: hidden;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png\"></p>\n<p><strong>3.BFC可以阻止元素被浮动的元素覆盖</strong><br>文字环绕效果</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png\"></p>\n<p>这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发<br>第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue;&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee;overflow: hidden&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg\"></p>\n<h3 id=\"清除浮动的几种方式\"><a href=\"#清除浮动的几种方式\" class=\"headerlink\" title=\"清除浮动的几种方式\"></a>清除浮动的几种方式</h3><p>1、clear:both<br>2、浮动元素后添加一个块级元素，添加属性clear:both<br>3、利用BFC原理<br>4、利用伪元素(before、after)</p>\n<h3 id=\"DOM、BOM对象\"><a href=\"#DOM、BOM对象\" class=\"headerlink\" title=\"DOM、BOM对象\"></a>DOM、BOM对象</h3><p>javascript由ECMAScript、BOM、DOM组成。  </p>\n<p>BOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  </p>\n<p>DOM（Document Object Model）是指文档对象模型，通过他<br>可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  </p>\n<p>ECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"htmlAndCss知识\"><a href=\"#htmlAndCss知识\" class=\"headerlink\" title=\"htmlAndCss知识\"></a>htmlAndCss知识</h2><h3 id=\"1、html5新特性、语义化\"><a href=\"#1、html5新特性、语义化\" class=\"headerlink\" title=\"1、html5新特性、语义化\"></a>1、html5新特性、语义化</h3><p>html5语义化指的是合理正确的使用语义化的标签来创建页面结构，如header、footer、nav,从标签上即可以直观的知道这个标签的作用<br>语义化标签: header、nav、main、article、section、aside、footer<br>语义化的优点有：<br>1.代码结构清晰，易于阅读，利与开发和维护<br>2.方便其他设备解析（如屏幕阅读器）根据语义渲染网页<br>3.有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重  </p>\n<h3 id=\"2、浏览器渲染机制、重绘、重排\"><a href=\"#2、浏览器渲染机制、重绘、重排\" class=\"headerlink\" title=\"2、浏览器渲染机制、重绘、重排\"></a>2、浏览器渲染机制、重绘、重排</h3><h4 id=\"网页生产过程：\"><a href=\"#网页生产过程：\" class=\"headerlink\" title=\"网页生产过程：\"></a>网页生产过程：</h4><p>1.HTML被HTML解析器解析成DOM树<br>2.CSS则被CSS解析器解析成CSSOM树<br>3.结合DOM树和CSSOM树，生成一颗渲染树（Render Tree）<br>4.生成布局（flow）,即将所有渲染树的所有节点进行平面合成<br>5.将布局绘制（paint）在屏幕上</p>\n<h4 id=\"重排（回流）\"><a href=\"#重排（回流）\" class=\"headerlink\" title=\"重排（回流）\"></a>重排（回流）</h4><p>当DOM的变化影响了元素的几何信息（DOM对象的位置和尺寸大小），浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。<br>触发：1.添加或者删除可见的DOM元素,2.元素尺寸改变—边距、填充、边框、宽度和高度</p>\n<h4 id=\"重绘\"><a href=\"#重绘\" class=\"headerlink\" title=\"重绘\"></a>重绘</h4><p>当DOM元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。<br>触发：改变元素的color、background、box-shadow等属性</p>\n<h4 id=\"重排优化建议\"><a href=\"#重排优化建议\" class=\"headerlink\" title=\"重排优化建议\"></a>重排优化建议</h4><p>1.分离读写操作<br>2.样式集中修改<br>3.缓存需要修改的DOM元素<br>4.尽量只修改position:absolute或fixed元素，对其他元素影响不大<br>5、动画开始GPU加速，translate使用3D变化  </p>\n<p>transform不重绘，不回流 是因为transform属于合成属性，对合成属性进行transition/animate动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。<br>当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧</p>\n<h3 id=\"CSS盒子模型-box-sizing\"><a href=\"#CSS盒子模型-box-sizing\" class=\"headerlink\" title=\"CSS盒子模型(box-sizing)\"></a>CSS盒子模型(box-sizing)</h3><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距（margin）、边框(border)、填充(padding)、内容(content)。<br>border-box:给元素设置宽高，此时宽高包括边框、填充、内容三部分<br>content-box: 给元素设置宽高，只设置了内容的宽高，不包括边框和填充</p>\n<h3 id=\"CSS样式优先级\"><a href=\"#CSS样式优先级\" class=\"headerlink\" title=\"CSS样式优先级\"></a>CSS样式优先级</h3><p>!important&gt;style&gt;id&gt;class</p>\n<h3 id=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"><a href=\"#什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\" class=\"headerlink\" title=\"什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？\"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？</h3><h4 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h4><p>Formatting Context 是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的Formatting context 有 Block Formatting Context(BFC)和Inline Formatting Context（IFC） </p>\n<p>具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性，通俗一点来讲，可以把<br>BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>\n<h4 id=\"触发BFC\"><a href=\"#触发BFC\" class=\"headerlink\" title=\"触发BFC\"></a>触发BFC</h4><p>1.body根元素<br>2.浮动元素：float除none以外的值<br>3.绝对定位元素：position(absolut,fixed)<br>4.display为inline-block、table-cells,flex<br>5.overflow除了visible以外的值(hidden,auto,scroll)  </p>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><p><strong>1.同一个BFC下两个元素上下外边距会发生折叠，为避免折叠可以将两个元素放置在两个BFC中</strong>  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;p&gt;&lt;/p&gt;\n    &lt;p&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-0a9ca8952c83141250a2d9002e6d2047_r.jpg\"><br>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 p 的下边距和第二个 p 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。<br>首先这不是 CSS 的 bug，我们可以理解为一种规范，<strong>如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。</strong></p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n        p &#123;\n            width: 100px;\n            height: 100px;\n            margin: 100px;\n            background: lightblue;\n        &#125;\n        div &#123;\n            overflow: hidden;\n        &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;div&quot;&gt;\n        &lt;p&gt;&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic2.zhimg.com/v2-5b8d6e8b2b507352900c1ece00018855_r.jpg\"></p>\n<p><strong>2.BFC可以包含浮动的元素（清除浮动,解决高度塌陷）</strong><br>浮动的元素会脱离普通文档流  </p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/v2-371eb702274af831df909b2c55d6a14b_r.jpg\"></p>\n<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度，如果触发容器的BFC，那么容器将会包裹着浮动元素。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n    &lt;style&gt;\n      .div1 &#123;\n        border: 1px solid #000;\n          overflow: hidden;\n      &#125;\n      .div2 &#123;\n        width: 100px;\n        height: 100px;\n        background: #EEEEEE;\n        float: left;\n      &#125;\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div class=&quot;div1&quot;&gt;\n    &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png\"></p>\n<p><strong>3.BFC可以阻止元素被浮动的元素覆盖</strong><br>文字环绕效果</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png\"></p>\n<p>这时候其实第二个元素有部分被浮动的元素所覆盖，（但是文本信息不会被浮动元素所覆盖）如果想避免这种情况，可触发<br>第二个元素的BFC特性，在第二个元素中加入__overflow:hidden__。</p>\n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue;&quot;&gt;我是一个左浮动的元素&lt;/div&gt;\n  &lt;div style=&quot;width: 200px; height: 200px;background: #eee;overflow: hidden&quot;&gt;我是一个没有设置浮动,\n      也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://pic3.zhimg.com/v2-5ebd48f09fac875f0bd25823c76ba7fa_r.jpg\"></p>\n<h3 id=\"清除浮动的几种方式\"><a href=\"#清除浮动的几种方式\" class=\"headerlink\" title=\"清除浮动的几种方式\"></a>清除浮动的几种方式</h3><p>1、clear:both<br>2、浮动元素后添加一个块级元素，添加属性clear:both<br>3、利用BFC原理<br>4、利用伪元素(before、after)</p>\n<h3 id=\"DOM、BOM对象\"><a href=\"#DOM、BOM对象\" class=\"headerlink\" title=\"DOM、BOM对象\"></a>DOM、BOM对象</h3><p>javascript由ECMAScript、BOM、DOM组成。  </p>\n<p>BOM（Browser Object Model）是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使用JavaScript有能力与浏览器“对话”。  </p>\n<p>DOM（Document Object Model）是指文档对象模型，通过他<br>可以访问HTML文档的所有元素。DOM是W3C的标准。DOM定义了访问HTML和XML文档的标准。  </p>\n<p>ECMAScript是一个标准，JS只是它的一个实现，其他实现包括ActionScript。</p>\n"},{"title":"basicJs","date":"2022-01-11T02:43:11.000Z","cover":"https://s4.ax1x.com/2022/01/13/7QjJ1S.png","_content":"\n## js基础知识\n\n### 一、js数据类型\n\n基本数值类型：String、Number、Boolean、Null、Undefined、Symbol  \n引用数据类型：Object、Array、Function  \n\nnull和undefined的区别：null表示空对象，undefined表示已在作用域中声明但未赋值的变量  \n\ntypeof主要用来判断数据类型 返回值有string、boolean、number、function、object、undefined  \n\ninstanceof 判断该对象是谁的实例\n\n弱类型：在定义变量时，我们可以为变量赋值任何数据，变量的数据类型不是固定死的，这样的类型叫做弱类型  \n强类型：在声明变量的时候，一旦给变量赋值，那么变量的数据类型就已经确定，之后如果要给该变量赋值其他类型的数据，需要进行强制类型装换  \n\n动态类型：动态类型的类型检查会在 __代码运行的时候进行__  \n静态类型：静态类型的类型检查会在 __编译时进行__\n\n### 二、作用域和作用域链\n在js中，作用域分为全局作用域和局部作用域，全局作用域在程序的任何地方都能访问，局部作用域一般指函数内部的作用域。  \n作用域链：函数内部找不到值，就会往上级作用域去找，一直找到全局作用域，这样一个查找过程形成的链条称为作用域链。\n\n### 三、变量提升\n在js编译阶段，会把变量和函数的声明提升至当前作用域的顶端  \n注意点：  \n1、提升的部分只是变量的声明，赋值语句和可执行代码逻辑还是保持原地不动  \n2、提升只是将变量声明和函数声明提升到变量所在的作用域顶端，并不会提示到全局作用域\n3、ES6 的let和const声明不存在变量提升\n4、函数是一级公民，优先提升\n\n### 四、闭包\n闭包是指有权访问另一个函数作用域中的变量的函数\n```javascript\nfunction a() {\n    var num = 0;\n    function b() {\n        num++;\n        console.log(num);\n    }\n    return b;\n}\n\nvar a1 = a();\na1();\na1();\n\n// 打印结果为1,2\n```\n正常来说，a方法执行完毕后，a方法的作用域会被垃圾回收机制销毁，但由于此时全局作用域中a1指向了b方法，全局作用域变量不会被回收，故垃圾回收机制认为b还在使用，不会销毁，同时b方法引用了\na方法作用域中的num变量，故num也不会销毁，此时就形成了闭包，每次请求，都在原有的num上++,故打印为1,2  \n\n闭包的优点：  \n1、可以读取函数内部的变量  \n2、避免全局污染  \n\n闭包的缺点：  \n1、闭包会导致变量不会被垃圾回收机制所清除，会大量消耗内存  \n2、不恰当的使用闭包可能会造成内存泄漏的问题  \n\n### 五、原型和原型链\n函数的原型：创建（声明）一个函数A，那么浏览器会在内存中创建一个对象B,函数A会有一个默认的属性prototype指向对象B，这个对象B就是函数A的原型对象。这个原型对象B有个默认属性constructor指向函数A\n![](http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/43031030.jpg)\n\n将函数A作为构造函数使用new创建对象C，对象C就会存在一个属性__proto__([[Prototype]])指向原型对象B\n![](http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/6663492.jpg)\n\n__Person函数举例__  \n```javascript\nfunction Person()\n{\n\n}\n\nvar person = new Person();\nperson.name = 'Tian';\nconsole.log(person.name);    //Tian\n```\nPerson有个属性prototype指向原型对象(这里称为对象A，Person.prototype)，原型对象有个属性constructor指向Person,实例person有个属性__proto__指向原型对象\n![](https://s4.ax1x.com/2022/01/11/7mAFOg.png)\n原型对象也是对象，构造函数为Object,构造函数Object的prototype指向原型对象B(Object.prototype)，原型对象B的constructor属性指向构造函数Object,原型对象A的__proto__指向原型对象B(Object.prototype)\n![](https://s4.ax1x.com/2022/01/11/7mEP41.png)\n\n原型链：实例的属性会先从实例的构造函数找，当前实例没有就会往构造函数的原型上找，直到找到构造函数Object的原型对象为止，Object.prototype.__proto__指向null,这样一个找寻过程形成的链路叫做原型链\n![](https://s4.ax1x.com/2022/01/11/7mEjPI.png)\n\n### 六、this指向\nthis永远指向最后调用它的对象  \n例1\n```javascript\nvar name = '小王', age = 17;\nvar obj = {\n    name: '小张',\n    objAge: this.age,\n    myFun: function () {\n        console.log(this.name + \"年龄\" + this.age);\n    }\n}\nconsole.log(obj.objAge) // 17\nobj.myFun() // 小张年龄undefined\nlet f = obj.myFun;\nf();  // 小王年龄17\n```\n例2\n```javascript\nvar fav = '盲僧';\nfunction shows() {\n    console.log(this.fav);\n}\nshows()// 盲僧\n```\nthis永远指向最后调用它的方法的对象，示例1  obj.myFun()this指向obj,将obj.myFun赋值给f,f调用，此时f()等同于window.fn(),故this指向window对象，示例2同理  \n\n函数对象的call()、apply()、bind()能改变this指向  \n\n__call、apply、bind方法详解__  \n例1  \n```javascript\nvar name = '小王', age = 17;\n    var obj = {\n        name: '小张',\n        objAge: this.age,\n        myFun: function () {\n            console.log(this.name + \"年龄\" + this.age);\n        }\n    }\n    var db = {\n        name: '德玛',\n        age: 99\n    }\n\n    obj.myFun.call(db) // 德玛年龄99\n    obj.myFun.apply(db) // 德玛年龄99\n    obj.myFun.bind(db)() // 德玛年龄99\n```\ncall、apply、bind都能改变this指向，bind方法返回是一个方法，需要再次调用  \n\n例2\n```javascript\nvar name = '小王', age = 17;\n    var obj = {\n        name: '小张',\n        objAge: this.age,\n        myFun: function (fm, to) {\n            console.log(this.name + \"年龄\" + this.age, \"来自\" + fm + \"去往\" + to);\n        }\n    }\n    var db = {\n        name: '德玛',\n        age: 99\n    }\n\n    obj.myFun.call(db, '上海', '成都') // 德玛年龄99 来自上海去往成都\n    obj.myFun.apply(db, ['上海', '成都']) // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, '上海', '成都')() // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, ['上海', '成都'])() // 德玛年龄99 来自上海,成都去往undefined\n```\ncall、apply、bind第一个参数都是this指向的对象，第二个参数，call是直接放入，apply是放入数组，bind和call参数形式一样，除了需要再次调用  \n\n### 七、new关键字\n是用new一个构造函数创建对象实例的过程  \n```javascript\nfunction Pro(){\n    this.x = '1';\n    this.y = function(){};\n}\nvar p = new Pro();\n```\n1、创建一个空对象  \n2、将空对象的__proto__指向构造函数的原型对象（Pro.prototype）  \n3、将构造函数中的this指向此对象(new关键字会自动调用函数的apply方法，将this指向这个空对象吗)\n4、执行构造函数代码为对象赋值  \n5、返回本对象(判断构造函数的返回值，如果是值类型，则返回创建的对象，如果是引用类型则返回引用类型对象本身)  \n![](https://pic2.zhimg.com/v2-7ce5f71bd0865872b513a88fabb597fd_r.jpg)\n\n__补充知识点__  \n1、在严格模式中默认的this不再是window，而是undefined\n\n### 八、继承\n父类准备\n```javascript\n// 定义一个动物类\nfunction Animal(name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function () {\n    console.log(this.name + '正在睡觉');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function (food) {\n  console.log(this.name + \"正在吃\" + food);\n}\n```\n__1、原型链继承__  \n核心：将父类的实例作为子类的原型\n```javascript\nfunction Cat(name) {\n      this.name = name;\n}\n\nCat.prototype = new Animal();\nCat.prototype.age = 1;\n\nvar cat = new Cat('ximi');\nconsole.log(cat.name, cat.age); // ximi 1\ncat.eat('fish'); // ximi正在吃fish\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例  \n2、父类新增原型方法/原型属性，子类都能访问到  \n3、简单，易于实现  \n缺点：  \n1、要新增子类原型属性和方法，必须放在new Animal()这样的语句之后执行  \n2、无法实现多继承  \n3、来自原型对象的所有属性被所有实例共享  \n4、创建子类实例时，无法向父类构造函数传参  \n\n__2、构造继承__  \n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）  \n```javascript\nfunction Cat(name) {\n    Animal.call(this, 'ximi');\n    this.name = name || 'putao';\n}\n\nvar cat = new Cat()\nconsole.log(cat.name) // putao\ncat.eat('fish'); // 报错\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat) // true\nconsole.log(cat instanceof Animal) // false\n```\n特点：  \n1、只继承了父类构造函数的属性和方法，没有继承父类原型的属性和方法  \n2、可以继承多个构造函数属性和方法（call多个）  \n3、创建子类实例时可以向父类传参\n缺点：  \n1、实例并不是父类的实例，只是子类的实例  \n2、只能继承父类的属性和方法，不能继承父类原型的属性和方法  \n3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能  \n\n__3、实例继承__  \n核心：为父类实例添加新特性，作为子类实例返回  \n```javascript\nfunction Cat(name) {\n    var instance = new Animal('ximi');\n    instance.name = name || 'putaa';\n    return instance\n}\n\nvar cat = new Cat('ppt');\nconsole.log(cat.name); // ppt\ncat.eat('鱼'); //ppt正在吃鱼\ncat.sleep(); //ppt正在睡觉\nconsole.log(cat instanceof Cat); //false\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、不限制调用方式，不管是new 子类()还是子类()，返回的对象具有相同的效果  \n缺点：  \n1、实例是父类的实例，不是子类的实例  \n2、不支持多继承  \n\n__4、拷贝继承__  \n```javascript\nfunction Cat(name) {\n    var instance = new Animal(name);\n\n    for (let key in instance) {\n        this[key] = instance[key];\n    }\n}\n\nvar cat = new Cat('bbt');\nconsole.log(cat.name); //bbt\ncat.eat('肉'); // bbt正在吃肉\ncat.sleep(); // bbt正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // false\n```\n特点：  \n1、支持多继承  \n缺点：  \n1、效率低，内存占用高，因为要拷贝父类的属性  \n2、无法获取父类不可枚举的方法  \n\n__5、组合继承__  \n核心：通过调用父类构造函数，继承父类属性并保留传参的特点，然后将通过将父类的实例作为子类的原型，实现函数复用\n```javascript\nfunction Cat(name) {\n    Animal.call(this, name);\n}\nCat.prototype = new Animal();\nvar cat = new Cat('ttp');\nconsole.log(cat.name); // ttp\ncat.eat('白菜'); // ttp正在吃白菜\ncat.sleep(); // ttp正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、弥补了方式2的缺陷，可以继承实例的属性和方法，也能继承原型的属性和方法  \n2、既是子类的实例，也是父类的实例  \n3、不存在引用属性共享的问题  \n4、可传参  \n5、函数可复用  \n缺点：  \n1、调用两次父类的构造函数，生成两份实例（子类实例将子类原型上的那份屏蔽了）  \n\n__6、寄生组合继承__  \n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次方法和属性，避免组合继承的缺陷  \n```javascript\nfunction Cat(name) {\n    Animal.call(this,name);\n}\n\nvar Super = function () {}\n\nSuper.prototype = Animal.prototype\n\nCat.prototype = new Super();\n\nCat.prototype.constructor = Cat;\n\nvar cat = new Cat('pig');\n\nconsole.log(cat.name); // pig\ncat.eat('白菜'); // pig正在吃白菜\ncat.sleep(); // pig正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、解决了两次调用父类的构造函数  \n缺点：  \n1、实现较为复杂\n\n### 九、EventLoop (事件循环)\nJS是单线程的，为了防止一个函数的执行事件过长阻塞后面的代码，所以会先把同步代码压入执行栈中，依次执行，将异步代码推入异步队列，当执行栈中没有执行任务时，EventLoop开始工作，将异步队列中的任务依次压入执行栈中执行，直到所有异步队列执行完毕。\n![](https://s4.ax1x.com/2022/01/13/7QcOG6.png)\n![](https://s4.ax1x.com/2022/01/13/7Qgliq.png)\n注意：  \n1、js是单线程的，但是浏览器是多线程的，执行异步任务是异步线程执行  \n2、异步任务也分为宏任务和微任务，微任务优先宏任务执行，微任务队列的代表：Promise.then,MutationObserver。宏任务的代表：setTimeout,setInterval,setImmediate  \n\n### 十、事件冒泡、捕获、委托\nDOM事件流：事件捕获、处于目标阶段、事件冒泡  \n事件委托：就是利用事件冒泡机制，将事件绑定在目标DOM的父级上，触发执行效果  \n事件委托的优势：1、减少DOM操作，提高性能。2、随时可以添加子元素，添加的子元素会自动有相应的处理事件  \n\n### 十一、原生AJAX\n```javascript\nvar Ajax = {\n    get: function (url, callback) {\n        // XMLHttpRequest对象用于在后台与服务器交换数据\n        var xhr = new XMLHttpRequest();\n        //参数说明：方法名GET/POST   请求地址   async 请求进行异步还是同步，true服务器响应时执行其他脚本，false是等待服务器响应再执行\n        xhr.open('GET', url, false);\n        xhr.onreadystatechange = function () {\n            // readyState == 4说明请求已完成\n            if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) {\n                // 从服务器获得数据\n                callback(xhr.responseText)\n            }\n        }\n        xhr.send();\n    },\n    post: function (url, data, callback) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST',url, false);\n        xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                if (xhr.status == 200 || xhr.status == 304) {\n                    callback(xhr.responseText);\n                }\n            }\n        }\n        xhr.send(data);\n    }\n}\n```\n\n### 十二、js深拷贝和浅拷贝\n如何区分浅拷贝和深拷贝，简单来说，假设B复制A，当修改A的引用数据时，看B是否发生改变，如果B跟着变了，就是浅拷贝，如果没变就是深拷贝  \n浅拷贝的方式：  \n1、直接=赋值  \n2、for in  \n3、Object.assign()  \n\n深拷贝的方式：  \n1、采用递归去拷贝所有层级的属性\n```javascript\nfunction deepClone(obj) {\n    let objClone = Array.isArray(obj) ? []: {}\n    if (typeof obj === 'object') {\n        Object.keys(obj).forEach(key => {\n            if (obj[key] && typeof obj[key] === 'object') {\n                objClone[key] = deepClone(obj[key])\n            } else {\n                objClone[key] = obj[key]\n            }\n        })\n    } else {\n        objClone = obj\n    }\n    return objClone;\n}\n\nlet a = {\n    name: 'zs',\n    age: 18,\n    son: {\n        name: 'ls',\n        age: 1\n    }\n}\nlet b = deepClone(a) //深拷贝\nlet c = Object.assign({}, a); //浅拷贝\nlet d = a; //浅拷贝\nlet e = {};\nfor (let key in a) { //浅拷贝\n    e[key] = a[key]\n}\na.son.name = 'zs';\nconsole.log(a); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\nconsole.log(b); // { name: 'zs', age: 18, son: { name: 'ls', age: 1 } }\nconsole.log(c); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\nconsole.log(d); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\nconsole.log(e); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\n```\n\n2、才用JSON的方法\n```javascript\nlet a = {\n    name: 'zs',\n    age: 18,\n    son: {\n        name: 'ls',\n        age: 1\n    }\n}\nlet b = JSON.parse(JSON.stringify(a));\na.son.name = 'ww';\nconsole.log(a); // { name: 'zs', age: 18, son: { name: 'ww', age: 1 } }\nconsole.log(b); // { name: 'zs', age: 18, son: { name: 'ls', age: 1 } }\n\n//缺点：无法复制方法属性\n\nlet a1 = {\n    name: 'zs',\n    age: 18,\n    son: {\n        name: 'ls',\n        age: 1\n    },\n    say() {\n        console.log('hello')\n    }\n}\nlet b1 = JSON.parse(JSON.stringify(a1));\na1.son.name = 'ww';\nconsole.log(a1); // { name: 'zs',age: 18,son: { name: 'ww', age: 1 },say: [Function: say] }\nconsole.log(b1); // { name: 'zs', age: 18, son: { name: 'ls', age: 1 } }\n```\n\n3、利用jQuery的extend方法\n```javascript\nlet arr = [1,2,3,4]\nlet newArr = $.extend(true, [], arr) // true为深拷贝，false为浅拷贝\n```\n\n4、loadsh函数库实现\n```javascript\nlet obj = {\n    name: 'z1',\n    son: {\n        name: 'zs'\n    }\n}\nlet result = _.cloneDeep(obj);\n```\n\n","source":"_posts/basicJs.md","raw":"---\ntitle: basicJs\ndate: 2022-01-11 10:43:11\ntags: \n- js\ncover: https://s4.ax1x.com/2022/01/13/7QjJ1S.png\n---\n\n## js基础知识\n\n### 一、js数据类型\n\n基本数值类型：String、Number、Boolean、Null、Undefined、Symbol  \n引用数据类型：Object、Array、Function  \n\nnull和undefined的区别：null表示空对象，undefined表示已在作用域中声明但未赋值的变量  \n\ntypeof主要用来判断数据类型 返回值有string、boolean、number、function、object、undefined  \n\ninstanceof 判断该对象是谁的实例\n\n弱类型：在定义变量时，我们可以为变量赋值任何数据，变量的数据类型不是固定死的，这样的类型叫做弱类型  \n强类型：在声明变量的时候，一旦给变量赋值，那么变量的数据类型就已经确定，之后如果要给该变量赋值其他类型的数据，需要进行强制类型装换  \n\n动态类型：动态类型的类型检查会在 __代码运行的时候进行__  \n静态类型：静态类型的类型检查会在 __编译时进行__\n\n### 二、作用域和作用域链\n在js中，作用域分为全局作用域和局部作用域，全局作用域在程序的任何地方都能访问，局部作用域一般指函数内部的作用域。  \n作用域链：函数内部找不到值，就会往上级作用域去找，一直找到全局作用域，这样一个查找过程形成的链条称为作用域链。\n\n### 三、变量提升\n在js编译阶段，会把变量和函数的声明提升至当前作用域的顶端  \n注意点：  \n1、提升的部分只是变量的声明，赋值语句和可执行代码逻辑还是保持原地不动  \n2、提升只是将变量声明和函数声明提升到变量所在的作用域顶端，并不会提示到全局作用域\n3、ES6 的let和const声明不存在变量提升\n4、函数是一级公民，优先提升\n\n### 四、闭包\n闭包是指有权访问另一个函数作用域中的变量的函数\n```javascript\nfunction a() {\n    var num = 0;\n    function b() {\n        num++;\n        console.log(num);\n    }\n    return b;\n}\n\nvar a1 = a();\na1();\na1();\n\n// 打印结果为1,2\n```\n正常来说，a方法执行完毕后，a方法的作用域会被垃圾回收机制销毁，但由于此时全局作用域中a1指向了b方法，全局作用域变量不会被回收，故垃圾回收机制认为b还在使用，不会销毁，同时b方法引用了\na方法作用域中的num变量，故num也不会销毁，此时就形成了闭包，每次请求，都在原有的num上++,故打印为1,2  \n\n闭包的优点：  \n1、可以读取函数内部的变量  \n2、避免全局污染  \n\n闭包的缺点：  \n1、闭包会导致变量不会被垃圾回收机制所清除，会大量消耗内存  \n2、不恰当的使用闭包可能会造成内存泄漏的问题  \n\n### 五、原型和原型链\n函数的原型：创建（声明）一个函数A，那么浏览器会在内存中创建一个对象B,函数A会有一个默认的属性prototype指向对象B，这个对象B就是函数A的原型对象。这个原型对象B有个默认属性constructor指向函数A\n![](http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/43031030.jpg)\n\n将函数A作为构造函数使用new创建对象C，对象C就会存在一个属性__proto__([[Prototype]])指向原型对象B\n![](http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/6663492.jpg)\n\n__Person函数举例__  \n```javascript\nfunction Person()\n{\n\n}\n\nvar person = new Person();\nperson.name = 'Tian';\nconsole.log(person.name);    //Tian\n```\nPerson有个属性prototype指向原型对象(这里称为对象A，Person.prototype)，原型对象有个属性constructor指向Person,实例person有个属性__proto__指向原型对象\n![](https://s4.ax1x.com/2022/01/11/7mAFOg.png)\n原型对象也是对象，构造函数为Object,构造函数Object的prototype指向原型对象B(Object.prototype)，原型对象B的constructor属性指向构造函数Object,原型对象A的__proto__指向原型对象B(Object.prototype)\n![](https://s4.ax1x.com/2022/01/11/7mEP41.png)\n\n原型链：实例的属性会先从实例的构造函数找，当前实例没有就会往构造函数的原型上找，直到找到构造函数Object的原型对象为止，Object.prototype.__proto__指向null,这样一个找寻过程形成的链路叫做原型链\n![](https://s4.ax1x.com/2022/01/11/7mEjPI.png)\n\n### 六、this指向\nthis永远指向最后调用它的对象  \n例1\n```javascript\nvar name = '小王', age = 17;\nvar obj = {\n    name: '小张',\n    objAge: this.age,\n    myFun: function () {\n        console.log(this.name + \"年龄\" + this.age);\n    }\n}\nconsole.log(obj.objAge) // 17\nobj.myFun() // 小张年龄undefined\nlet f = obj.myFun;\nf();  // 小王年龄17\n```\n例2\n```javascript\nvar fav = '盲僧';\nfunction shows() {\n    console.log(this.fav);\n}\nshows()// 盲僧\n```\nthis永远指向最后调用它的方法的对象，示例1  obj.myFun()this指向obj,将obj.myFun赋值给f,f调用，此时f()等同于window.fn(),故this指向window对象，示例2同理  \n\n函数对象的call()、apply()、bind()能改变this指向  \n\n__call、apply、bind方法详解__  \n例1  \n```javascript\nvar name = '小王', age = 17;\n    var obj = {\n        name: '小张',\n        objAge: this.age,\n        myFun: function () {\n            console.log(this.name + \"年龄\" + this.age);\n        }\n    }\n    var db = {\n        name: '德玛',\n        age: 99\n    }\n\n    obj.myFun.call(db) // 德玛年龄99\n    obj.myFun.apply(db) // 德玛年龄99\n    obj.myFun.bind(db)() // 德玛年龄99\n```\ncall、apply、bind都能改变this指向，bind方法返回是一个方法，需要再次调用  \n\n例2\n```javascript\nvar name = '小王', age = 17;\n    var obj = {\n        name: '小张',\n        objAge: this.age,\n        myFun: function (fm, to) {\n            console.log(this.name + \"年龄\" + this.age, \"来自\" + fm + \"去往\" + to);\n        }\n    }\n    var db = {\n        name: '德玛',\n        age: 99\n    }\n\n    obj.myFun.call(db, '上海', '成都') // 德玛年龄99 来自上海去往成都\n    obj.myFun.apply(db, ['上海', '成都']) // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, '上海', '成都')() // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, ['上海', '成都'])() // 德玛年龄99 来自上海,成都去往undefined\n```\ncall、apply、bind第一个参数都是this指向的对象，第二个参数，call是直接放入，apply是放入数组，bind和call参数形式一样，除了需要再次调用  \n\n### 七、new关键字\n是用new一个构造函数创建对象实例的过程  \n```javascript\nfunction Pro(){\n    this.x = '1';\n    this.y = function(){};\n}\nvar p = new Pro();\n```\n1、创建一个空对象  \n2、将空对象的__proto__指向构造函数的原型对象（Pro.prototype）  \n3、将构造函数中的this指向此对象(new关键字会自动调用函数的apply方法，将this指向这个空对象吗)\n4、执行构造函数代码为对象赋值  \n5、返回本对象(判断构造函数的返回值，如果是值类型，则返回创建的对象，如果是引用类型则返回引用类型对象本身)  \n![](https://pic2.zhimg.com/v2-7ce5f71bd0865872b513a88fabb597fd_r.jpg)\n\n__补充知识点__  \n1、在严格模式中默认的this不再是window，而是undefined\n\n### 八、继承\n父类准备\n```javascript\n// 定义一个动物类\nfunction Animal(name) {\n  // 属性\n  this.name = name || 'Animal';\n  // 实例方法\n  this.sleep = function () {\n    console.log(this.name + '正在睡觉');\n  }\n}\n// 原型方法\nAnimal.prototype.eat = function (food) {\n  console.log(this.name + \"正在吃\" + food);\n}\n```\n__1、原型链继承__  \n核心：将父类的实例作为子类的原型\n```javascript\nfunction Cat(name) {\n      this.name = name;\n}\n\nCat.prototype = new Animal();\nCat.prototype.age = 1;\n\nvar cat = new Cat('ximi');\nconsole.log(cat.name, cat.age); // ximi 1\ncat.eat('fish'); // ximi正在吃fish\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例  \n2、父类新增原型方法/原型属性，子类都能访问到  \n3、简单，易于实现  \n缺点：  \n1、要新增子类原型属性和方法，必须放在new Animal()这样的语句之后执行  \n2、无法实现多继承  \n3、来自原型对象的所有属性被所有实例共享  \n4、创建子类实例时，无法向父类构造函数传参  \n\n__2、构造继承__  \n核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）  \n```javascript\nfunction Cat(name) {\n    Animal.call(this, 'ximi');\n    this.name = name || 'putao';\n}\n\nvar cat = new Cat()\nconsole.log(cat.name) // putao\ncat.eat('fish'); // 报错\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat) // true\nconsole.log(cat instanceof Animal) // false\n```\n特点：  \n1、只继承了父类构造函数的属性和方法，没有继承父类原型的属性和方法  \n2、可以继承多个构造函数属性和方法（call多个）  \n3、创建子类实例时可以向父类传参\n缺点：  \n1、实例并不是父类的实例，只是子类的实例  \n2、只能继承父类的属性和方法，不能继承父类原型的属性和方法  \n3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能  \n\n__3、实例继承__  \n核心：为父类实例添加新特性，作为子类实例返回  \n```javascript\nfunction Cat(name) {\n    var instance = new Animal('ximi');\n    instance.name = name || 'putaa';\n    return instance\n}\n\nvar cat = new Cat('ppt');\nconsole.log(cat.name); // ppt\ncat.eat('鱼'); //ppt正在吃鱼\ncat.sleep(); //ppt正在睡觉\nconsole.log(cat instanceof Cat); //false\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、不限制调用方式，不管是new 子类()还是子类()，返回的对象具有相同的效果  \n缺点：  \n1、实例是父类的实例，不是子类的实例  \n2、不支持多继承  \n\n__4、拷贝继承__  \n```javascript\nfunction Cat(name) {\n    var instance = new Animal(name);\n\n    for (let key in instance) {\n        this[key] = instance[key];\n    }\n}\n\nvar cat = new Cat('bbt');\nconsole.log(cat.name); //bbt\ncat.eat('肉'); // bbt正在吃肉\ncat.sleep(); // bbt正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // false\n```\n特点：  \n1、支持多继承  \n缺点：  \n1、效率低，内存占用高，因为要拷贝父类的属性  \n2、无法获取父类不可枚举的方法  \n\n__5、组合继承__  \n核心：通过调用父类构造函数，继承父类属性并保留传参的特点，然后将通过将父类的实例作为子类的原型，实现函数复用\n```javascript\nfunction Cat(name) {\n    Animal.call(this, name);\n}\nCat.prototype = new Animal();\nvar cat = new Cat('ttp');\nconsole.log(cat.name); // ttp\ncat.eat('白菜'); // ttp正在吃白菜\ncat.sleep(); // ttp正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、弥补了方式2的缺陷，可以继承实例的属性和方法，也能继承原型的属性和方法  \n2、既是子类的实例，也是父类的实例  \n3、不存在引用属性共享的问题  \n4、可传参  \n5、函数可复用  \n缺点：  \n1、调用两次父类的构造函数，生成两份实例（子类实例将子类原型上的那份屏蔽了）  \n\n__6、寄生组合继承__  \n核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次方法和属性，避免组合继承的缺陷  \n```javascript\nfunction Cat(name) {\n    Animal.call(this,name);\n}\n\nvar Super = function () {}\n\nSuper.prototype = Animal.prototype\n\nCat.prototype = new Super();\n\nCat.prototype.constructor = Cat;\n\nvar cat = new Cat('pig');\n\nconsole.log(cat.name); // pig\ncat.eat('白菜'); // pig正在吃白菜\ncat.sleep(); // pig正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n```\n特点：  \n1、解决了两次调用父类的构造函数  \n缺点：  \n1、实现较为复杂\n\n### 九、EventLoop (事件循环)\nJS是单线程的，为了防止一个函数的执行事件过长阻塞后面的代码，所以会先把同步代码压入执行栈中，依次执行，将异步代码推入异步队列，当执行栈中没有执行任务时，EventLoop开始工作，将异步队列中的任务依次压入执行栈中执行，直到所有异步队列执行完毕。\n![](https://s4.ax1x.com/2022/01/13/7QcOG6.png)\n![](https://s4.ax1x.com/2022/01/13/7Qgliq.png)\n注意：  \n1、js是单线程的，但是浏览器是多线程的，执行异步任务是异步线程执行  \n2、异步任务也分为宏任务和微任务，微任务优先宏任务执行，微任务队列的代表：Promise.then,MutationObserver。宏任务的代表：setTimeout,setInterval,setImmediate  \n\n### 十、事件冒泡、捕获、委托\nDOM事件流：事件捕获、处于目标阶段、事件冒泡  \n事件委托：就是利用事件冒泡机制，将事件绑定在目标DOM的父级上，触发执行效果  \n事件委托的优势：1、减少DOM操作，提高性能。2、随时可以添加子元素，添加的子元素会自动有相应的处理事件  \n\n### 十一、原生AJAX\n```javascript\nvar Ajax = {\n    get: function (url, callback) {\n        // XMLHttpRequest对象用于在后台与服务器交换数据\n        var xhr = new XMLHttpRequest();\n        //参数说明：方法名GET/POST   请求地址   async 请求进行异步还是同步，true服务器响应时执行其他脚本，false是等待服务器响应再执行\n        xhr.open('GET', url, false);\n        xhr.onreadystatechange = function () {\n            // readyState == 4说明请求已完成\n            if (xhr.readyState == 4 && xhr.status == 200 || xhr.status == 304) {\n                // 从服务器获得数据\n                callback(xhr.responseText)\n            }\n        }\n        xhr.send();\n    },\n    post: function (url, data, callback) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST',url, false);\n        xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded');\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n                if (xhr.status == 200 || xhr.status == 304) {\n                    callback(xhr.responseText);\n                }\n            }\n        }\n        xhr.send(data);\n    }\n}\n```\n\n### 十二、js深拷贝和浅拷贝\n如何区分浅拷贝和深拷贝，简单来说，假设B复制A，当修改A的引用数据时，看B是否发生改变，如果B跟着变了，就是浅拷贝，如果没变就是深拷贝  \n浅拷贝的方式：  \n1、直接=赋值  \n2、for in  \n3、Object.assign()  \n\n深拷贝的方式：  \n1、采用递归去拷贝所有层级的属性\n```javascript\nfunction deepClone(obj) {\n    let objClone = Array.isArray(obj) ? []: {}\n    if (typeof obj === 'object') {\n        Object.keys(obj).forEach(key => {\n            if (obj[key] && typeof obj[key] === 'object') {\n                objClone[key] = deepClone(obj[key])\n            } else {\n                objClone[key] = obj[key]\n            }\n        })\n    } else {\n        objClone = obj\n    }\n    return objClone;\n}\n\nlet a = {\n    name: 'zs',\n    age: 18,\n    son: {\n        name: 'ls',\n        age: 1\n    }\n}\nlet b = deepClone(a) //深拷贝\nlet c = Object.assign({}, a); //浅拷贝\nlet d = a; //浅拷贝\nlet e = {};\nfor (let key in a) { //浅拷贝\n    e[key] = a[key]\n}\na.son.name = 'zs';\nconsole.log(a); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\nconsole.log(b); // { name: 'zs', age: 18, son: { name: 'ls', age: 1 } }\nconsole.log(c); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\nconsole.log(d); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\nconsole.log(e); // { name: 'zs', age: 18, son: { name: 'zs', age: 1 } }\n```\n\n2、才用JSON的方法\n```javascript\nlet a = {\n    name: 'zs',\n    age: 18,\n    son: {\n        name: 'ls',\n        age: 1\n    }\n}\nlet b = JSON.parse(JSON.stringify(a));\na.son.name = 'ww';\nconsole.log(a); // { name: 'zs', age: 18, son: { name: 'ww', age: 1 } }\nconsole.log(b); // { name: 'zs', age: 18, son: { name: 'ls', age: 1 } }\n\n//缺点：无法复制方法属性\n\nlet a1 = {\n    name: 'zs',\n    age: 18,\n    son: {\n        name: 'ls',\n        age: 1\n    },\n    say() {\n        console.log('hello')\n    }\n}\nlet b1 = JSON.parse(JSON.stringify(a1));\na1.son.name = 'ww';\nconsole.log(a1); // { name: 'zs',age: 18,son: { name: 'ww', age: 1 },say: [Function: say] }\nconsole.log(b1); // { name: 'zs', age: 18, son: { name: 'ls', age: 1 } }\n```\n\n3、利用jQuery的extend方法\n```javascript\nlet arr = [1,2,3,4]\nlet newArr = $.extend(true, [], arr) // true为深拷贝，false为浅拷贝\n```\n\n4、loadsh函数库实现\n```javascript\nlet obj = {\n    name: 'z1',\n    son: {\n        name: 'zs'\n    }\n}\nlet result = _.cloneDeep(obj);\n```\n\n","slug":"basicJs","published":1,"updated":"2022-01-17T09:42:53.085Z","_id":"cky9ii5eu0000bcv4cqh3ckht","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"js基础知识\"><a href=\"#js基础知识\" class=\"headerlink\" title=\"js基础知识\"></a>js基础知识</h2><h3 id=\"一、js数据类型\"><a href=\"#一、js数据类型\" class=\"headerlink\" title=\"一、js数据类型\"></a>一、js数据类型</h3><p>基本数值类型：String、Number、Boolean、Null、Undefined、Symbol<br>引用数据类型：Object、Array、Function  </p>\n<p>null和undefined的区别：null表示空对象，undefined表示已在作用域中声明但未赋值的变量  </p>\n<p>typeof主要用来判断数据类型 返回值有string、boolean、number、function、object、undefined  </p>\n<p>instanceof 判断该对象是谁的实例</p>\n<p>弱类型：在定义变量时，我们可以为变量赋值任何数据，变量的数据类型不是固定死的，这样的类型叫做弱类型<br>强类型：在声明变量的时候，一旦给变量赋值，那么变量的数据类型就已经确定，之后如果要给该变量赋值其他类型的数据，需要进行强制类型装换  </p>\n<p>动态类型：动态类型的类型检查会在 <strong>代码运行的时候进行</strong><br>静态类型：静态类型的类型检查会在 <strong>编译时进行</strong></p>\n<h3 id=\"二、作用域和作用域链\"><a href=\"#二、作用域和作用域链\" class=\"headerlink\" title=\"二、作用域和作用域链\"></a>二、作用域和作用域链</h3><p>在js中，作用域分为全局作用域和局部作用域，全局作用域在程序的任何地方都能访问，局部作用域一般指函数内部的作用域。<br>作用域链：函数内部找不到值，就会往上级作用域去找，一直找到全局作用域，这样一个查找过程形成的链条称为作用域链。</p>\n<h3 id=\"三、变量提升\"><a href=\"#三、变量提升\" class=\"headerlink\" title=\"三、变量提升\"></a>三、变量提升</h3><p>在js编译阶段，会把变量和函数的声明提升至当前作用域的顶端<br>注意点：<br>1、提升的部分只是变量的声明，赋值语句和可执行代码逻辑还是保持原地不动<br>2、提升只是将变量声明和函数声明提升到变量所在的作用域顶端，并不会提示到全局作用域<br>3、ES6 的let和const声明不存在变量提升<br>4、函数是一级公民，优先提升</p>\n<h3 id=\"四、闭包\"><a href=\"#四、闭包\" class=\"headerlink\" title=\"四、闭包\"></a>四、闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数</p>\n<pre><code class=\"javascript\">function a() &#123;\n    var num = 0;\n    function b() &#123;\n        num++;\n        console.log(num);\n    &#125;\n    return b;\n&#125;\n\nvar a1 = a();\na1();\na1();\n\n// 打印结果为1,2\n</code></pre>\n<p>正常来说，a方法执行完毕后，a方法的作用域会被垃圾回收机制销毁，但由于此时全局作用域中a1指向了b方法，全局作用域变量不会被回收，故垃圾回收机制认为b还在使用，不会销毁，同时b方法引用了<br>a方法作用域中的num变量，故num也不会销毁，此时就形成了闭包，每次请求，都在原有的num上++,故打印为1,2  </p>\n<p>闭包的优点：<br>1、可以读取函数内部的变量<br>2、避免全局污染  </p>\n<p>闭包的缺点：<br>1、闭包会导致变量不会被垃圾回收机制所清除，会大量消耗内存<br>2、不恰当的使用闭包可能会造成内存泄漏的问题  </p>\n<h3 id=\"五、原型和原型链\"><a href=\"#五、原型和原型链\" class=\"headerlink\" title=\"五、原型和原型链\"></a>五、原型和原型链</h3><p>函数的原型：创建（声明）一个函数A，那么浏览器会在内存中创建一个对象B,函数A会有一个默认的属性prototype指向对象B，这个对象B就是函数A的原型对象。这个原型对象B有个默认属性constructor指向函数A<br><img src=\"http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/43031030.jpg\"></p>\n<p>将函数A作为构造函数使用new创建对象C，对象C就会存在一个属性__proto__([[Prototype]])指向原型对象B<br><img src=\"http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/6663492.jpg\"></p>\n<p><strong>Person函数举例</strong>  </p>\n<pre><code class=\"javascript\">function Person()\n&#123;\n\n&#125;\n\nvar person = new Person();\nperson.name = &#39;Tian&#39;;\nconsole.log(person.name);    //Tian\n</code></pre>\n<p>Person有个属性prototype指向原型对象(这里称为对象A，Person.prototype)，原型对象有个属性constructor指向Person,实例person有个属性__proto__指向原型对象<br><img src=\"https://s4.ax1x.com/2022/01/11/7mAFOg.png\"><br>原型对象也是对象，构造函数为Object,构造函数Object的prototype指向原型对象B(Object.prototype)，原型对象B的constructor属性指向构造函数Object,原型对象A的__proto__指向原型对象B(Object.prototype)<br><img src=\"https://s4.ax1x.com/2022/01/11/7mEP41.png\"></p>\n<p>原型链：实例的属性会先从实例的构造函数找，当前实例没有就会往构造函数的原型上找，直到找到构造函数Object的原型对象为止，Object.prototype.__proto__指向null,这样一个找寻过程形成的链路叫做原型链<br><img src=\"https://s4.ax1x.com/2022/01/11/7mEjPI.png\"></p>\n<h3 id=\"六、this指向\"><a href=\"#六、this指向\" class=\"headerlink\" title=\"六、this指向\"></a>六、this指向</h3><p>this永远指向最后调用它的对象<br>例1</p>\n<pre><code class=\"javascript\">var name = &#39;小王&#39;, age = 17;\nvar obj = &#123;\n    name: &#39;小张&#39;,\n    objAge: this.age,\n    myFun: function () &#123;\n        console.log(this.name + &quot;年龄&quot; + this.age);\n    &#125;\n&#125;\nconsole.log(obj.objAge) // 17\nobj.myFun() // 小张年龄undefined\nlet f = obj.myFun;\nf();  // 小王年龄17\n</code></pre>\n<p>例2</p>\n<pre><code class=\"javascript\">var fav = &#39;盲僧&#39;;\nfunction shows() &#123;\n    console.log(this.fav);\n&#125;\nshows()// 盲僧\n</code></pre>\n<p>this永远指向最后调用它的方法的对象，示例1  obj.myFun()this指向obj,将obj.myFun赋值给f,f调用，此时f()等同于window.fn(),故this指向window对象，示例2同理  </p>\n<p>函数对象的call()、apply()、bind()能改变this指向  </p>\n<p><strong>call、apply、bind方法详解</strong><br>例1  </p>\n<pre><code class=\"javascript\">var name = &#39;小王&#39;, age = 17;\n    var obj = &#123;\n        name: &#39;小张&#39;,\n        objAge: this.age,\n        myFun: function () &#123;\n            console.log(this.name + &quot;年龄&quot; + this.age);\n        &#125;\n    &#125;\n    var db = &#123;\n        name: &#39;德玛&#39;,\n        age: 99\n    &#125;\n\n    obj.myFun.call(db) // 德玛年龄99\n    obj.myFun.apply(db) // 德玛年龄99\n    obj.myFun.bind(db)() // 德玛年龄99\n</code></pre>\n<p>call、apply、bind都能改变this指向，bind方法返回是一个方法，需要再次调用  </p>\n<p>例2</p>\n<pre><code class=\"javascript\">var name = &#39;小王&#39;, age = 17;\n    var obj = &#123;\n        name: &#39;小张&#39;,\n        objAge: this.age,\n        myFun: function (fm, to) &#123;\n            console.log(this.name + &quot;年龄&quot; + this.age, &quot;来自&quot; + fm + &quot;去往&quot; + to);\n        &#125;\n    &#125;\n    var db = &#123;\n        name: &#39;德玛&#39;,\n        age: 99\n    &#125;\n\n    obj.myFun.call(db, &#39;上海&#39;, &#39;成都&#39;) // 德玛年龄99 来自上海去往成都\n    obj.myFun.apply(db, [&#39;上海&#39;, &#39;成都&#39;]) // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, &#39;上海&#39;, &#39;成都&#39;)() // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, [&#39;上海&#39;, &#39;成都&#39;])() // 德玛年龄99 来自上海,成都去往undefined\n</code></pre>\n<p>call、apply、bind第一个参数都是this指向的对象，第二个参数，call是直接放入，apply是放入数组，bind和call参数形式一样，除了需要再次调用  </p>\n<h3 id=\"七、new关键字\"><a href=\"#七、new关键字\" class=\"headerlink\" title=\"七、new关键字\"></a>七、new关键字</h3><p>是用new一个构造函数创建对象实例的过程  </p>\n<pre><code class=\"javascript\">function Pro()&#123;\n    this.x = &#39;1&#39;;\n    this.y = function()&#123;&#125;;\n&#125;\nvar p = new Pro();\n</code></pre>\n<p>1、创建一个空对象<br>2、将空对象的__proto__指向构造函数的原型对象（Pro.prototype）<br>3、将构造函数中的this指向此对象(new关键字会自动调用函数的apply方法，将this指向这个空对象吗)<br>4、执行构造函数代码为对象赋值<br>5、返回本对象(判断构造函数的返回值，如果是值类型，则返回创建的对象，如果是引用类型则返回引用类型对象本身)<br><img src=\"https://pic2.zhimg.com/v2-7ce5f71bd0865872b513a88fabb597fd_r.jpg\"></p>\n<p><strong>补充知识点</strong><br>1、在严格模式中默认的this不再是window，而是undefined</p>\n<h3 id=\"八、继承\"><a href=\"#八、继承\" class=\"headerlink\" title=\"八、继承\"></a>八、继承</h3><p>父类准备</p>\n<pre><code class=\"javascript\">// 定义一个动物类\nfunction Animal(name) &#123;\n  // 属性\n  this.name = name || &#39;Animal&#39;;\n  // 实例方法\n  this.sleep = function () &#123;\n    console.log(this.name + &#39;正在睡觉&#39;);\n  &#125;\n&#125;\n// 原型方法\nAnimal.prototype.eat = function (food) &#123;\n  console.log(this.name + &quot;正在吃&quot; + food);\n&#125;\n</code></pre>\n<p><strong>1、原型链继承</strong><br>核心：将父类的实例作为子类的原型</p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n      this.name = name;\n&#125;\n\nCat.prototype = new Animal();\nCat.prototype.age = 1;\n\nvar cat = new Cat(&#39;ximi&#39;);\nconsole.log(cat.name, cat.age); // ximi 1\ncat.eat(&#39;fish&#39;); // ximi正在吃fish\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例<br>2、父类新增原型方法/原型属性，子类都能访问到<br>3、简单，易于实现<br>缺点：<br>1、要新增子类原型属性和方法，必须放在new Animal()这样的语句之后执行<br>2、无法实现多继承<br>3、来自原型对象的所有属性被所有实例共享<br>4、创建子类实例时，无法向父类构造函数传参  </p>\n<p><strong>2、构造继承</strong><br>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    Animal.call(this, &#39;ximi&#39;);\n    this.name = name || &#39;putao&#39;;\n&#125;\n\nvar cat = new Cat()\nconsole.log(cat.name) // putao\ncat.eat(&#39;fish&#39;); // 报错\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat) // true\nconsole.log(cat instanceof Animal) // false\n</code></pre>\n<p>特点：<br>1、只继承了父类构造函数的属性和方法，没有继承父类原型的属性和方法<br>2、可以继承多个构造函数属性和方法（call多个）<br>3、创建子类实例时可以向父类传参<br>缺点：<br>1、实例并不是父类的实例，只是子类的实例<br>2、只能继承父类的属性和方法，不能继承父类原型的属性和方法<br>3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能  </p>\n<p><strong>3、实例继承</strong><br>核心：为父类实例添加新特性，作为子类实例返回  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    var instance = new Animal(&#39;ximi&#39;);\n    instance.name = name || &#39;putaa&#39;;\n    return instance\n&#125;\n\nvar cat = new Cat(&#39;ppt&#39;);\nconsole.log(cat.name); // ppt\ncat.eat(&#39;鱼&#39;); //ppt正在吃鱼\ncat.sleep(); //ppt正在睡觉\nconsole.log(cat instanceof Cat); //false\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、不限制调用方式，不管是new 子类()还是子类()，返回的对象具有相同的效果<br>缺点：<br>1、实例是父类的实例，不是子类的实例<br>2、不支持多继承  </p>\n<p><strong>4、拷贝继承</strong>  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    var instance = new Animal(name);\n\n    for (let key in instance) &#123;\n        this[key] = instance[key];\n    &#125;\n&#125;\n\nvar cat = new Cat(&#39;bbt&#39;);\nconsole.log(cat.name); //bbt\ncat.eat(&#39;肉&#39;); // bbt正在吃肉\ncat.sleep(); // bbt正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // false\n</code></pre>\n<p>特点：<br>1、支持多继承<br>缺点：<br>1、效率低，内存占用高，因为要拷贝父类的属性<br>2、无法获取父类不可枚举的方法  </p>\n<p><strong>5、组合继承</strong><br>核心：通过调用父类构造函数，继承父类属性并保留传参的特点，然后将通过将父类的实例作为子类的原型，实现函数复用</p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    Animal.call(this, name);\n&#125;\nCat.prototype = new Animal();\nvar cat = new Cat(&#39;ttp&#39;);\nconsole.log(cat.name); // ttp\ncat.eat(&#39;白菜&#39;); // ttp正在吃白菜\ncat.sleep(); // ttp正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、弥补了方式2的缺陷，可以继承实例的属性和方法，也能继承原型的属性和方法<br>2、既是子类的实例，也是父类的实例<br>3、不存在引用属性共享的问题<br>4、可传参<br>5、函数可复用<br>缺点：<br>1、调用两次父类的构造函数，生成两份实例（子类实例将子类原型上的那份屏蔽了）  </p>\n<p><strong>6、寄生组合继承</strong><br>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次方法和属性，避免组合继承的缺陷  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    Animal.call(this,name);\n&#125;\n\nvar Super = function () &#123;&#125;\n\nSuper.prototype = Animal.prototype\n\nCat.prototype = new Super();\n\nCat.prototype.constructor = Cat;\n\nvar cat = new Cat(&#39;pig&#39;);\n\nconsole.log(cat.name); // pig\ncat.eat(&#39;白菜&#39;); // pig正在吃白菜\ncat.sleep(); // pig正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、解决了两次调用父类的构造函数<br>缺点：<br>1、实现较为复杂</p>\n<h3 id=\"九、EventLoop-事件循环\"><a href=\"#九、EventLoop-事件循环\" class=\"headerlink\" title=\"九、EventLoop (事件循环)\"></a>九、EventLoop (事件循环)</h3><p>JS是单线程的，为了防止一个函数的执行事件过长阻塞后面的代码，所以会先把同步代码压入执行栈中，依次执行，将异步代码推入异步队列，当执行栈中没有执行任务时，EventLoop开始工作，将异步队列中的任务依次压入执行栈中执行，直到所有异步队列执行完毕。<br><img src=\"https://s4.ax1x.com/2022/01/13/7QcOG6.png\"><br><img src=\"https://s4.ax1x.com/2022/01/13/7Qgliq.png\"><br>注意：<br>1、js是单线程的，但是浏览器是多线程的，执行异步任务是异步线程执行<br>2、异步任务也分为宏任务和微任务，微任务优先宏任务执行，微任务队列的代表：Promise.then,MutationObserver。宏任务的代表：setTimeout,setInterval,setImmediate  </p>\n<h3 id=\"十、事件冒泡、捕获、委托\"><a href=\"#十、事件冒泡、捕获、委托\" class=\"headerlink\" title=\"十、事件冒泡、捕获、委托\"></a>十、事件冒泡、捕获、委托</h3><p>DOM事件流：事件捕获、处于目标阶段、事件冒泡<br>事件委托：就是利用事件冒泡机制，将事件绑定在目标DOM的父级上，触发执行效果<br>事件委托的优势：1、减少DOM操作，提高性能。2、随时可以添加子元素，添加的子元素会自动有相应的处理事件  </p>\n<h3 id=\"十一、原生AJAX\"><a href=\"#十一、原生AJAX\" class=\"headerlink\" title=\"十一、原生AJAX\"></a>十一、原生AJAX</h3><pre><code class=\"javascript\">var Ajax = &#123;\n    get: function (url, callback) &#123;\n        // XMLHttpRequest对象用于在后台与服务器交换数据\n        var xhr = new XMLHttpRequest();\n        //参数说明：方法名GET/POST   请求地址   async 请求进行异步还是同步，true服务器响应时执行其他脚本，false是等待服务器响应再执行\n        xhr.open(&#39;GET&#39;, url, false);\n        xhr.onreadystatechange = function () &#123;\n            // readyState == 4说明请求已完成\n            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304) &#123;\n                // 从服务器获得数据\n                callback(xhr.responseText)\n            &#125;\n        &#125;\n        xhr.send();\n    &#125;,\n    post: function (url, data, callback) &#123;\n        var xhr = new XMLHttpRequest();\n        xhr.open(&#39;POST&#39;,url, false);\n        xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);\n        xhr.onreadystatechange = function () &#123;\n            if (xhr.readyState == 4) &#123;\n                if (xhr.status == 200 || xhr.status == 304) &#123;\n                    callback(xhr.responseText);\n                &#125;\n            &#125;\n        &#125;\n        xhr.send(data);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"十二、js深拷贝和浅拷贝\"><a href=\"#十二、js深拷贝和浅拷贝\" class=\"headerlink\" title=\"十二、js深拷贝和浅拷贝\"></a>十二、js深拷贝和浅拷贝</h3><p>如何区分浅拷贝和深拷贝，简单来说，假设B复制A，当修改A的引用数据时，看B是否发生改变，如果B跟着变了，就是浅拷贝，如果没变就是深拷贝<br>浅拷贝的方式：<br>1、直接=赋值<br>2、for in<br>3、Object.assign()  </p>\n<p>深拷贝的方式：<br>1、采用递归去拷贝所有层级的属性</p>\n<pre><code class=\"javascript\">function deepClone(obj) &#123;\n    let objClone = Array.isArray(obj) ? []: &#123;&#125;\n    if (typeof obj === &#39;object&#39;) &#123;\n        Object.keys(obj).forEach(key =&gt; &#123;\n            if (obj[key] &amp;&amp; typeof obj[key] === &#39;object&#39;) &#123;\n                objClone[key] = deepClone(obj[key])\n            &#125; else &#123;\n                objClone[key] = obj[key]\n            &#125;\n        &#125;)\n    &#125; else &#123;\n        objClone = obj\n    &#125;\n    return objClone;\n&#125;\n\nlet a = &#123;\n    name: &#39;zs&#39;,\n    age: 18,\n    son: &#123;\n        name: &#39;ls&#39;,\n        age: 1\n    &#125;\n&#125;\nlet b = deepClone(a) //深拷贝\nlet c = Object.assign(&#123;&#125;, a); //浅拷贝\nlet d = a; //浅拷贝\nlet e = &#123;&#125;;\nfor (let key in a) &#123; //浅拷贝\n    e[key] = a[key]\n&#125;\na.son.name = &#39;zs&#39;;\nconsole.log(a); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\nconsole.log(b); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ls&#39;, age: 1 &#125; &#125;\nconsole.log(c); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\nconsole.log(d); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\nconsole.log(e); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\n</code></pre>\n<p>2、才用JSON的方法</p>\n<pre><code class=\"javascript\">let a = &#123;\n    name: &#39;zs&#39;,\n    age: 18,\n    son: &#123;\n        name: &#39;ls&#39;,\n        age: 1\n    &#125;\n&#125;\nlet b = JSON.parse(JSON.stringify(a));\na.son.name = &#39;ww&#39;;\nconsole.log(a); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ww&#39;, age: 1 &#125; &#125;\nconsole.log(b); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ls&#39;, age: 1 &#125; &#125;\n\n//缺点：无法复制方法属性\n\nlet a1 = &#123;\n    name: &#39;zs&#39;,\n    age: 18,\n    son: &#123;\n        name: &#39;ls&#39;,\n        age: 1\n    &#125;,\n    say() &#123;\n        console.log(&#39;hello&#39;)\n    &#125;\n&#125;\nlet b1 = JSON.parse(JSON.stringify(a1));\na1.son.name = &#39;ww&#39;;\nconsole.log(a1); // &#123; name: &#39;zs&#39;,age: 18,son: &#123; name: &#39;ww&#39;, age: 1 &#125;,say: [Function: say] &#125;\nconsole.log(b1); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ls&#39;, age: 1 &#125; &#125;\n</code></pre>\n<p>3、利用jQuery的extend方法</p>\n<pre><code class=\"javascript\">let arr = [1,2,3,4]\nlet newArr = $.extend(true, [], arr) // true为深拷贝，false为浅拷贝\n</code></pre>\n<p>4、loadsh函数库实现</p>\n<pre><code class=\"javascript\">let obj = &#123;\n    name: &#39;z1&#39;,\n    son: &#123;\n        name: &#39;zs&#39;\n    &#125;\n&#125;\nlet result = _.cloneDeep(obj);\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"js基础知识\"><a href=\"#js基础知识\" class=\"headerlink\" title=\"js基础知识\"></a>js基础知识</h2><h3 id=\"一、js数据类型\"><a href=\"#一、js数据类型\" class=\"headerlink\" title=\"一、js数据类型\"></a>一、js数据类型</h3><p>基本数值类型：String、Number、Boolean、Null、Undefined、Symbol<br>引用数据类型：Object、Array、Function  </p>\n<p>null和undefined的区别：null表示空对象，undefined表示已在作用域中声明但未赋值的变量  </p>\n<p>typeof主要用来判断数据类型 返回值有string、boolean、number、function、object、undefined  </p>\n<p>instanceof 判断该对象是谁的实例</p>\n<p>弱类型：在定义变量时，我们可以为变量赋值任何数据，变量的数据类型不是固定死的，这样的类型叫做弱类型<br>强类型：在声明变量的时候，一旦给变量赋值，那么变量的数据类型就已经确定，之后如果要给该变量赋值其他类型的数据，需要进行强制类型装换  </p>\n<p>动态类型：动态类型的类型检查会在 <strong>代码运行的时候进行</strong><br>静态类型：静态类型的类型检查会在 <strong>编译时进行</strong></p>\n<h3 id=\"二、作用域和作用域链\"><a href=\"#二、作用域和作用域链\" class=\"headerlink\" title=\"二、作用域和作用域链\"></a>二、作用域和作用域链</h3><p>在js中，作用域分为全局作用域和局部作用域，全局作用域在程序的任何地方都能访问，局部作用域一般指函数内部的作用域。<br>作用域链：函数内部找不到值，就会往上级作用域去找，一直找到全局作用域，这样一个查找过程形成的链条称为作用域链。</p>\n<h3 id=\"三、变量提升\"><a href=\"#三、变量提升\" class=\"headerlink\" title=\"三、变量提升\"></a>三、变量提升</h3><p>在js编译阶段，会把变量和函数的声明提升至当前作用域的顶端<br>注意点：<br>1、提升的部分只是变量的声明，赋值语句和可执行代码逻辑还是保持原地不动<br>2、提升只是将变量声明和函数声明提升到变量所在的作用域顶端，并不会提示到全局作用域<br>3、ES6 的let和const声明不存在变量提升<br>4、函数是一级公民，优先提升</p>\n<h3 id=\"四、闭包\"><a href=\"#四、闭包\" class=\"headerlink\" title=\"四、闭包\"></a>四、闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数</p>\n<pre><code class=\"javascript\">function a() &#123;\n    var num = 0;\n    function b() &#123;\n        num++;\n        console.log(num);\n    &#125;\n    return b;\n&#125;\n\nvar a1 = a();\na1();\na1();\n\n// 打印结果为1,2\n</code></pre>\n<p>正常来说，a方法执行完毕后，a方法的作用域会被垃圾回收机制销毁，但由于此时全局作用域中a1指向了b方法，全局作用域变量不会被回收，故垃圾回收机制认为b还在使用，不会销毁，同时b方法引用了<br>a方法作用域中的num变量，故num也不会销毁，此时就形成了闭包，每次请求，都在原有的num上++,故打印为1,2  </p>\n<p>闭包的优点：<br>1、可以读取函数内部的变量<br>2、避免全局污染  </p>\n<p>闭包的缺点：<br>1、闭包会导致变量不会被垃圾回收机制所清除，会大量消耗内存<br>2、不恰当的使用闭包可能会造成内存泄漏的问题  </p>\n<h3 id=\"五、原型和原型链\"><a href=\"#五、原型和原型链\" class=\"headerlink\" title=\"五、原型和原型链\"></a>五、原型和原型链</h3><p>函数的原型：创建（声明）一个函数A，那么浏览器会在内存中创建一个对象B,函数A会有一个默认的属性prototype指向对象B，这个对象B就是函数A的原型对象。这个原型对象B有个默认属性constructor指向函数A<br><img src=\"http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/43031030.jpg\"></p>\n<p>将函数A作为构造函数使用new创建对象C，对象C就会存在一个属性__proto__([[Prototype]])指向原型对象B<br><img src=\"http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/imgs/public/16-11-10/6663492.jpg\"></p>\n<p><strong>Person函数举例</strong>  </p>\n<pre><code class=\"javascript\">function Person()\n&#123;\n\n&#125;\n\nvar person = new Person();\nperson.name = &#39;Tian&#39;;\nconsole.log(person.name);    //Tian\n</code></pre>\n<p>Person有个属性prototype指向原型对象(这里称为对象A，Person.prototype)，原型对象有个属性constructor指向Person,实例person有个属性__proto__指向原型对象<br><img src=\"https://s4.ax1x.com/2022/01/11/7mAFOg.png\"><br>原型对象也是对象，构造函数为Object,构造函数Object的prototype指向原型对象B(Object.prototype)，原型对象B的constructor属性指向构造函数Object,原型对象A的__proto__指向原型对象B(Object.prototype)<br><img src=\"https://s4.ax1x.com/2022/01/11/7mEP41.png\"></p>\n<p>原型链：实例的属性会先从实例的构造函数找，当前实例没有就会往构造函数的原型上找，直到找到构造函数Object的原型对象为止，Object.prototype.__proto__指向null,这样一个找寻过程形成的链路叫做原型链<br><img src=\"https://s4.ax1x.com/2022/01/11/7mEjPI.png\"></p>\n<h3 id=\"六、this指向\"><a href=\"#六、this指向\" class=\"headerlink\" title=\"六、this指向\"></a>六、this指向</h3><p>this永远指向最后调用它的对象<br>例1</p>\n<pre><code class=\"javascript\">var name = &#39;小王&#39;, age = 17;\nvar obj = &#123;\n    name: &#39;小张&#39;,\n    objAge: this.age,\n    myFun: function () &#123;\n        console.log(this.name + &quot;年龄&quot; + this.age);\n    &#125;\n&#125;\nconsole.log(obj.objAge) // 17\nobj.myFun() // 小张年龄undefined\nlet f = obj.myFun;\nf();  // 小王年龄17\n</code></pre>\n<p>例2</p>\n<pre><code class=\"javascript\">var fav = &#39;盲僧&#39;;\nfunction shows() &#123;\n    console.log(this.fav);\n&#125;\nshows()// 盲僧\n</code></pre>\n<p>this永远指向最后调用它的方法的对象，示例1  obj.myFun()this指向obj,将obj.myFun赋值给f,f调用，此时f()等同于window.fn(),故this指向window对象，示例2同理  </p>\n<p>函数对象的call()、apply()、bind()能改变this指向  </p>\n<p><strong>call、apply、bind方法详解</strong><br>例1  </p>\n<pre><code class=\"javascript\">var name = &#39;小王&#39;, age = 17;\n    var obj = &#123;\n        name: &#39;小张&#39;,\n        objAge: this.age,\n        myFun: function () &#123;\n            console.log(this.name + &quot;年龄&quot; + this.age);\n        &#125;\n    &#125;\n    var db = &#123;\n        name: &#39;德玛&#39;,\n        age: 99\n    &#125;\n\n    obj.myFun.call(db) // 德玛年龄99\n    obj.myFun.apply(db) // 德玛年龄99\n    obj.myFun.bind(db)() // 德玛年龄99\n</code></pre>\n<p>call、apply、bind都能改变this指向，bind方法返回是一个方法，需要再次调用  </p>\n<p>例2</p>\n<pre><code class=\"javascript\">var name = &#39;小王&#39;, age = 17;\n    var obj = &#123;\n        name: &#39;小张&#39;,\n        objAge: this.age,\n        myFun: function (fm, to) &#123;\n            console.log(this.name + &quot;年龄&quot; + this.age, &quot;来自&quot; + fm + &quot;去往&quot; + to);\n        &#125;\n    &#125;\n    var db = &#123;\n        name: &#39;德玛&#39;,\n        age: 99\n    &#125;\n\n    obj.myFun.call(db, &#39;上海&#39;, &#39;成都&#39;) // 德玛年龄99 来自上海去往成都\n    obj.myFun.apply(db, [&#39;上海&#39;, &#39;成都&#39;]) // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, &#39;上海&#39;, &#39;成都&#39;)() // 德玛年龄99 来自上海去往成都\n    obj.myFun.bind(db, [&#39;上海&#39;, &#39;成都&#39;])() // 德玛年龄99 来自上海,成都去往undefined\n</code></pre>\n<p>call、apply、bind第一个参数都是this指向的对象，第二个参数，call是直接放入，apply是放入数组，bind和call参数形式一样，除了需要再次调用  </p>\n<h3 id=\"七、new关键字\"><a href=\"#七、new关键字\" class=\"headerlink\" title=\"七、new关键字\"></a>七、new关键字</h3><p>是用new一个构造函数创建对象实例的过程  </p>\n<pre><code class=\"javascript\">function Pro()&#123;\n    this.x = &#39;1&#39;;\n    this.y = function()&#123;&#125;;\n&#125;\nvar p = new Pro();\n</code></pre>\n<p>1、创建一个空对象<br>2、将空对象的__proto__指向构造函数的原型对象（Pro.prototype）<br>3、将构造函数中的this指向此对象(new关键字会自动调用函数的apply方法，将this指向这个空对象吗)<br>4、执行构造函数代码为对象赋值<br>5、返回本对象(判断构造函数的返回值，如果是值类型，则返回创建的对象，如果是引用类型则返回引用类型对象本身)<br><img src=\"https://pic2.zhimg.com/v2-7ce5f71bd0865872b513a88fabb597fd_r.jpg\"></p>\n<p><strong>补充知识点</strong><br>1、在严格模式中默认的this不再是window，而是undefined</p>\n<h3 id=\"八、继承\"><a href=\"#八、继承\" class=\"headerlink\" title=\"八、继承\"></a>八、继承</h3><p>父类准备</p>\n<pre><code class=\"javascript\">// 定义一个动物类\nfunction Animal(name) &#123;\n  // 属性\n  this.name = name || &#39;Animal&#39;;\n  // 实例方法\n  this.sleep = function () &#123;\n    console.log(this.name + &#39;正在睡觉&#39;);\n  &#125;\n&#125;\n// 原型方法\nAnimal.prototype.eat = function (food) &#123;\n  console.log(this.name + &quot;正在吃&quot; + food);\n&#125;\n</code></pre>\n<p><strong>1、原型链继承</strong><br>核心：将父类的实例作为子类的原型</p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n      this.name = name;\n&#125;\n\nCat.prototype = new Animal();\nCat.prototype.age = 1;\n\nvar cat = new Cat(&#39;ximi&#39;);\nconsole.log(cat.name, cat.age); // ximi 1\ncat.eat(&#39;fish&#39;); // ximi正在吃fish\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、非常纯粹的继承关系，实例是子类的实例，也是父类的实例<br>2、父类新增原型方法/原型属性，子类都能访问到<br>3、简单，易于实现<br>缺点：<br>1、要新增子类原型属性和方法，必须放在new Animal()这样的语句之后执行<br>2、无法实现多继承<br>3、来自原型对象的所有属性被所有实例共享<br>4、创建子类实例时，无法向父类构造函数传参  </p>\n<p><strong>2、构造继承</strong><br>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    Animal.call(this, &#39;ximi&#39;);\n    this.name = name || &#39;putao&#39;;\n&#125;\n\nvar cat = new Cat()\nconsole.log(cat.name) // putao\ncat.eat(&#39;fish&#39;); // 报错\ncat.sleep(); // ximi正在睡觉\nconsole.log(cat instanceof Cat) // true\nconsole.log(cat instanceof Animal) // false\n</code></pre>\n<p>特点：<br>1、只继承了父类构造函数的属性和方法，没有继承父类原型的属性和方法<br>2、可以继承多个构造函数属性和方法（call多个）<br>3、创建子类实例时可以向父类传参<br>缺点：<br>1、实例并不是父类的实例，只是子类的实例<br>2、只能继承父类的属性和方法，不能继承父类原型的属性和方法<br>3、无法实现函数复用，每个子类都有父类实例函数的副本，影响性能  </p>\n<p><strong>3、实例继承</strong><br>核心：为父类实例添加新特性，作为子类实例返回  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    var instance = new Animal(&#39;ximi&#39;);\n    instance.name = name || &#39;putaa&#39;;\n    return instance\n&#125;\n\nvar cat = new Cat(&#39;ppt&#39;);\nconsole.log(cat.name); // ppt\ncat.eat(&#39;鱼&#39;); //ppt正在吃鱼\ncat.sleep(); //ppt正在睡觉\nconsole.log(cat instanceof Cat); //false\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、不限制调用方式，不管是new 子类()还是子类()，返回的对象具有相同的效果<br>缺点：<br>1、实例是父类的实例，不是子类的实例<br>2、不支持多继承  </p>\n<p><strong>4、拷贝继承</strong>  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    var instance = new Animal(name);\n\n    for (let key in instance) &#123;\n        this[key] = instance[key];\n    &#125;\n&#125;\n\nvar cat = new Cat(&#39;bbt&#39;);\nconsole.log(cat.name); //bbt\ncat.eat(&#39;肉&#39;); // bbt正在吃肉\ncat.sleep(); // bbt正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // false\n</code></pre>\n<p>特点：<br>1、支持多继承<br>缺点：<br>1、效率低，内存占用高，因为要拷贝父类的属性<br>2、无法获取父类不可枚举的方法  </p>\n<p><strong>5、组合继承</strong><br>核心：通过调用父类构造函数，继承父类属性并保留传参的特点，然后将通过将父类的实例作为子类的原型，实现函数复用</p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    Animal.call(this, name);\n&#125;\nCat.prototype = new Animal();\nvar cat = new Cat(&#39;ttp&#39;);\nconsole.log(cat.name); // ttp\ncat.eat(&#39;白菜&#39;); // ttp正在吃白菜\ncat.sleep(); // ttp正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、弥补了方式2的缺陷，可以继承实例的属性和方法，也能继承原型的属性和方法<br>2、既是子类的实例，也是父类的实例<br>3、不存在引用属性共享的问题<br>4、可传参<br>5、函数可复用<br>缺点：<br>1、调用两次父类的构造函数，生成两份实例（子类实例将子类原型上的那份屏蔽了）  </p>\n<p><strong>6、寄生组合继承</strong><br>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次方法和属性，避免组合继承的缺陷  </p>\n<pre><code class=\"javascript\">function Cat(name) &#123;\n    Animal.call(this,name);\n&#125;\n\nvar Super = function () &#123;&#125;\n\nSuper.prototype = Animal.prototype\n\nCat.prototype = new Super();\n\nCat.prototype.constructor = Cat;\n\nvar cat = new Cat(&#39;pig&#39;);\n\nconsole.log(cat.name); // pig\ncat.eat(&#39;白菜&#39;); // pig正在吃白菜\ncat.sleep(); // pig正在睡觉\nconsole.log(cat instanceof Cat); // true\nconsole.log(cat instanceof Animal); // true\n</code></pre>\n<p>特点：<br>1、解决了两次调用父类的构造函数<br>缺点：<br>1、实现较为复杂</p>\n<h3 id=\"九、EventLoop-事件循环\"><a href=\"#九、EventLoop-事件循环\" class=\"headerlink\" title=\"九、EventLoop (事件循环)\"></a>九、EventLoop (事件循环)</h3><p>JS是单线程的，为了防止一个函数的执行事件过长阻塞后面的代码，所以会先把同步代码压入执行栈中，依次执行，将异步代码推入异步队列，当执行栈中没有执行任务时，EventLoop开始工作，将异步队列中的任务依次压入执行栈中执行，直到所有异步队列执行完毕。<br><img src=\"https://s4.ax1x.com/2022/01/13/7QcOG6.png\"><br><img src=\"https://s4.ax1x.com/2022/01/13/7Qgliq.png\"><br>注意：<br>1、js是单线程的，但是浏览器是多线程的，执行异步任务是异步线程执行<br>2、异步任务也分为宏任务和微任务，微任务优先宏任务执行，微任务队列的代表：Promise.then,MutationObserver。宏任务的代表：setTimeout,setInterval,setImmediate  </p>\n<h3 id=\"十、事件冒泡、捕获、委托\"><a href=\"#十、事件冒泡、捕获、委托\" class=\"headerlink\" title=\"十、事件冒泡、捕获、委托\"></a>十、事件冒泡、捕获、委托</h3><p>DOM事件流：事件捕获、处于目标阶段、事件冒泡<br>事件委托：就是利用事件冒泡机制，将事件绑定在目标DOM的父级上，触发执行效果<br>事件委托的优势：1、减少DOM操作，提高性能。2、随时可以添加子元素，添加的子元素会自动有相应的处理事件  </p>\n<h3 id=\"十一、原生AJAX\"><a href=\"#十一、原生AJAX\" class=\"headerlink\" title=\"十一、原生AJAX\"></a>十一、原生AJAX</h3><pre><code class=\"javascript\">var Ajax = &#123;\n    get: function (url, callback) &#123;\n        // XMLHttpRequest对象用于在后台与服务器交换数据\n        var xhr = new XMLHttpRequest();\n        //参数说明：方法名GET/POST   请求地址   async 请求进行异步还是同步，true服务器响应时执行其他脚本，false是等待服务器响应再执行\n        xhr.open(&#39;GET&#39;, url, false);\n        xhr.onreadystatechange = function () &#123;\n            // readyState == 4说明请求已完成\n            if (xhr.readyState == 4 &amp;&amp; xhr.status == 200 || xhr.status == 304) &#123;\n                // 从服务器获得数据\n                callback(xhr.responseText)\n            &#125;\n        &#125;\n        xhr.send();\n    &#125;,\n    post: function (url, data, callback) &#123;\n        var xhr = new XMLHttpRequest();\n        xhr.open(&#39;POST&#39;,url, false);\n        xhr.setRequestHeader(&#39;Content-Type&#39;,&#39;application/x-www-form-urlencoded&#39;);\n        xhr.onreadystatechange = function () &#123;\n            if (xhr.readyState == 4) &#123;\n                if (xhr.status == 200 || xhr.status == 304) &#123;\n                    callback(xhr.responseText);\n                &#125;\n            &#125;\n        &#125;\n        xhr.send(data);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"十二、js深拷贝和浅拷贝\"><a href=\"#十二、js深拷贝和浅拷贝\" class=\"headerlink\" title=\"十二、js深拷贝和浅拷贝\"></a>十二、js深拷贝和浅拷贝</h3><p>如何区分浅拷贝和深拷贝，简单来说，假设B复制A，当修改A的引用数据时，看B是否发生改变，如果B跟着变了，就是浅拷贝，如果没变就是深拷贝<br>浅拷贝的方式：<br>1、直接=赋值<br>2、for in<br>3、Object.assign()  </p>\n<p>深拷贝的方式：<br>1、采用递归去拷贝所有层级的属性</p>\n<pre><code class=\"javascript\">function deepClone(obj) &#123;\n    let objClone = Array.isArray(obj) ? []: &#123;&#125;\n    if (typeof obj === &#39;object&#39;) &#123;\n        Object.keys(obj).forEach(key =&gt; &#123;\n            if (obj[key] &amp;&amp; typeof obj[key] === &#39;object&#39;) &#123;\n                objClone[key] = deepClone(obj[key])\n            &#125; else &#123;\n                objClone[key] = obj[key]\n            &#125;\n        &#125;)\n    &#125; else &#123;\n        objClone = obj\n    &#125;\n    return objClone;\n&#125;\n\nlet a = &#123;\n    name: &#39;zs&#39;,\n    age: 18,\n    son: &#123;\n        name: &#39;ls&#39;,\n        age: 1\n    &#125;\n&#125;\nlet b = deepClone(a) //深拷贝\nlet c = Object.assign(&#123;&#125;, a); //浅拷贝\nlet d = a; //浅拷贝\nlet e = &#123;&#125;;\nfor (let key in a) &#123; //浅拷贝\n    e[key] = a[key]\n&#125;\na.son.name = &#39;zs&#39;;\nconsole.log(a); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\nconsole.log(b); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ls&#39;, age: 1 &#125; &#125;\nconsole.log(c); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\nconsole.log(d); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\nconsole.log(e); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;zs&#39;, age: 1 &#125; &#125;\n</code></pre>\n<p>2、才用JSON的方法</p>\n<pre><code class=\"javascript\">let a = &#123;\n    name: &#39;zs&#39;,\n    age: 18,\n    son: &#123;\n        name: &#39;ls&#39;,\n        age: 1\n    &#125;\n&#125;\nlet b = JSON.parse(JSON.stringify(a));\na.son.name = &#39;ww&#39;;\nconsole.log(a); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ww&#39;, age: 1 &#125; &#125;\nconsole.log(b); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ls&#39;, age: 1 &#125; &#125;\n\n//缺点：无法复制方法属性\n\nlet a1 = &#123;\n    name: &#39;zs&#39;,\n    age: 18,\n    son: &#123;\n        name: &#39;ls&#39;,\n        age: 1\n    &#125;,\n    say() &#123;\n        console.log(&#39;hello&#39;)\n    &#125;\n&#125;\nlet b1 = JSON.parse(JSON.stringify(a1));\na1.son.name = &#39;ww&#39;;\nconsole.log(a1); // &#123; name: &#39;zs&#39;,age: 18,son: &#123; name: &#39;ww&#39;, age: 1 &#125;,say: [Function: say] &#125;\nconsole.log(b1); // &#123; name: &#39;zs&#39;, age: 18, son: &#123; name: &#39;ls&#39;, age: 1 &#125; &#125;\n</code></pre>\n<p>3、利用jQuery的extend方法</p>\n<pre><code class=\"javascript\">let arr = [1,2,3,4]\nlet newArr = $.extend(true, [], arr) // true为深拷贝，false为浅拷贝\n</code></pre>\n<p>4、loadsh函数库实现</p>\n<pre><code class=\"javascript\">let obj = &#123;\n    name: &#39;z1&#39;,\n    son: &#123;\n        name: &#39;zs&#39;\n    &#125;\n&#125;\nlet result = _.cloneDeep(obj);\n</code></pre>\n"},{"title":"es6","date":"2022-01-13T08:27:11.000Z","cover":"https://s4.ax1x.com/2022/01/13/7Qj0kq.png","_content":"\n## es6基本知识\n\n### 一、let/const\n1、const/let都是用来声明变量，不可重复声明，具有块级作用域。存在暂时性死区，不存在变量提升。const用来声明常量。  \n\n### 二、symbol\n1、symbol是一个全新的数据类型，表示独一无二的值，对象可以以symbol类型作为键  \n2、现在主要用于声明对象的私有属性  \n__示例__\n```javascript\nconsole.log(Symbol() === Symbol()); // false\nconsole.log(Symbol('foo') === Symbol('foo')); // false\nconsole.log(typeof Symbol()); // symbol\nconsole.log(Symbol('foo')); // Symbol('foo')\n\nconst obj = {\n    [Symbol('name')]: '张三'\n}\nconsole.log(obj) // {[Symbol(name)]:'张三'}\nconsole.log(obj[Symbol('name')]) // undefined\n\nlet name = Symbol('name');\nconst Person = {\n    [name]: 'zhangsan',\n    age: 15,\n    say() {\n        console.log('i am ' + this[name])\n    }\n}\n\nconsole.log(Person[Symbol('name')]) // undefined 故symbol一般用于定义私有属性 ，外部访问不到\nPerson.say() // i am zhangsan\n\nconsole.log(Symbol.for('true') === Symbol.for(true)) // true  Symbol.for方法是根据字符串参数作比较是否相等\n\nconst objj = {\n    [Symbol('name')]: 'lisi',\n    age: 15\n}\n\nfor (let k in objj) {\n    console.log(k); // age  for方法无法访问到Symbol属性\n}\n\nconsole.log(Object.keys(objj)) // ['age']  Object.keys也无法访问Symbol属性\n\nconsole.log(JSON.stringify(objj)) // {'age':15}\n\nconsole.log(Object.getOwnPropertySymbols(objj)) // [Symbol(name)] 能获取到Symbol属性\n\nconsole.log(Reflect.ownKeys(objj)) // ['age', Symbol(name)] 能获取到Symbol属性\n```\n\n### 三、对象和数组的解构\n__示例__  \n1、数组的解构\n```javascript\n// 传统方法\nconst arr = [1, 2, 3];\nlet fir = arr[0];\nlet sec = arr[1];\nlet thr = arr[2];\nconsole.log(fir, sec, thr) // 1,2,3\n\n//es6新增解构方法\nlet [f, s, t] = arr;\nconsole.log(f,s,t) // 1,2,3\n\nlet [f, ...rest] = arr;\nconsole.log(f, rest) // 1, [2, 3]\n\nlet [f, a, b, c, d] = arr;\nconsole.log(f,a,b,c,d) // 1,2,3,undefined，undefined\n\nlet [,,a,b,c] = arr;\nconsole.log(a,b,c) // 3 undefined undefined\n```\n2、对象的解构\n```javascript\nconst obj = {\n    name: 'zhangsan',\n    age: 15\n}\n\nconst {name, age} = obj;\nconsole.log(name, age); // zhangsan 15\n\nconst name1 = 'lisi';\n\nconst {name: name2, age, sex='man'} = obj;\n\nconsole.log(name1, name2, age, sex); // lisi zhangsan 15 man\n```\n\n### 四、模板字符串\n__示例__  \n```javascript\nlet str = `我是模板字符串 我能\n直接换行`\nconsole.log(str);\n//我是模板字符串 我能\n//直接换行\n\nconst {name, age, sex} = {\n    name: 'zhangsan',\n    age: 18,\n    sex: 'man'\n}\n\nlet s = `大家好，我是${name}, 今年${age}, ${1+20}，${Math.random()}`\nconsole.log(s) // 大家好，我是zhangsan, 今年18, 21，0.45371632552390184\n\nfunction tag(str, sex, name, age) {\n    console.log(str, sex, name, age)\n}\n//tag方法使用于模板字符串，第一个参数返回以${}拆分的数组，剩余的参数与目标字符穿的顺序一一对应\nconst a = tag`大家好，我是${sex}，姓名：${name}, 年龄${age}, 哈哈`; // [ '大家好， 我是', '，姓名：', ', 年龄', ',哈哈' ] 'man' 'zhangsan' 18\nconsole.log(a); // undefined\n```\n\n### 五、扩展运算符(...)  \n对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中,属于浅拷贝  \n__示例__  \n```javascript\nconst a = {\n    name: 'zhangsan',\n    age: 18,\n    friends: ['xm', 'xh']\n}\nconst b = {\n    name: 'lisi',\n    sex: 'woman'\n}\n\nconst c = {\n    ...a,\n    ...b\n}\nconsole.log(c)  // { name: 'lisi', age: 18, friends: [ 'xm', 'xh' ], sex: 'woman' }\n\n// c引用数据类型发生改变，a也会随之改变，证明扩展运算符是浅拷贝\nc.friends[0] = 'xt';\nc.age = 20;\nconsole.log(a) // { name: 'zhangsan', age: 18, friends: [ 'xt', 'xh' ] }\nconsole.log(c) // { name: 'lisi', age: 20, friends: [ 'xt', 'xh' ], sex: 'woman' }\n```\n\n### 六、字符串新增方法\n1、includes、startsWith、endsWith\n```javascript\nlet s = 'hello es6';\nconsole.log(s.includes('es')); // true  判断字符串是否包含某字符串\nconsole.log(s.startsWith('e')); // false 判断字符串是否以某字符串开头\nconsole.log(s.endsWith('6')); // true  判断字符串是否以某字符串结尾\n```\n\n2、repeat方法\n```javascript\nlet i = 'abc';\nconsole.log(i.repeat(3)) // abcabcabc 表示重复某字符串几次\n```\n\n3、padStart、padEnd方法\n```javascript\nlet x = 'x';\nconsole.log(x.padStart(5, 'ab')); // ababx  在x字符串前面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padStart(4, 'ab')); // abax   在x字符串前面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(5, 'ab')); // xabab    在x字符串后面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(4, 'ab')); // xaba     在x字符串后面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\n```\n\n4、replaceAll方法\n```javascript\nlet o = 'abbcc';\nlet o1 = o.replaceAll('b', '_');\nconsole.log(o) // 'abbcc'\nconsole.log(o1) // 'a__cc'\n```\n\n### 七、箭头函数\n__1、箭头函数中this是在定义是绑定的，而不是调用时。（箭头函数的this值继承自外围作用域。运行时它会首先到它的父级作用域找，如果父级作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向）__\n```javascript\nvar a1 = 'ppp'\n\nvar obj1 = {\n    a1: 'bbb',\n    b2: this.a1,\n    f: function () {\n        console.log(this.a1)\n    },\n    d: () => {\n        console.log(this.a1)\n    }\n}\nconsole.log(obj1.b2) // ‘ppp’\nobj1.f(); // ‘bbb’\nobj1.d(); // 'ppp'\n```\n__2、箭头函数不能作为构造函数，不能使用new__  \n```javascript\n//构造函数如下：\nfunction Person(p){\n    this.name = p.name;\n}\n//如果用箭头函数作为构造函数，则如下\nvar Person = (p) => {\n    this.name = p.name;\n}\n```\n由于this必须是实例对象，而箭头函数是没有实例的，此处的this指向window，不能产生person的实例，自相矛盾  \n\n__3、箭头函数没有arguments、caller、callee__  \n箭头函数本身没有arguments,如果箭头函数在一个function内部，它会将外部函数的arguments拿过来使用。  \n箭头函数中要想接手不定参数，应该使用rest参数...解决\n```javascript\nlet B = (b)=>{\n  console.log(arguments);\n}\nB(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined\n\nlet C = (...c) => {\n  console.log(c);\n}\nC(3,82,32,11323);  // [3, 82, 32, 11323]\n```\n\n__4、箭头函数通过call和apply调用，不会改变this指向，只会传入参数__  \n```javascript\nvar name = 'lw'\nlet a1 = {\n    name: 'zs',\n    f: function (age) {\n        console.log(`我是${this.name},年龄${age}`)\n    },\n    d: (age) => {\n        console.log(`我是${this.name},年龄${age}`)\n    }\n}\n\nlet a2 = {\n    name: 'ls'\n}\n\na1.f(15); // 我是zs,年龄15\na1.d(15); // 我是lw,年龄15\na1.f.call(a2, 18); // 我是ls,年龄18\na1.d.call(a2, 18); // 我是lw,年龄18\n```\n\n__5、箭头函数没有原型属性__  \n```javascript\nvar A = function () {\n    return 2\n}\n\nvar B = () => {\n    return 3\n}\n\nconsole.log(A.prototype) // {constructor: ƒ}\nconsole.log(B.prototype) // undefined\n```\n\n__6、箭头函数ES6 class中声明的方法为实例方法，不是原型方法__  \n```javascript\nclass Super {\n    sayHello() {\n        console.log('hello')\n    }\n    sayWorld = () => {\n        console.log('world')\n    }\n}\nconst a = new Super();\nconst b = new Super();\n\nconsole.log(a.sayHello === b.sayHello) // true sayHello是Super.prototype上的方法，所有实例共享同一个方法，所以为true\nconsole.log(a.sayWorld === b.sayWorld) // false sayWorld是各自实例上的方法，所以每个方法不一样，估为false\nconsole.log(Super.prototype)\n\n```\n\n### 八、Proxy代理\n```javascript\nconst person = {\n    name: 'zs',\n    age: 18\n}\n\nconst personProxy = new Proxy(person, {\n    get(target, key, receiver) {\n        console.log(target, key, receiver)\n        return key in target ? target[key] : 'default';\n    },\n    set(target, key, value, receiver) {\n        console.log(target, key, value, receiver)\n        if (typeof value !== 'number') {\n            throw new TypeError('age need number');\n        }\n        target[key] = value;\n    }\n})\n\nconsole.log(personProxy.name) // {name: 'zs', age: 18}  'name'  Proxy{name: 'zs', age: 18}  zs\nconsole.log(personProxy.sex) // {name: 'zs', age: 18}  'sex'  Proxy{name: 'zs', age: 18}  default\nconsole.log(personProxy.age) // {name: 'zs', age: 18}  'age'  Proxy{name: 'zs', age: 18}  18\npersonProxy.age = 19  // // {name: 'zs', age: 18}  'age'  19  Proxy{name: 'zs', age: 18}  \npersonProxy.age = '20';  // {name: 'zs', age: 19}  'age'  '20'  Proxy{name: 'zs', age: 19}  报错Uncaught TypeError: age need number\n\n\nconst list = [1,2,3]\nconst listProxy = new Proxy(list, {\n    get(target, key, receiver) {\n        console.log('get')\n        return target[key]\n    },\n    set(target, key, value, receiver) {\n        console.log('set')\n        target[key] = value;\n        return true; // 表示设置成功\n    },\n    deleteProperty(target, key) {\n        console.log('delete')\n    }\n})\nconsole.log(listProxy[0]);\nconsole.log(listProxy.push(100));\nconsole.log(listProxy.shift())\nlistProxy[0] = 999\n```\nProxy代理 vs Object.defineProperty()  \n1、Object.defineProperty()只能监听对象的读写操作  而Proxy能监听更多的操作，比如deleteProperty、has等  \n2、Proxy能监听数组的操作  \n3、Proxy是以非侵入式的监管对象，不会对原对象进行任何的操作\n\n### 八、Reflect\nReflect提供了对象统一操作API\n```javascript\nconst person = {\n    name: 'zs',\n    age: 19\n}\nfunction Person() {\n    this.name = 'ls';\n    this.age = 20;\n}\nPerson.prototype.say = function () {\n    console.log('hello world')\n}\nconst p = new Person();\nconsole.log(Reflect.get(person, 'name'))  // zs\nconsole.log(Reflect.ownKeys(person)) // ['name', 'age']  只能访问对象上的属性，不能访问原型上的\nconsole.log(Reflect.ownKeys(p)) // ['name', 'age']\nconsole.log(Reflect.set(person, 'age', 20)) // true 表示操作成功\nconsole.log(Reflect.has(person, 'sex')) // false\nconsole.log(Reflect.deleteProperty(person, 'age')) // true 表示操作成功\n```\n\n### 九、set和map\n1、set数据结构 返回一个没有重复值的集合  \n```javascript\nconst s = new Set()\ns.add('a').add('b').add(3).add(4).add(5).add(5);\n\ns.forEach(i => console.log(i))  // a b 3 4 5\n\nfor (let i of s) {\n    console.log(i) // a b 3 4 5\n}\n\nconsole.log(s) // Set(5){'a', 'b', 3, 4, 5}\nconsole.log(s.size) // 5\nconsole.log(s.has('a')) // true\nconsole.log(s.has(100)) // false\nconsole.log(s.delete(5)) // true 表示操作成功 删除5\nconsole.log(s) // Set(4){'a', 'b', 3, 4}\nconsole.log(s.clear()) // undefined\nconsole.log(s) // Set(0){size: 0}\n\n// 数组去重\nconst array = [1,3,2,3,1,5,6,1,5];\nconst newArr = [...new Set(array)]\nconsole.log(newArr) // [1, 3, 2, 5, 6]\n```\n2、map数据结构 键值对数据结构\n```javascript\n// 传统键值对象，会将key不是字符串的值转变为字符串\nconst obj = {};\nobj[123] = 'value';\nobj[true] = 'value';\nobj[{name:'zs'}] = 'value';\nobj['zzh'] = 'value';\nconsole.log(Reflect.ownKeys(obj)) // ['123', 'true', '[object Object]', 'zzh']\n\n// map对象，会将key的数据类型保留\nconst t = {\n    name: 'kzz'\n}\nconst m = new Map();\nm.set(t, 'a');\nm.set(true, 'b');\nm.set(123, 'c');\nconsole.log(m); // {{…} => 'a', true => 'b', 123 => 'c'}\nconsole.log(m.get(t)) // a\nconsole.log(m.get(true)) // b\nm.forEach((i, k) => console.log(i, k)) // a {name: 'kzz'}  b true  c 123\n```\n\n### 十、class\n1、ES6的类，完全可以看成构造函数的另外一种写法  \n```javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor  // true\n```\n2、类的方法都是定义在prototype对象上（箭头函数方法是定义在实例上）  \n3、类的内部定义的方法，都是不可枚举的,这和ES5的行为不一致\n```javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n4、constructor方法是类的默认方法，通过new对象创建实例时，会自动调用该方法。一个类必定有constructor方法，如果没有显式定义，一个空的constructor方法会默认被添加  \n```javascript\nclass Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n5、constructor方法默认返回实例对象（this）,完全可以指定返回另外一个对象\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n// constructor返回一个全新的对象，结果导致实例对象不是Foo的实例\n```\n6、静态方法  \n类相当于实例的原型，所有在类中定义的方法，都会被实例继承，如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n如果静态方法中包含关键字this,这个this指向的是类而不是实例\n```javascript\nclass Foo {\n  static bar() {\n    this.baz();\n  }\n  static baz() {\n    console.log('hello');\n  }\n  baz() {\n    console.log('world');\n  }\n}\n\nFoo.bar() // hello\n```\n父类的静态方法能被子类继承\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod() // 'hello'\n```\n\n7、静态属性  \n使用static 声明的属性就是静态属性，由类调用\n\n### 十一、类的继承\n1、class可以通过extends关键字实现继承\n```javascript\nclass Point {\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n上述代码中，constructor和toString方法之后，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的实例  \n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。  \n```javascript\nclass Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); //ReferenceError\n```\nES6的继承机制实质上是将父类的实例对象的属性和方法，加在this上面，所以必须先调用super方法，然后再用子类的构造函数修改this  \n如果子类没有定义constructor方法，这个方法会被默认添加\n```javascript\nclass ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n```\n在子类的constructor方法没有调用super之前，就使用this关键字，结果报错\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n2、super关键字\nsuper关键字既可以当做函数使用，也可以当做对象使用  \n\n第一种情况，super作为构造函数使用，代表父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数\n```javascript\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n注意，super虽然代表了父类的构造函数，但是返回是子类B的实例，即super内部的this指向的是B的实例，因此super()相当于A.prototype.constructor.call(this)。  \n\n第二种情况，super作为对象，在普通方法中指向父类的原型对象，在静态方法中，指向父类  \n```javascript\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n```\n上面代码中，子类B当中的super.p()，就是将super当做一个对象。这是super在普通方法中，指向A.prototype，所以super.p()相当于A.prototype.p()。  \n\n注意：这里的super指向的是父类的原型对象，所以定义在父类实例上的方法和属性，是无法通过super调用的\n```javascript\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\nES6规定，在子类的普通方法中通过super调用父类的方法时，方法内部this指向当前子类的实例  \n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。  \n\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。  \n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n\n如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\n```javascript\nclass Parent {\n  static myMethod(msg) {\n    console.log('static', msg);\n  }\n\n  myMethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass Child extends Parent {\n  static myMethod(msg) {\n    super.myMethod(msg);\n  }\n\n  myMethod(msg) {\n    super.myMethod(msg);\n  }\n}\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n```\n\n在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。  \n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n```","source":"_posts/es6.md","raw":"---\ntitle: es6\ndate: 2022-01-13 16:27:11\ntags:\n- es6\n- js\ncover: https://s4.ax1x.com/2022/01/13/7Qj0kq.png\n---\n\n## es6基本知识\n\n### 一、let/const\n1、const/let都是用来声明变量，不可重复声明，具有块级作用域。存在暂时性死区，不存在变量提升。const用来声明常量。  \n\n### 二、symbol\n1、symbol是一个全新的数据类型，表示独一无二的值，对象可以以symbol类型作为键  \n2、现在主要用于声明对象的私有属性  \n__示例__\n```javascript\nconsole.log(Symbol() === Symbol()); // false\nconsole.log(Symbol('foo') === Symbol('foo')); // false\nconsole.log(typeof Symbol()); // symbol\nconsole.log(Symbol('foo')); // Symbol('foo')\n\nconst obj = {\n    [Symbol('name')]: '张三'\n}\nconsole.log(obj) // {[Symbol(name)]:'张三'}\nconsole.log(obj[Symbol('name')]) // undefined\n\nlet name = Symbol('name');\nconst Person = {\n    [name]: 'zhangsan',\n    age: 15,\n    say() {\n        console.log('i am ' + this[name])\n    }\n}\n\nconsole.log(Person[Symbol('name')]) // undefined 故symbol一般用于定义私有属性 ，外部访问不到\nPerson.say() // i am zhangsan\n\nconsole.log(Symbol.for('true') === Symbol.for(true)) // true  Symbol.for方法是根据字符串参数作比较是否相等\n\nconst objj = {\n    [Symbol('name')]: 'lisi',\n    age: 15\n}\n\nfor (let k in objj) {\n    console.log(k); // age  for方法无法访问到Symbol属性\n}\n\nconsole.log(Object.keys(objj)) // ['age']  Object.keys也无法访问Symbol属性\n\nconsole.log(JSON.stringify(objj)) // {'age':15}\n\nconsole.log(Object.getOwnPropertySymbols(objj)) // [Symbol(name)] 能获取到Symbol属性\n\nconsole.log(Reflect.ownKeys(objj)) // ['age', Symbol(name)] 能获取到Symbol属性\n```\n\n### 三、对象和数组的解构\n__示例__  \n1、数组的解构\n```javascript\n// 传统方法\nconst arr = [1, 2, 3];\nlet fir = arr[0];\nlet sec = arr[1];\nlet thr = arr[2];\nconsole.log(fir, sec, thr) // 1,2,3\n\n//es6新增解构方法\nlet [f, s, t] = arr;\nconsole.log(f,s,t) // 1,2,3\n\nlet [f, ...rest] = arr;\nconsole.log(f, rest) // 1, [2, 3]\n\nlet [f, a, b, c, d] = arr;\nconsole.log(f,a,b,c,d) // 1,2,3,undefined，undefined\n\nlet [,,a,b,c] = arr;\nconsole.log(a,b,c) // 3 undefined undefined\n```\n2、对象的解构\n```javascript\nconst obj = {\n    name: 'zhangsan',\n    age: 15\n}\n\nconst {name, age} = obj;\nconsole.log(name, age); // zhangsan 15\n\nconst name1 = 'lisi';\n\nconst {name: name2, age, sex='man'} = obj;\n\nconsole.log(name1, name2, age, sex); // lisi zhangsan 15 man\n```\n\n### 四、模板字符串\n__示例__  \n```javascript\nlet str = `我是模板字符串 我能\n直接换行`\nconsole.log(str);\n//我是模板字符串 我能\n//直接换行\n\nconst {name, age, sex} = {\n    name: 'zhangsan',\n    age: 18,\n    sex: 'man'\n}\n\nlet s = `大家好，我是${name}, 今年${age}, ${1+20}，${Math.random()}`\nconsole.log(s) // 大家好，我是zhangsan, 今年18, 21，0.45371632552390184\n\nfunction tag(str, sex, name, age) {\n    console.log(str, sex, name, age)\n}\n//tag方法使用于模板字符串，第一个参数返回以${}拆分的数组，剩余的参数与目标字符穿的顺序一一对应\nconst a = tag`大家好，我是${sex}，姓名：${name}, 年龄${age}, 哈哈`; // [ '大家好， 我是', '，姓名：', ', 年龄', ',哈哈' ] 'man' 'zhangsan' 18\nconsole.log(a); // undefined\n```\n\n### 五、扩展运算符(...)  \n对象中的扩展运算符(...)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中,属于浅拷贝  \n__示例__  \n```javascript\nconst a = {\n    name: 'zhangsan',\n    age: 18,\n    friends: ['xm', 'xh']\n}\nconst b = {\n    name: 'lisi',\n    sex: 'woman'\n}\n\nconst c = {\n    ...a,\n    ...b\n}\nconsole.log(c)  // { name: 'lisi', age: 18, friends: [ 'xm', 'xh' ], sex: 'woman' }\n\n// c引用数据类型发生改变，a也会随之改变，证明扩展运算符是浅拷贝\nc.friends[0] = 'xt';\nc.age = 20;\nconsole.log(a) // { name: 'zhangsan', age: 18, friends: [ 'xt', 'xh' ] }\nconsole.log(c) // { name: 'lisi', age: 20, friends: [ 'xt', 'xh' ], sex: 'woman' }\n```\n\n### 六、字符串新增方法\n1、includes、startsWith、endsWith\n```javascript\nlet s = 'hello es6';\nconsole.log(s.includes('es')); // true  判断字符串是否包含某字符串\nconsole.log(s.startsWith('e')); // false 判断字符串是否以某字符串开头\nconsole.log(s.endsWith('6')); // true  判断字符串是否以某字符串结尾\n```\n\n2、repeat方法\n```javascript\nlet i = 'abc';\nconsole.log(i.repeat(3)) // abcabcabc 表示重复某字符串几次\n```\n\n3、padStart、padEnd方法\n```javascript\nlet x = 'x';\nconsole.log(x.padStart(5, 'ab')); // ababx  在x字符串前面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padStart(4, 'ab')); // abax   在x字符串前面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(5, 'ab')); // xabab    在x字符串后面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(4, 'ab')); // xaba     在x字符串后面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\n```\n\n4、replaceAll方法\n```javascript\nlet o = 'abbcc';\nlet o1 = o.replaceAll('b', '_');\nconsole.log(o) // 'abbcc'\nconsole.log(o1) // 'a__cc'\n```\n\n### 七、箭头函数\n__1、箭头函数中this是在定义是绑定的，而不是调用时。（箭头函数的this值继承自外围作用域。运行时它会首先到它的父级作用域找，如果父级作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向）__\n```javascript\nvar a1 = 'ppp'\n\nvar obj1 = {\n    a1: 'bbb',\n    b2: this.a1,\n    f: function () {\n        console.log(this.a1)\n    },\n    d: () => {\n        console.log(this.a1)\n    }\n}\nconsole.log(obj1.b2) // ‘ppp’\nobj1.f(); // ‘bbb’\nobj1.d(); // 'ppp'\n```\n__2、箭头函数不能作为构造函数，不能使用new__  \n```javascript\n//构造函数如下：\nfunction Person(p){\n    this.name = p.name;\n}\n//如果用箭头函数作为构造函数，则如下\nvar Person = (p) => {\n    this.name = p.name;\n}\n```\n由于this必须是实例对象，而箭头函数是没有实例的，此处的this指向window，不能产生person的实例，自相矛盾  \n\n__3、箭头函数没有arguments、caller、callee__  \n箭头函数本身没有arguments,如果箭头函数在一个function内部，它会将外部函数的arguments拿过来使用。  \n箭头函数中要想接手不定参数，应该使用rest参数...解决\n```javascript\nlet B = (b)=>{\n  console.log(arguments);\n}\nB(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined\n\nlet C = (...c) => {\n  console.log(c);\n}\nC(3,82,32,11323);  // [3, 82, 32, 11323]\n```\n\n__4、箭头函数通过call和apply调用，不会改变this指向，只会传入参数__  \n```javascript\nvar name = 'lw'\nlet a1 = {\n    name: 'zs',\n    f: function (age) {\n        console.log(`我是${this.name},年龄${age}`)\n    },\n    d: (age) => {\n        console.log(`我是${this.name},年龄${age}`)\n    }\n}\n\nlet a2 = {\n    name: 'ls'\n}\n\na1.f(15); // 我是zs,年龄15\na1.d(15); // 我是lw,年龄15\na1.f.call(a2, 18); // 我是ls,年龄18\na1.d.call(a2, 18); // 我是lw,年龄18\n```\n\n__5、箭头函数没有原型属性__  \n```javascript\nvar A = function () {\n    return 2\n}\n\nvar B = () => {\n    return 3\n}\n\nconsole.log(A.prototype) // {constructor: ƒ}\nconsole.log(B.prototype) // undefined\n```\n\n__6、箭头函数ES6 class中声明的方法为实例方法，不是原型方法__  \n```javascript\nclass Super {\n    sayHello() {\n        console.log('hello')\n    }\n    sayWorld = () => {\n        console.log('world')\n    }\n}\nconst a = new Super();\nconst b = new Super();\n\nconsole.log(a.sayHello === b.sayHello) // true sayHello是Super.prototype上的方法，所有实例共享同一个方法，所以为true\nconsole.log(a.sayWorld === b.sayWorld) // false sayWorld是各自实例上的方法，所以每个方法不一样，估为false\nconsole.log(Super.prototype)\n\n```\n\n### 八、Proxy代理\n```javascript\nconst person = {\n    name: 'zs',\n    age: 18\n}\n\nconst personProxy = new Proxy(person, {\n    get(target, key, receiver) {\n        console.log(target, key, receiver)\n        return key in target ? target[key] : 'default';\n    },\n    set(target, key, value, receiver) {\n        console.log(target, key, value, receiver)\n        if (typeof value !== 'number') {\n            throw new TypeError('age need number');\n        }\n        target[key] = value;\n    }\n})\n\nconsole.log(personProxy.name) // {name: 'zs', age: 18}  'name'  Proxy{name: 'zs', age: 18}  zs\nconsole.log(personProxy.sex) // {name: 'zs', age: 18}  'sex'  Proxy{name: 'zs', age: 18}  default\nconsole.log(personProxy.age) // {name: 'zs', age: 18}  'age'  Proxy{name: 'zs', age: 18}  18\npersonProxy.age = 19  // // {name: 'zs', age: 18}  'age'  19  Proxy{name: 'zs', age: 18}  \npersonProxy.age = '20';  // {name: 'zs', age: 19}  'age'  '20'  Proxy{name: 'zs', age: 19}  报错Uncaught TypeError: age need number\n\n\nconst list = [1,2,3]\nconst listProxy = new Proxy(list, {\n    get(target, key, receiver) {\n        console.log('get')\n        return target[key]\n    },\n    set(target, key, value, receiver) {\n        console.log('set')\n        target[key] = value;\n        return true; // 表示设置成功\n    },\n    deleteProperty(target, key) {\n        console.log('delete')\n    }\n})\nconsole.log(listProxy[0]);\nconsole.log(listProxy.push(100));\nconsole.log(listProxy.shift())\nlistProxy[0] = 999\n```\nProxy代理 vs Object.defineProperty()  \n1、Object.defineProperty()只能监听对象的读写操作  而Proxy能监听更多的操作，比如deleteProperty、has等  \n2、Proxy能监听数组的操作  \n3、Proxy是以非侵入式的监管对象，不会对原对象进行任何的操作\n\n### 八、Reflect\nReflect提供了对象统一操作API\n```javascript\nconst person = {\n    name: 'zs',\n    age: 19\n}\nfunction Person() {\n    this.name = 'ls';\n    this.age = 20;\n}\nPerson.prototype.say = function () {\n    console.log('hello world')\n}\nconst p = new Person();\nconsole.log(Reflect.get(person, 'name'))  // zs\nconsole.log(Reflect.ownKeys(person)) // ['name', 'age']  只能访问对象上的属性，不能访问原型上的\nconsole.log(Reflect.ownKeys(p)) // ['name', 'age']\nconsole.log(Reflect.set(person, 'age', 20)) // true 表示操作成功\nconsole.log(Reflect.has(person, 'sex')) // false\nconsole.log(Reflect.deleteProperty(person, 'age')) // true 表示操作成功\n```\n\n### 九、set和map\n1、set数据结构 返回一个没有重复值的集合  \n```javascript\nconst s = new Set()\ns.add('a').add('b').add(3).add(4).add(5).add(5);\n\ns.forEach(i => console.log(i))  // a b 3 4 5\n\nfor (let i of s) {\n    console.log(i) // a b 3 4 5\n}\n\nconsole.log(s) // Set(5){'a', 'b', 3, 4, 5}\nconsole.log(s.size) // 5\nconsole.log(s.has('a')) // true\nconsole.log(s.has(100)) // false\nconsole.log(s.delete(5)) // true 表示操作成功 删除5\nconsole.log(s) // Set(4){'a', 'b', 3, 4}\nconsole.log(s.clear()) // undefined\nconsole.log(s) // Set(0){size: 0}\n\n// 数组去重\nconst array = [1,3,2,3,1,5,6,1,5];\nconst newArr = [...new Set(array)]\nconsole.log(newArr) // [1, 3, 2, 5, 6]\n```\n2、map数据结构 键值对数据结构\n```javascript\n// 传统键值对象，会将key不是字符串的值转变为字符串\nconst obj = {};\nobj[123] = 'value';\nobj[true] = 'value';\nobj[{name:'zs'}] = 'value';\nobj['zzh'] = 'value';\nconsole.log(Reflect.ownKeys(obj)) // ['123', 'true', '[object Object]', 'zzh']\n\n// map对象，会将key的数据类型保留\nconst t = {\n    name: 'kzz'\n}\nconst m = new Map();\nm.set(t, 'a');\nm.set(true, 'b');\nm.set(123, 'c');\nconsole.log(m); // {{…} => 'a', true => 'b', 123 => 'c'}\nconsole.log(m.get(t)) // a\nconsole.log(m.get(true)) // b\nm.forEach((i, k) => console.log(i, k)) // a {name: 'kzz'}  b true  c 123\n```\n\n### 十、class\n1、ES6的类，完全可以看成构造函数的另外一种写法  \n```javascript\nclass Point {\n  // ...\n}\n\ntypeof Point // \"function\"\nPoint === Point.prototype.constructor  // true\n```\n2、类的方法都是定义在prototype对象上（箭头函数方法是定义在实例上）  \n3、类的内部定义的方法，都是不可枚举的,这和ES5的行为不一致\n```javascript\nclass Point {\n  constructor(x, y) {\n    // ...\n  }\n\n  toString() {\n    // ...\n  }\n}\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [\"constructor\",\"toString\"]\n```\n4、constructor方法是类的默认方法，通过new对象创建实例时，会自动调用该方法。一个类必定有constructor方法，如果没有显式定义，一个空的constructor方法会默认被添加  \n```javascript\nclass Point {\n}\n\n// 等同于\nclass Point {\n  constructor() {}\n}\n```\n5、constructor方法默认返回实例对象（this）,完全可以指定返回另外一个对象\n```javascript\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n// constructor返回一个全新的对象，结果导致实例对象不是Foo的实例\n```\n6、静态方法  \n类相当于实例的原型，所有在类中定义的方法，都会被实例继承，如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n如果静态方法中包含关键字this,这个this指向的是类而不是实例\n```javascript\nclass Foo {\n  static bar() {\n    this.baz();\n  }\n  static baz() {\n    console.log('hello');\n  }\n  baz() {\n    console.log('world');\n  }\n}\n\nFoo.bar() // hello\n```\n父类的静态方法能被子类继承\n```javascript\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nclass Bar extends Foo {\n}\n\nBar.classMethod() // 'hello'\n```\n\n7、静态属性  \n使用static 声明的属性就是静态属性，由类调用\n\n### 十一、类的继承\n1、class可以通过extends关键字实现继承\n```javascript\nclass Point {\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n上述代码中，constructor和toString方法之后，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的实例  \n子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。  \n```javascript\nclass Point { /* ... */ }\n\nclass ColorPoint extends Point {\n  constructor() {\n  }\n}\n\nlet cp = new ColorPoint(); //ReferenceError\n```\nES6的继承机制实质上是将父类的实例对象的属性和方法，加在this上面，所以必须先调用super方法，然后再用子类的构造函数修改this  \n如果子类没有定义constructor方法，这个方法会被默认添加\n```javascript\nclass ColorPoint extends Point {\n}\n\n// 等同于\nclass ColorPoint extends Point {\n  constructor(...args) {\n    super(...args);\n  }\n}\n```\n在子类的constructor方法没有调用super之前，就使用this关键字，结果报错\n```javascript\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nclass ColorPoint extends Point {\n  constructor(x, y, color) {\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  }\n}\n```\n\n2、super关键字\nsuper关键字既可以当做函数使用，也可以当做对象使用  \n\n第一种情况，super作为构造函数使用，代表父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数\n```javascript\nclass A {}\n\nclass B extends A {\n  constructor() {\n    super();\n  }\n}\n```\n注意，super虽然代表了父类的构造函数，但是返回是子类B的实例，即super内部的this指向的是B的实例，因此super()相当于A.prototype.constructor.call(this)。  \n\n第二种情况，super作为对象，在普通方法中指向父类的原型对象，在静态方法中，指向父类  \n```javascript\nclass A {\n  p() {\n    return 2;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    console.log(super.p()); // 2\n  }\n}\n\nlet b = new B();\n```\n上面代码中，子类B当中的super.p()，就是将super当做一个对象。这是super在普通方法中，指向A.prototype，所以super.p()相当于A.prototype.p()。  \n\n注意：这里的super指向的是父类的原型对象，所以定义在父类实例上的方法和属性，是无法通过super调用的\n```javascript\nclass A {\n  constructor() {\n    this.p = 2;\n  }\n}\n\nclass B extends A {\n  get m() {\n    return super.p;\n  }\n}\n\nlet b = new B();\nb.m // undefined\n```\n\nES6规定，在子类的普通方法中通过super调用父类的方法时，方法内部this指向当前子类的实例  \n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  m() {\n    super.print();\n  }\n}\n\nlet b = new B();\nb.m() // 2\n```\n上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。  \n\n由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。  \n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  }\n}\n\nlet b = new B();\n```\n上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。\n\n如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。\n```javascript\nclass Parent {\n  static myMethod(msg) {\n    console.log('static', msg);\n  }\n\n  myMethod(msg) {\n    console.log('instance', msg);\n  }\n}\n\nclass Child extends Parent {\n  static myMethod(msg) {\n    super.myMethod(msg);\n  }\n\n  myMethod(msg) {\n    super.myMethod(msg);\n  }\n}\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n```\n\n在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。  \n```javascript\nclass A {\n  constructor() {\n    this.x = 1;\n  }\n  static print() {\n    console.log(this.x);\n  }\n}\n\nclass B extends A {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n  static m() {\n    super.print();\n  }\n}\n\nB.x = 3;\nB.m() // 3\n```","slug":"es6","published":1,"updated":"2022-01-24T07:01:57.127Z","_id":"ckycpspqf00006sv48i763yh4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"es6基本知识\"><a href=\"#es6基本知识\" class=\"headerlink\" title=\"es6基本知识\"></a>es6基本知识</h2><h3 id=\"一、let-const\"><a href=\"#一、let-const\" class=\"headerlink\" title=\"一、let/const\"></a>一、let/const</h3><p>1、const/let都是用来声明变量，不可重复声明，具有块级作用域。存在暂时性死区，不存在变量提升。const用来声明常量。  </p>\n<h3 id=\"二、symbol\"><a href=\"#二、symbol\" class=\"headerlink\" title=\"二、symbol\"></a>二、symbol</h3><p>1、symbol是一个全新的数据类型，表示独一无二的值，对象可以以symbol类型作为键<br>2、现在主要用于声明对象的私有属性<br><strong>示例</strong></p>\n<pre><code class=\"javascript\">console.log(Symbol() === Symbol()); // false\nconsole.log(Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;)); // false\nconsole.log(typeof Symbol()); // symbol\nconsole.log(Symbol(&#39;foo&#39;)); // Symbol(&#39;foo&#39;)\n\nconst obj = &#123;\n    [Symbol(&#39;name&#39;)]: &#39;张三&#39;\n&#125;\nconsole.log(obj) // &#123;[Symbol(name)]:&#39;张三&#39;&#125;\nconsole.log(obj[Symbol(&#39;name&#39;)]) // undefined\n\nlet name = Symbol(&#39;name&#39;);\nconst Person = &#123;\n    [name]: &#39;zhangsan&#39;,\n    age: 15,\n    say() &#123;\n        console.log(&#39;i am &#39; + this[name])\n    &#125;\n&#125;\n\nconsole.log(Person[Symbol(&#39;name&#39;)]) // undefined 故symbol一般用于定义私有属性 ，外部访问不到\nPerson.say() // i am zhangsan\n\nconsole.log(Symbol.for(&#39;true&#39;) === Symbol.for(true)) // true  Symbol.for方法是根据字符串参数作比较是否相等\n\nconst objj = &#123;\n    [Symbol(&#39;name&#39;)]: &#39;lisi&#39;,\n    age: 15\n&#125;\n\nfor (let k in objj) &#123;\n    console.log(k); // age  for方法无法访问到Symbol属性\n&#125;\n\nconsole.log(Object.keys(objj)) // [&#39;age&#39;]  Object.keys也无法访问Symbol属性\n\nconsole.log(JSON.stringify(objj)) // &#123;&#39;age&#39;:15&#125;\n\nconsole.log(Object.getOwnPropertySymbols(objj)) // [Symbol(name)] 能获取到Symbol属性\n\nconsole.log(Reflect.ownKeys(objj)) // [&#39;age&#39;, Symbol(name)] 能获取到Symbol属性\n</code></pre>\n<h3 id=\"三、对象和数组的解构\"><a href=\"#三、对象和数组的解构\" class=\"headerlink\" title=\"三、对象和数组的解构\"></a>三、对象和数组的解构</h3><p><strong>示例</strong><br>1、数组的解构</p>\n<pre><code class=\"javascript\">// 传统方法\nconst arr = [1, 2, 3];\nlet fir = arr[0];\nlet sec = arr[1];\nlet thr = arr[2];\nconsole.log(fir, sec, thr) // 1,2,3\n\n//es6新增解构方法\nlet [f, s, t] = arr;\nconsole.log(f,s,t) // 1,2,3\n\nlet [f, ...rest] = arr;\nconsole.log(f, rest) // 1, [2, 3]\n\nlet [f, a, b, c, d] = arr;\nconsole.log(f,a,b,c,d) // 1,2,3,undefined，undefined\n\nlet [,,a,b,c] = arr;\nconsole.log(a,b,c) // 3 undefined undefined\n</code></pre>\n<p>2、对象的解构</p>\n<pre><code class=\"javascript\">const obj = &#123;\n    name: &#39;zhangsan&#39;,\n    age: 15\n&#125;\n\nconst &#123;name, age&#125; = obj;\nconsole.log(name, age); // zhangsan 15\n\nconst name1 = &#39;lisi&#39;;\n\nconst &#123;name: name2, age, sex=&#39;man&#39;&#125; = obj;\n\nconsole.log(name1, name2, age, sex); // lisi zhangsan 15 man\n</code></pre>\n<h3 id=\"四、模板字符串\"><a href=\"#四、模板字符串\" class=\"headerlink\" title=\"四、模板字符串\"></a>四、模板字符串</h3><p><strong>示例</strong>  </p>\n<pre><code class=\"javascript\">let str = `我是模板字符串 我能\n直接换行`\nconsole.log(str);\n//我是模板字符串 我能\n//直接换行\n\nconst &#123;name, age, sex&#125; = &#123;\n    name: &#39;zhangsan&#39;,\n    age: 18,\n    sex: &#39;man&#39;\n&#125;\n\nlet s = `大家好，我是$&#123;name&#125;, 今年$&#123;age&#125;, $&#123;1+20&#125;，$&#123;Math.random()&#125;`\nconsole.log(s) // 大家好，我是zhangsan, 今年18, 21，0.45371632552390184\n\nfunction tag(str, sex, name, age) &#123;\n    console.log(str, sex, name, age)\n&#125;\n//tag方法使用于模板字符串，第一个参数返回以$&#123;&#125;拆分的数组，剩余的参数与目标字符穿的顺序一一对应\nconst a = tag`大家好，我是$&#123;sex&#125;，姓名：$&#123;name&#125;, 年龄$&#123;age&#125;, 哈哈`; // [ &#39;大家好， 我是&#39;, &#39;，姓名：&#39;, &#39;, 年龄&#39;, &#39;,哈哈&#39; ] &#39;man&#39; &#39;zhangsan&#39; 18\nconsole.log(a); // undefined\n</code></pre>\n<h3 id=\"五、扩展运算符-…\"><a href=\"#五、扩展运算符-…\" class=\"headerlink\" title=\"五、扩展运算符(…)\"></a>五、扩展运算符(…)</h3><p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中,属于浅拷贝<br><strong>示例</strong>  </p>\n<pre><code class=\"javascript\">const a = &#123;\n    name: &#39;zhangsan&#39;,\n    age: 18,\n    friends: [&#39;xm&#39;, &#39;xh&#39;]\n&#125;\nconst b = &#123;\n    name: &#39;lisi&#39;,\n    sex: &#39;woman&#39;\n&#125;\n\nconst c = &#123;\n    ...a,\n    ...b\n&#125;\nconsole.log(c)  // &#123; name: &#39;lisi&#39;, age: 18, friends: [ &#39;xm&#39;, &#39;xh&#39; ], sex: &#39;woman&#39; &#125;\n\n// c引用数据类型发生改变，a也会随之改变，证明扩展运算符是浅拷贝\nc.friends[0] = &#39;xt&#39;;\nc.age = 20;\nconsole.log(a) // &#123; name: &#39;zhangsan&#39;, age: 18, friends: [ &#39;xt&#39;, &#39;xh&#39; ] &#125;\nconsole.log(c) // &#123; name: &#39;lisi&#39;, age: 20, friends: [ &#39;xt&#39;, &#39;xh&#39; ], sex: &#39;woman&#39; &#125;\n</code></pre>\n<h3 id=\"六、字符串新增方法\"><a href=\"#六、字符串新增方法\" class=\"headerlink\" title=\"六、字符串新增方法\"></a>六、字符串新增方法</h3><p>1、includes、startsWith、endsWith</p>\n<pre><code class=\"javascript\">let s = &#39;hello es6&#39;;\nconsole.log(s.includes(&#39;es&#39;)); // true  判断字符串是否包含某字符串\nconsole.log(s.startsWith(&#39;e&#39;)); // false 判断字符串是否以某字符串开头\nconsole.log(s.endsWith(&#39;6&#39;)); // true  判断字符串是否以某字符串结尾\n</code></pre>\n<p>2、repeat方法</p>\n<pre><code class=\"javascript\">let i = &#39;abc&#39;;\nconsole.log(i.repeat(3)) // abcabcabc 表示重复某字符串几次\n</code></pre>\n<p>3、padStart、padEnd方法</p>\n<pre><code class=\"javascript\">let x = &#39;x&#39;;\nconsole.log(x.padStart(5, &#39;ab&#39;)); // ababx  在x字符串前面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padStart(4, &#39;ab&#39;)); // abax   在x字符串前面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(5, &#39;ab&#39;)); // xabab    在x字符串后面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(4, &#39;ab&#39;)); // xaba     在x字符串后面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\n</code></pre>\n<p>4、replaceAll方法</p>\n<pre><code class=\"javascript\">let o = &#39;abbcc&#39;;\nlet o1 = o.replaceAll(&#39;b&#39;, &#39;_&#39;);\nconsole.log(o) // &#39;abbcc&#39;\nconsole.log(o1) // &#39;a__cc&#39;\n</code></pre>\n<h3 id=\"七、箭头函数\"><a href=\"#七、箭头函数\" class=\"headerlink\" title=\"七、箭头函数\"></a>七、箭头函数</h3><p><strong>1、箭头函数中this是在定义是绑定的，而不是调用时。（箭头函数的this值继承自外围作用域。运行时它会首先到它的父级作用域找，如果父级作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向）</strong></p>\n<pre><code class=\"javascript\">var a1 = &#39;ppp&#39;\n\nvar obj1 = &#123;\n    a1: &#39;bbb&#39;,\n    b2: this.a1,\n    f: function () &#123;\n        console.log(this.a1)\n    &#125;,\n    d: () =&gt; &#123;\n        console.log(this.a1)\n    &#125;\n&#125;\nconsole.log(obj1.b2) // ‘ppp’\nobj1.f(); // ‘bbb’\nobj1.d(); // &#39;ppp&#39;\n</code></pre>\n<p><strong>2、箭头函数不能作为构造函数，不能使用new</strong>  </p>\n<pre><code class=\"javascript\">//构造函数如下：\nfunction Person(p)&#123;\n    this.name = p.name;\n&#125;\n//如果用箭头函数作为构造函数，则如下\nvar Person = (p) =&gt; &#123;\n    this.name = p.name;\n&#125;\n</code></pre>\n<p>由于this必须是实例对象，而箭头函数是没有实例的，此处的this指向window，不能产生person的实例，自相矛盾  </p>\n<p><strong>3、箭头函数没有arguments、caller、callee</strong><br>箭头函数本身没有arguments,如果箭头函数在一个function内部，它会将外部函数的arguments拿过来使用。<br>箭头函数中要想接手不定参数，应该使用rest参数…解决</p>\n<pre><code class=\"javascript\">let B = (b)=&gt;&#123;\n  console.log(arguments);\n&#125;\nB(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined\n\nlet C = (...c) =&gt; &#123;\n  console.log(c);\n&#125;\nC(3,82,32,11323);  // [3, 82, 32, 11323]\n</code></pre>\n<p><strong>4、箭头函数通过call和apply调用，不会改变this指向，只会传入参数</strong>  </p>\n<pre><code class=\"javascript\">var name = &#39;lw&#39;\nlet a1 = &#123;\n    name: &#39;zs&#39;,\n    f: function (age) &#123;\n        console.log(`我是$&#123;this.name&#125;,年龄$&#123;age&#125;`)\n    &#125;,\n    d: (age) =&gt; &#123;\n        console.log(`我是$&#123;this.name&#125;,年龄$&#123;age&#125;`)\n    &#125;\n&#125;\n\nlet a2 = &#123;\n    name: &#39;ls&#39;\n&#125;\n\na1.f(15); // 我是zs,年龄15\na1.d(15); // 我是lw,年龄15\na1.f.call(a2, 18); // 我是ls,年龄18\na1.d.call(a2, 18); // 我是lw,年龄18\n</code></pre>\n<p><strong>5、箭头函数没有原型属性</strong>  </p>\n<pre><code class=\"javascript\">var A = function () &#123;\n    return 2\n&#125;\n\nvar B = () =&gt; &#123;\n    return 3\n&#125;\n\nconsole.log(A.prototype) // &#123;constructor: ƒ&#125;\nconsole.log(B.prototype) // undefined\n</code></pre>\n<p><strong>6、箭头函数ES6 class中声明的方法为实例方法，不是原型方法</strong>  </p>\n<pre><code class=\"javascript\">class Super &#123;\n    sayHello() &#123;\n        console.log(&#39;hello&#39;)\n    &#125;\n    sayWorld = () =&gt; &#123;\n        console.log(&#39;world&#39;)\n    &#125;\n&#125;\nconst a = new Super();\nconst b = new Super();\n\nconsole.log(a.sayHello === b.sayHello) // true sayHello是Super.prototype上的方法，所有实例共享同一个方法，所以为true\nconsole.log(a.sayWorld === b.sayWorld) // false sayWorld是各自实例上的方法，所以每个方法不一样，估为false\nconsole.log(Super.prototype)\n</code></pre>\n<h3 id=\"八、Proxy代理\"><a href=\"#八、Proxy代理\" class=\"headerlink\" title=\"八、Proxy代理\"></a>八、Proxy代理</h3><pre><code class=\"javascript\">const person = &#123;\n    name: &#39;zs&#39;,\n    age: 18\n&#125;\n\nconst personProxy = new Proxy(person, &#123;\n    get(target, key, receiver) &#123;\n        console.log(target, key, receiver)\n        return key in target ? target[key] : &#39;default&#39;;\n    &#125;,\n    set(target, key, value, receiver) &#123;\n        console.log(target, key, value, receiver)\n        if (typeof value !== &#39;number&#39;) &#123;\n            throw new TypeError(&#39;age need number&#39;);\n        &#125;\n        target[key] = value;\n    &#125;\n&#125;)\n\nconsole.log(personProxy.name) // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;name&#39;  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  zs\nconsole.log(personProxy.sex) // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;sex&#39;  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  default\nconsole.log(personProxy.age) // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;age&#39;  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  18\npersonProxy.age = 19  // // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;age&#39;  19  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  \npersonProxy.age = &#39;20&#39;;  // &#123;name: &#39;zs&#39;, age: 19&#125;  &#39;age&#39;  &#39;20&#39;  Proxy&#123;name: &#39;zs&#39;, age: 19&#125;  报错Uncaught TypeError: age need number\n\n\nconst list = [1,2,3]\nconst listProxy = new Proxy(list, &#123;\n    get(target, key, receiver) &#123;\n        console.log(&#39;get&#39;)\n        return target[key]\n    &#125;,\n    set(target, key, value, receiver) &#123;\n        console.log(&#39;set&#39;)\n        target[key] = value;\n        return true; // 表示设置成功\n    &#125;,\n    deleteProperty(target, key) &#123;\n        console.log(&#39;delete&#39;)\n    &#125;\n&#125;)\nconsole.log(listProxy[0]);\nconsole.log(listProxy.push(100));\nconsole.log(listProxy.shift())\nlistProxy[0] = 999\n</code></pre>\n<p>Proxy代理 vs Object.defineProperty()<br>1、Object.defineProperty()只能监听对象的读写操作  而Proxy能监听更多的操作，比如deleteProperty、has等<br>2、Proxy能监听数组的操作<br>3、Proxy是以非侵入式的监管对象，不会对原对象进行任何的操作</p>\n<h3 id=\"八、Reflect\"><a href=\"#八、Reflect\" class=\"headerlink\" title=\"八、Reflect\"></a>八、Reflect</h3><p>Reflect提供了对象统一操作API</p>\n<pre><code class=\"javascript\">const person = &#123;\n    name: &#39;zs&#39;,\n    age: 19\n&#125;\nfunction Person() &#123;\n    this.name = &#39;ls&#39;;\n    this.age = 20;\n&#125;\nPerson.prototype.say = function () &#123;\n    console.log(&#39;hello world&#39;)\n&#125;\nconst p = new Person();\nconsole.log(Reflect.get(person, &#39;name&#39;))  // zs\nconsole.log(Reflect.ownKeys(person)) // [&#39;name&#39;, &#39;age&#39;]  只能访问对象上的属性，不能访问原型上的\nconsole.log(Reflect.ownKeys(p)) // [&#39;name&#39;, &#39;age&#39;]\nconsole.log(Reflect.set(person, &#39;age&#39;, 20)) // true 表示操作成功\nconsole.log(Reflect.has(person, &#39;sex&#39;)) // false\nconsole.log(Reflect.deleteProperty(person, &#39;age&#39;)) // true 表示操作成功\n</code></pre>\n<h3 id=\"九、set和map\"><a href=\"#九、set和map\" class=\"headerlink\" title=\"九、set和map\"></a>九、set和map</h3><p>1、set数据结构 返回一个没有重复值的集合  </p>\n<pre><code class=\"javascript\">const s = new Set()\ns.add(&#39;a&#39;).add(&#39;b&#39;).add(3).add(4).add(5).add(5);\n\ns.forEach(i =&gt; console.log(i))  // a b 3 4 5\n\nfor (let i of s) &#123;\n    console.log(i) // a b 3 4 5\n&#125;\n\nconsole.log(s) // Set(5)&#123;&#39;a&#39;, &#39;b&#39;, 3, 4, 5&#125;\nconsole.log(s.size) // 5\nconsole.log(s.has(&#39;a&#39;)) // true\nconsole.log(s.has(100)) // false\nconsole.log(s.delete(5)) // true 表示操作成功 删除5\nconsole.log(s) // Set(4)&#123;&#39;a&#39;, &#39;b&#39;, 3, 4&#125;\nconsole.log(s.clear()) // undefined\nconsole.log(s) // Set(0)&#123;size: 0&#125;\n\n// 数组去重\nconst array = [1,3,2,3,1,5,6,1,5];\nconst newArr = [...new Set(array)]\nconsole.log(newArr) // [1, 3, 2, 5, 6]\n</code></pre>\n<p>2、map数据结构 键值对数据结构</p>\n<pre><code class=\"javascript\">// 传统键值对象，会将key不是字符串的值转变为字符串\nconst obj = &#123;&#125;;\nobj[123] = &#39;value&#39;;\nobj[true] = &#39;value&#39;;\nobj[&#123;name:&#39;zs&#39;&#125;] = &#39;value&#39;;\nobj[&#39;zzh&#39;] = &#39;value&#39;;\nconsole.log(Reflect.ownKeys(obj)) // [&#39;123&#39;, &#39;true&#39;, &#39;[object Object]&#39;, &#39;zzh&#39;]\n\n// map对象，会将key的数据类型保留\nconst t = &#123;\n    name: &#39;kzz&#39;\n&#125;\nconst m = new Map();\nm.set(t, &#39;a&#39;);\nm.set(true, &#39;b&#39;);\nm.set(123, &#39;c&#39;);\nconsole.log(m); // &#123;&#123;…&#125; =&gt; &#39;a&#39;, true =&gt; &#39;b&#39;, 123 =&gt; &#39;c&#39;&#125;\nconsole.log(m.get(t)) // a\nconsole.log(m.get(true)) // b\nm.forEach((i, k) =&gt; console.log(i, k)) // a &#123;name: &#39;kzz&#39;&#125;  b true  c 123\n</code></pre>\n<h3 id=\"十、class\"><a href=\"#十、class\" class=\"headerlink\" title=\"十、class\"></a>十、class</h3><p>1、ES6的类，完全可以看成构造函数的另外一种写法  </p>\n<pre><code class=\"javascript\">class Point &#123;\n  // ...\n&#125;\n\ntypeof Point // &quot;function&quot;\nPoint === Point.prototype.constructor  // true\n</code></pre>\n<p>2、类的方法都是定义在prototype对象上（箭头函数方法是定义在实例上）<br>3、类的内部定义的方法，都是不可枚举的,这和ES5的行为不一致</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n&#125;\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [&quot;constructor&quot;,&quot;toString&quot;]\n</code></pre>\n<p>4、constructor方法是类的默认方法，通过new对象创建实例时，会自动调用该方法。一个类必定有constructor方法，如果没有显式定义，一个空的constructor方法会默认被添加  </p>\n<pre><code class=\"javascript\">class Point &#123;\n&#125;\n\n// 等同于\nclass Point &#123;\n  constructor() &#123;&#125;\n&#125;\n</code></pre>\n<p>5、constructor方法默认返回实例对象（this）,完全可以指定返回另外一个对象</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  constructor() &#123;\n    return Object.create(null);\n  &#125;\n&#125;\n\nnew Foo() instanceof Foo\n// false\n// constructor返回一个全新的对象，结果导致实例对象不是Foo的实例\n</code></pre>\n<p>6、静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承，如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nFoo.classMethod() // &#39;hello&#39;\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n</code></pre>\n<p>如果静态方法中包含关键字this,这个this指向的是类而不是实例</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static bar() &#123;\n    this.baz();\n  &#125;\n  static baz() &#123;\n    console.log(&#39;hello&#39;);\n  &#125;\n  baz() &#123;\n    console.log(&#39;world&#39;);\n  &#125;\n&#125;\n\nFoo.bar() // hello\n</code></pre>\n<p>父类的静态方法能被子类继承</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nclass Bar extends Foo &#123;\n&#125;\n\nBar.classMethod() // &#39;hello&#39;\n</code></pre>\n<p>7、静态属性<br>使用static 声明的属性就是静态属性，由类调用</p>\n<h3 id=\"十一、类的继承\"><a href=\"#十一、类的继承\" class=\"headerlink\" title=\"十一、类的继承\"></a>十一、类的继承</h3><p>1、class可以通过extends关键字实现继承</p>\n<pre><code class=\"javascript\">class Point &#123;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  &#125;\n\n  toString() &#123;\n    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()\n  &#125;\n&#125;\n</code></pre>\n<p>上述代码中，constructor和toString方法之后，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的实例<br>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。  </p>\n<pre><code class=\"javascript\">class Point &#123; /* ... */ &#125;\n\nclass ColorPoint extends Point &#123;\n  constructor() &#123;\n  &#125;\n&#125;\n\nlet cp = new ColorPoint(); //ReferenceError\n</code></pre>\n<p>ES6的继承机制实质上是将父类的实例对象的属性和方法，加在this上面，所以必须先调用super方法，然后再用子类的构造函数修改this<br>如果子类没有定义constructor方法，这个方法会被默认添加</p>\n<pre><code class=\"javascript\">class ColorPoint extends Point &#123;\n&#125;\n\n// 等同于\nclass ColorPoint extends Point &#123;\n  constructor(...args) &#123;\n    super(...args);\n  &#125;\n&#125;\n</code></pre>\n<p>在子类的constructor方法没有调用super之前，就使用this关键字，结果报错</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  &#125;\n&#125;\n</code></pre>\n<p>2、super关键字<br>super关键字既可以当做函数使用，也可以当做对象使用  </p>\n<p>第一种情况，super作为构造函数使用，代表父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数</p>\n<pre><code class=\"javascript\">class A &#123;&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n  &#125;\n&#125;\n</code></pre>\n<p>注意，super虽然代表了父类的构造函数，但是返回是子类B的实例，即super内部的this指向的是B的实例，因此super()相当于A.prototype.constructor.call(this)。  </p>\n<p>第二种情况，super作为对象，在普通方法中指向父类的原型对象，在静态方法中，指向父类  </p>\n<pre><code class=\"javascript\">class A &#123;\n  p() &#123;\n    return 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super.p()); // 2\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，子类B当中的super.p()，就是将super当做一个对象。这是super在普通方法中，指向A.prototype，所以super.p()相当于A.prototype.p()。  </p>\n<p>注意：这里的super指向的是父类的原型对象，所以定义在父类实例上的方法和属性，是无法通过super调用的</p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.p = 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  get m() &#123;\n    return super.p;\n  &#125;\n&#125;\n\nlet b = new B();\nb.m // undefined\n</code></pre>\n<p>ES6规定，在子类的普通方法中通过super调用父类的方法时，方法内部this指向当前子类的实例  </p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nlet b = new B();\nb.m() // 2\n</code></pre>\n<p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。  </p>\n<p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。  </p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>\n<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>\n<pre><code class=\"javascript\">class Parent &#123;\n  static myMethod(msg) &#123;\n    console.log(&#39;static&#39;, msg);\n  &#125;\n\n  myMethod(msg) &#123;\n    console.log(&#39;instance&#39;, msg);\n  &#125;\n&#125;\n\nclass Child extends Parent &#123;\n  static myMethod(msg) &#123;\n    super.myMethod(msg);\n  &#125;\n\n  myMethod(msg) &#123;\n    super.myMethod(msg);\n  &#125;\n&#125;\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n</code></pre>\n<p>在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。  </p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  static print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  static m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nB.x = 3;\nB.m() // 3\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"es6基本知识\"><a href=\"#es6基本知识\" class=\"headerlink\" title=\"es6基本知识\"></a>es6基本知识</h2><h3 id=\"一、let-const\"><a href=\"#一、let-const\" class=\"headerlink\" title=\"一、let/const\"></a>一、let/const</h3><p>1、const/let都是用来声明变量，不可重复声明，具有块级作用域。存在暂时性死区，不存在变量提升。const用来声明常量。  </p>\n<h3 id=\"二、symbol\"><a href=\"#二、symbol\" class=\"headerlink\" title=\"二、symbol\"></a>二、symbol</h3><p>1、symbol是一个全新的数据类型，表示独一无二的值，对象可以以symbol类型作为键<br>2、现在主要用于声明对象的私有属性<br><strong>示例</strong></p>\n<pre><code class=\"javascript\">console.log(Symbol() === Symbol()); // false\nconsole.log(Symbol(&#39;foo&#39;) === Symbol(&#39;foo&#39;)); // false\nconsole.log(typeof Symbol()); // symbol\nconsole.log(Symbol(&#39;foo&#39;)); // Symbol(&#39;foo&#39;)\n\nconst obj = &#123;\n    [Symbol(&#39;name&#39;)]: &#39;张三&#39;\n&#125;\nconsole.log(obj) // &#123;[Symbol(name)]:&#39;张三&#39;&#125;\nconsole.log(obj[Symbol(&#39;name&#39;)]) // undefined\n\nlet name = Symbol(&#39;name&#39;);\nconst Person = &#123;\n    [name]: &#39;zhangsan&#39;,\n    age: 15,\n    say() &#123;\n        console.log(&#39;i am &#39; + this[name])\n    &#125;\n&#125;\n\nconsole.log(Person[Symbol(&#39;name&#39;)]) // undefined 故symbol一般用于定义私有属性 ，外部访问不到\nPerson.say() // i am zhangsan\n\nconsole.log(Symbol.for(&#39;true&#39;) === Symbol.for(true)) // true  Symbol.for方法是根据字符串参数作比较是否相等\n\nconst objj = &#123;\n    [Symbol(&#39;name&#39;)]: &#39;lisi&#39;,\n    age: 15\n&#125;\n\nfor (let k in objj) &#123;\n    console.log(k); // age  for方法无法访问到Symbol属性\n&#125;\n\nconsole.log(Object.keys(objj)) // [&#39;age&#39;]  Object.keys也无法访问Symbol属性\n\nconsole.log(JSON.stringify(objj)) // &#123;&#39;age&#39;:15&#125;\n\nconsole.log(Object.getOwnPropertySymbols(objj)) // [Symbol(name)] 能获取到Symbol属性\n\nconsole.log(Reflect.ownKeys(objj)) // [&#39;age&#39;, Symbol(name)] 能获取到Symbol属性\n</code></pre>\n<h3 id=\"三、对象和数组的解构\"><a href=\"#三、对象和数组的解构\" class=\"headerlink\" title=\"三、对象和数组的解构\"></a>三、对象和数组的解构</h3><p><strong>示例</strong><br>1、数组的解构</p>\n<pre><code class=\"javascript\">// 传统方法\nconst arr = [1, 2, 3];\nlet fir = arr[0];\nlet sec = arr[1];\nlet thr = arr[2];\nconsole.log(fir, sec, thr) // 1,2,3\n\n//es6新增解构方法\nlet [f, s, t] = arr;\nconsole.log(f,s,t) // 1,2,3\n\nlet [f, ...rest] = arr;\nconsole.log(f, rest) // 1, [2, 3]\n\nlet [f, a, b, c, d] = arr;\nconsole.log(f,a,b,c,d) // 1,2,3,undefined，undefined\n\nlet [,,a,b,c] = arr;\nconsole.log(a,b,c) // 3 undefined undefined\n</code></pre>\n<p>2、对象的解构</p>\n<pre><code class=\"javascript\">const obj = &#123;\n    name: &#39;zhangsan&#39;,\n    age: 15\n&#125;\n\nconst &#123;name, age&#125; = obj;\nconsole.log(name, age); // zhangsan 15\n\nconst name1 = &#39;lisi&#39;;\n\nconst &#123;name: name2, age, sex=&#39;man&#39;&#125; = obj;\n\nconsole.log(name1, name2, age, sex); // lisi zhangsan 15 man\n</code></pre>\n<h3 id=\"四、模板字符串\"><a href=\"#四、模板字符串\" class=\"headerlink\" title=\"四、模板字符串\"></a>四、模板字符串</h3><p><strong>示例</strong>  </p>\n<pre><code class=\"javascript\">let str = `我是模板字符串 我能\n直接换行`\nconsole.log(str);\n//我是模板字符串 我能\n//直接换行\n\nconst &#123;name, age, sex&#125; = &#123;\n    name: &#39;zhangsan&#39;,\n    age: 18,\n    sex: &#39;man&#39;\n&#125;\n\nlet s = `大家好，我是$&#123;name&#125;, 今年$&#123;age&#125;, $&#123;1+20&#125;，$&#123;Math.random()&#125;`\nconsole.log(s) // 大家好，我是zhangsan, 今年18, 21，0.45371632552390184\n\nfunction tag(str, sex, name, age) &#123;\n    console.log(str, sex, name, age)\n&#125;\n//tag方法使用于模板字符串，第一个参数返回以$&#123;&#125;拆分的数组，剩余的参数与目标字符穿的顺序一一对应\nconst a = tag`大家好，我是$&#123;sex&#125;，姓名：$&#123;name&#125;, 年龄$&#123;age&#125;, 哈哈`; // [ &#39;大家好， 我是&#39;, &#39;，姓名：&#39;, &#39;, 年龄&#39;, &#39;,哈哈&#39; ] &#39;man&#39; &#39;zhangsan&#39; 18\nconsole.log(a); // undefined\n</code></pre>\n<h3 id=\"五、扩展运算符-…\"><a href=\"#五、扩展运算符-…\" class=\"headerlink\" title=\"五、扩展运算符(…)\"></a>五、扩展运算符(…)</h3><p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中,属于浅拷贝<br><strong>示例</strong>  </p>\n<pre><code class=\"javascript\">const a = &#123;\n    name: &#39;zhangsan&#39;,\n    age: 18,\n    friends: [&#39;xm&#39;, &#39;xh&#39;]\n&#125;\nconst b = &#123;\n    name: &#39;lisi&#39;,\n    sex: &#39;woman&#39;\n&#125;\n\nconst c = &#123;\n    ...a,\n    ...b\n&#125;\nconsole.log(c)  // &#123; name: &#39;lisi&#39;, age: 18, friends: [ &#39;xm&#39;, &#39;xh&#39; ], sex: &#39;woman&#39; &#125;\n\n// c引用数据类型发生改变，a也会随之改变，证明扩展运算符是浅拷贝\nc.friends[0] = &#39;xt&#39;;\nc.age = 20;\nconsole.log(a) // &#123; name: &#39;zhangsan&#39;, age: 18, friends: [ &#39;xt&#39;, &#39;xh&#39; ] &#125;\nconsole.log(c) // &#123; name: &#39;lisi&#39;, age: 20, friends: [ &#39;xt&#39;, &#39;xh&#39; ], sex: &#39;woman&#39; &#125;\n</code></pre>\n<h3 id=\"六、字符串新增方法\"><a href=\"#六、字符串新增方法\" class=\"headerlink\" title=\"六、字符串新增方法\"></a>六、字符串新增方法</h3><p>1、includes、startsWith、endsWith</p>\n<pre><code class=\"javascript\">let s = &#39;hello es6&#39;;\nconsole.log(s.includes(&#39;es&#39;)); // true  判断字符串是否包含某字符串\nconsole.log(s.startsWith(&#39;e&#39;)); // false 判断字符串是否以某字符串开头\nconsole.log(s.endsWith(&#39;6&#39;)); // true  判断字符串是否以某字符串结尾\n</code></pre>\n<p>2、repeat方法</p>\n<pre><code class=\"javascript\">let i = &#39;abc&#39;;\nconsole.log(i.repeat(3)) // abcabcabc 表示重复某字符串几次\n</code></pre>\n<p>3、padStart、padEnd方法</p>\n<pre><code class=\"javascript\">let x = &#39;x&#39;;\nconsole.log(x.padStart(5, &#39;ab&#39;)); // ababx  在x字符串前面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padStart(4, &#39;ab&#39;)); // abax   在x字符串前面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(5, &#39;ab&#39;)); // xabab    在x字符串后面，用ab补全，总共5位  第一个参数补全之后的位数，第二个参数补全用的字符\nconsole.log(x.padEnd(4, &#39;ab&#39;)); // xaba     在x字符串后面，用ab补全，总共4位  第一个参数补全之后的位数，第二个参数补全用的字符\n</code></pre>\n<p>4、replaceAll方法</p>\n<pre><code class=\"javascript\">let o = &#39;abbcc&#39;;\nlet o1 = o.replaceAll(&#39;b&#39;, &#39;_&#39;);\nconsole.log(o) // &#39;abbcc&#39;\nconsole.log(o1) // &#39;a__cc&#39;\n</code></pre>\n<h3 id=\"七、箭头函数\"><a href=\"#七、箭头函数\" class=\"headerlink\" title=\"七、箭头函数\"></a>七、箭头函数</h3><p><strong>1、箭头函数中this是在定义是绑定的，而不是调用时。（箭头函数的this值继承自外围作用域。运行时它会首先到它的父级作用域找，如果父级作用域还是箭头函数，那么接着向上找，直到找到我们要的this指向）</strong></p>\n<pre><code class=\"javascript\">var a1 = &#39;ppp&#39;\n\nvar obj1 = &#123;\n    a1: &#39;bbb&#39;,\n    b2: this.a1,\n    f: function () &#123;\n        console.log(this.a1)\n    &#125;,\n    d: () =&gt; &#123;\n        console.log(this.a1)\n    &#125;\n&#125;\nconsole.log(obj1.b2) // ‘ppp’\nobj1.f(); // ‘bbb’\nobj1.d(); // &#39;ppp&#39;\n</code></pre>\n<p><strong>2、箭头函数不能作为构造函数，不能使用new</strong>  </p>\n<pre><code class=\"javascript\">//构造函数如下：\nfunction Person(p)&#123;\n    this.name = p.name;\n&#125;\n//如果用箭头函数作为构造函数，则如下\nvar Person = (p) =&gt; &#123;\n    this.name = p.name;\n&#125;\n</code></pre>\n<p>由于this必须是实例对象，而箭头函数是没有实例的，此处的this指向window，不能产生person的实例，自相矛盾  </p>\n<p><strong>3、箭头函数没有arguments、caller、callee</strong><br>箭头函数本身没有arguments,如果箭头函数在一个function内部，它会将外部函数的arguments拿过来使用。<br>箭头函数中要想接手不定参数，应该使用rest参数…解决</p>\n<pre><code class=\"javascript\">let B = (b)=&gt;&#123;\n  console.log(arguments);\n&#125;\nB(2,92,32,32);   // Uncaught ReferenceError: arguments is not defined\n\nlet C = (...c) =&gt; &#123;\n  console.log(c);\n&#125;\nC(3,82,32,11323);  // [3, 82, 32, 11323]\n</code></pre>\n<p><strong>4、箭头函数通过call和apply调用，不会改变this指向，只会传入参数</strong>  </p>\n<pre><code class=\"javascript\">var name = &#39;lw&#39;\nlet a1 = &#123;\n    name: &#39;zs&#39;,\n    f: function (age) &#123;\n        console.log(`我是$&#123;this.name&#125;,年龄$&#123;age&#125;`)\n    &#125;,\n    d: (age) =&gt; &#123;\n        console.log(`我是$&#123;this.name&#125;,年龄$&#123;age&#125;`)\n    &#125;\n&#125;\n\nlet a2 = &#123;\n    name: &#39;ls&#39;\n&#125;\n\na1.f(15); // 我是zs,年龄15\na1.d(15); // 我是lw,年龄15\na1.f.call(a2, 18); // 我是ls,年龄18\na1.d.call(a2, 18); // 我是lw,年龄18\n</code></pre>\n<p><strong>5、箭头函数没有原型属性</strong>  </p>\n<pre><code class=\"javascript\">var A = function () &#123;\n    return 2\n&#125;\n\nvar B = () =&gt; &#123;\n    return 3\n&#125;\n\nconsole.log(A.prototype) // &#123;constructor: ƒ&#125;\nconsole.log(B.prototype) // undefined\n</code></pre>\n<p><strong>6、箭头函数ES6 class中声明的方法为实例方法，不是原型方法</strong>  </p>\n<pre><code class=\"javascript\">class Super &#123;\n    sayHello() &#123;\n        console.log(&#39;hello&#39;)\n    &#125;\n    sayWorld = () =&gt; &#123;\n        console.log(&#39;world&#39;)\n    &#125;\n&#125;\nconst a = new Super();\nconst b = new Super();\n\nconsole.log(a.sayHello === b.sayHello) // true sayHello是Super.prototype上的方法，所有实例共享同一个方法，所以为true\nconsole.log(a.sayWorld === b.sayWorld) // false sayWorld是各自实例上的方法，所以每个方法不一样，估为false\nconsole.log(Super.prototype)\n</code></pre>\n<h3 id=\"八、Proxy代理\"><a href=\"#八、Proxy代理\" class=\"headerlink\" title=\"八、Proxy代理\"></a>八、Proxy代理</h3><pre><code class=\"javascript\">const person = &#123;\n    name: &#39;zs&#39;,\n    age: 18\n&#125;\n\nconst personProxy = new Proxy(person, &#123;\n    get(target, key, receiver) &#123;\n        console.log(target, key, receiver)\n        return key in target ? target[key] : &#39;default&#39;;\n    &#125;,\n    set(target, key, value, receiver) &#123;\n        console.log(target, key, value, receiver)\n        if (typeof value !== &#39;number&#39;) &#123;\n            throw new TypeError(&#39;age need number&#39;);\n        &#125;\n        target[key] = value;\n    &#125;\n&#125;)\n\nconsole.log(personProxy.name) // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;name&#39;  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  zs\nconsole.log(personProxy.sex) // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;sex&#39;  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  default\nconsole.log(personProxy.age) // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;age&#39;  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  18\npersonProxy.age = 19  // // &#123;name: &#39;zs&#39;, age: 18&#125;  &#39;age&#39;  19  Proxy&#123;name: &#39;zs&#39;, age: 18&#125;  \npersonProxy.age = &#39;20&#39;;  // &#123;name: &#39;zs&#39;, age: 19&#125;  &#39;age&#39;  &#39;20&#39;  Proxy&#123;name: &#39;zs&#39;, age: 19&#125;  报错Uncaught TypeError: age need number\n\n\nconst list = [1,2,3]\nconst listProxy = new Proxy(list, &#123;\n    get(target, key, receiver) &#123;\n        console.log(&#39;get&#39;)\n        return target[key]\n    &#125;,\n    set(target, key, value, receiver) &#123;\n        console.log(&#39;set&#39;)\n        target[key] = value;\n        return true; // 表示设置成功\n    &#125;,\n    deleteProperty(target, key) &#123;\n        console.log(&#39;delete&#39;)\n    &#125;\n&#125;)\nconsole.log(listProxy[0]);\nconsole.log(listProxy.push(100));\nconsole.log(listProxy.shift())\nlistProxy[0] = 999\n</code></pre>\n<p>Proxy代理 vs Object.defineProperty()<br>1、Object.defineProperty()只能监听对象的读写操作  而Proxy能监听更多的操作，比如deleteProperty、has等<br>2、Proxy能监听数组的操作<br>3、Proxy是以非侵入式的监管对象，不会对原对象进行任何的操作</p>\n<h3 id=\"八、Reflect\"><a href=\"#八、Reflect\" class=\"headerlink\" title=\"八、Reflect\"></a>八、Reflect</h3><p>Reflect提供了对象统一操作API</p>\n<pre><code class=\"javascript\">const person = &#123;\n    name: &#39;zs&#39;,\n    age: 19\n&#125;\nfunction Person() &#123;\n    this.name = &#39;ls&#39;;\n    this.age = 20;\n&#125;\nPerson.prototype.say = function () &#123;\n    console.log(&#39;hello world&#39;)\n&#125;\nconst p = new Person();\nconsole.log(Reflect.get(person, &#39;name&#39;))  // zs\nconsole.log(Reflect.ownKeys(person)) // [&#39;name&#39;, &#39;age&#39;]  只能访问对象上的属性，不能访问原型上的\nconsole.log(Reflect.ownKeys(p)) // [&#39;name&#39;, &#39;age&#39;]\nconsole.log(Reflect.set(person, &#39;age&#39;, 20)) // true 表示操作成功\nconsole.log(Reflect.has(person, &#39;sex&#39;)) // false\nconsole.log(Reflect.deleteProperty(person, &#39;age&#39;)) // true 表示操作成功\n</code></pre>\n<h3 id=\"九、set和map\"><a href=\"#九、set和map\" class=\"headerlink\" title=\"九、set和map\"></a>九、set和map</h3><p>1、set数据结构 返回一个没有重复值的集合  </p>\n<pre><code class=\"javascript\">const s = new Set()\ns.add(&#39;a&#39;).add(&#39;b&#39;).add(3).add(4).add(5).add(5);\n\ns.forEach(i =&gt; console.log(i))  // a b 3 4 5\n\nfor (let i of s) &#123;\n    console.log(i) // a b 3 4 5\n&#125;\n\nconsole.log(s) // Set(5)&#123;&#39;a&#39;, &#39;b&#39;, 3, 4, 5&#125;\nconsole.log(s.size) // 5\nconsole.log(s.has(&#39;a&#39;)) // true\nconsole.log(s.has(100)) // false\nconsole.log(s.delete(5)) // true 表示操作成功 删除5\nconsole.log(s) // Set(4)&#123;&#39;a&#39;, &#39;b&#39;, 3, 4&#125;\nconsole.log(s.clear()) // undefined\nconsole.log(s) // Set(0)&#123;size: 0&#125;\n\n// 数组去重\nconst array = [1,3,2,3,1,5,6,1,5];\nconst newArr = [...new Set(array)]\nconsole.log(newArr) // [1, 3, 2, 5, 6]\n</code></pre>\n<p>2、map数据结构 键值对数据结构</p>\n<pre><code class=\"javascript\">// 传统键值对象，会将key不是字符串的值转变为字符串\nconst obj = &#123;&#125;;\nobj[123] = &#39;value&#39;;\nobj[true] = &#39;value&#39;;\nobj[&#123;name:&#39;zs&#39;&#125;] = &#39;value&#39;;\nobj[&#39;zzh&#39;] = &#39;value&#39;;\nconsole.log(Reflect.ownKeys(obj)) // [&#39;123&#39;, &#39;true&#39;, &#39;[object Object]&#39;, &#39;zzh&#39;]\n\n// map对象，会将key的数据类型保留\nconst t = &#123;\n    name: &#39;kzz&#39;\n&#125;\nconst m = new Map();\nm.set(t, &#39;a&#39;);\nm.set(true, &#39;b&#39;);\nm.set(123, &#39;c&#39;);\nconsole.log(m); // &#123;&#123;…&#125; =&gt; &#39;a&#39;, true =&gt; &#39;b&#39;, 123 =&gt; &#39;c&#39;&#125;\nconsole.log(m.get(t)) // a\nconsole.log(m.get(true)) // b\nm.forEach((i, k) =&gt; console.log(i, k)) // a &#123;name: &#39;kzz&#39;&#125;  b true  c 123\n</code></pre>\n<h3 id=\"十、class\"><a href=\"#十、class\" class=\"headerlink\" title=\"十、class\"></a>十、class</h3><p>1、ES6的类，完全可以看成构造函数的另外一种写法  </p>\n<pre><code class=\"javascript\">class Point &#123;\n  // ...\n&#125;\n\ntypeof Point // &quot;function&quot;\nPoint === Point.prototype.constructor  // true\n</code></pre>\n<p>2、类的方法都是定义在prototype对象上（箭头函数方法是定义在实例上）<br>3、类的内部定义的方法，都是不可枚举的,这和ES5的行为不一致</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    // ...\n  &#125;\n\n  toString() &#123;\n    // ...\n  &#125;\n&#125;\n\nObject.keys(Point.prototype)\n// []\nObject.getOwnPropertyNames(Point.prototype)\n// [&quot;constructor&quot;,&quot;toString&quot;]\n</code></pre>\n<p>4、constructor方法是类的默认方法，通过new对象创建实例时，会自动调用该方法。一个类必定有constructor方法，如果没有显式定义，一个空的constructor方法会默认被添加  </p>\n<pre><code class=\"javascript\">class Point &#123;\n&#125;\n\n// 等同于\nclass Point &#123;\n  constructor() &#123;&#125;\n&#125;\n</code></pre>\n<p>5、constructor方法默认返回实例对象（this）,完全可以指定返回另外一个对象</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  constructor() &#123;\n    return Object.create(null);\n  &#125;\n&#125;\n\nnew Foo() instanceof Foo\n// false\n// constructor返回一个全新的对象，结果导致实例对象不是Foo的实例\n</code></pre>\n<p>6、静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承，如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nFoo.classMethod() // &#39;hello&#39;\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n</code></pre>\n<p>如果静态方法中包含关键字this,这个this指向的是类而不是实例</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static bar() &#123;\n    this.baz();\n  &#125;\n  static baz() &#123;\n    console.log(&#39;hello&#39;);\n  &#125;\n  baz() &#123;\n    console.log(&#39;world&#39;);\n  &#125;\n&#125;\n\nFoo.bar() // hello\n</code></pre>\n<p>父类的静态方法能被子类继承</p>\n<pre><code class=\"javascript\">class Foo &#123;\n  static classMethod() &#123;\n    return &#39;hello&#39;;\n  &#125;\n&#125;\n\nclass Bar extends Foo &#123;\n&#125;\n\nBar.classMethod() // &#39;hello&#39;\n</code></pre>\n<p>7、静态属性<br>使用static 声明的属性就是静态属性，由类调用</p>\n<h3 id=\"十一、类的继承\"><a href=\"#十一、类的继承\" class=\"headerlink\" title=\"十一、类的继承\"></a>十一、类的继承</h3><p>1、class可以通过extends关键字实现继承</p>\n<pre><code class=\"javascript\">class Point &#123;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  &#125;\n\n  toString() &#123;\n    return this.color + &#39; &#39; + super.toString(); // 调用父类的toString()\n  &#125;\n&#125;\n</code></pre>\n<p>上述代码中，constructor和toString方法之后，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的实例<br>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。  </p>\n<pre><code class=\"javascript\">class Point &#123; /* ... */ &#125;\n\nclass ColorPoint extends Point &#123;\n  constructor() &#123;\n  &#125;\n&#125;\n\nlet cp = new ColorPoint(); //ReferenceError\n</code></pre>\n<p>ES6的继承机制实质上是将父类的实例对象的属性和方法，加在this上面，所以必须先调用super方法，然后再用子类的构造函数修改this<br>如果子类没有定义constructor方法，这个方法会被默认添加</p>\n<pre><code class=\"javascript\">class ColorPoint extends Point &#123;\n&#125;\n\n// 等同于\nclass ColorPoint extends Point &#123;\n  constructor(...args) &#123;\n    super(...args);\n  &#125;\n&#125;\n</code></pre>\n<p>在子类的constructor方法没有调用super之前，就使用this关键字，结果报错</p>\n<pre><code class=\"javascript\">class Point &#123;\n  constructor(x, y) &#123;\n    this.x = x;\n    this.y = y;\n  &#125;\n&#125;\n\nclass ColorPoint extends Point &#123;\n  constructor(x, y, color) &#123;\n    this.color = color; // ReferenceError\n    super(x, y);\n    this.color = color; // 正确\n  &#125;\n&#125;\n</code></pre>\n<p>2、super关键字<br>super关键字既可以当做函数使用，也可以当做对象使用  </p>\n<p>第一种情况，super作为构造函数使用，代表父类的构造函数，ES6要求，子类的构造函数必须执行一次super函数</p>\n<pre><code class=\"javascript\">class A &#123;&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n  &#125;\n&#125;\n</code></pre>\n<p>注意，super虽然代表了父类的构造函数，但是返回是子类B的实例，即super内部的this指向的是B的实例，因此super()相当于A.prototype.constructor.call(this)。  </p>\n<p>第二种情况，super作为对象，在普通方法中指向父类的原型对象，在静态方法中，指向父类  </p>\n<pre><code class=\"javascript\">class A &#123;\n  p() &#123;\n    return 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    console.log(super.p()); // 2\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，子类B当中的super.p()，就是将super当做一个对象。这是super在普通方法中，指向A.prototype，所以super.p()相当于A.prototype.p()。  </p>\n<p>注意：这里的super指向的是父类的原型对象，所以定义在父类实例上的方法和属性，是无法通过super调用的</p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.p = 2;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  get m() &#123;\n    return super.p;\n  &#125;\n&#125;\n\nlet b = new B();\nb.m // undefined\n</code></pre>\n<p>ES6规定，在子类的普通方法中通过super调用父类的方法时，方法内部this指向当前子类的实例  </p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nlet b = new B();\nb.m() // 2\n</code></pre>\n<p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。  </p>\n<p>由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。  </p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n    super.x = 3;\n    console.log(super.x); // undefined\n    console.log(this.x); // 3\n  &#125;\n&#125;\n\nlet b = new B();\n</code></pre>\n<p>上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。</p>\n<p>如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。</p>\n<pre><code class=\"javascript\">class Parent &#123;\n  static myMethod(msg) &#123;\n    console.log(&#39;static&#39;, msg);\n  &#125;\n\n  myMethod(msg) &#123;\n    console.log(&#39;instance&#39;, msg);\n  &#125;\n&#125;\n\nclass Child extends Parent &#123;\n  static myMethod(msg) &#123;\n    super.myMethod(msg);\n  &#125;\n\n  myMethod(msg) &#123;\n    super.myMethod(msg);\n  &#125;\n&#125;\n\nChild.myMethod(1); // static 1\n\nvar child = new Child();\nchild.myMethod(2); // instance 2\n</code></pre>\n<p>在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。  </p>\n<pre><code class=\"javascript\">class A &#123;\n  constructor() &#123;\n    this.x = 1;\n  &#125;\n  static print() &#123;\n    console.log(this.x);\n  &#125;\n&#125;\n\nclass B extends A &#123;\n  constructor() &#123;\n    super();\n    this.x = 2;\n  &#125;\n  static m() &#123;\n    super.print();\n  &#125;\n&#125;\n\nB.x = 3;\nB.m() // 3\n</code></pre>\n"},{"title":"network","date":"2022-01-26T06:18:12.000Z","cover":"https://s4.ax1x.com/2022/01/26/7LPKsg.png","_content":"\n## 网络基本知识\n\n### 一、从输入URL到浏览器显示页面发生了什么\n三个方面  \n一、网络篇  \n互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方法进行通信。分层由高到底分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接受端从数据链路层往上走。如图所示\n![](https://s4.ax1x.com/2022/01/26/7LMBv9.png)\n__1、输入URL__  \n__2、应用层DNS解析域名(找到域名对应IP)__\n客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直到找到活到根节点。  \n__3、应用层客户端发送HTTP请求__\nHTTP请求包括请求头和请求体，其中请求头包含了请求方法、目标URL、协议、cookie、缓存等  \n__4、传输层TCP传输报文__  \n位于传输层的TCP协议为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文\n段为单位的数据包进行管理，并为他们编号，方便服务器接收时能准确地还原报文信息。TCP\n协议通过\"三次握手\"等方法保证传输的安全可靠。  \n“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复，接收端\n收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有\nACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内\n没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。  \n![](https://s4.ax1x.com/2022/02/14/Hy3DWq.png)\n__5、网络层IP协议查询MAC地址__  \nIP协议的作用是把TCP分割好的各种数据包发送给接收方。而要保证确实能闯到接收方还需要接收方的MAC地址，也就是物理地址。IP地址\n和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议\n可以将IP地址解析成对应的MAC地址。  \n__6、数据到达数据链路层__  \n在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束  \n__7、服务器接收数据__  \n接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据\n包重新组成原来的HTTP请求报文  \n__8、服务器响应请求__  \n服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息-状态码。状态码\n由三位数字组成。  \n__9、服务器返回相应的文件__  \n请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。  \n__10、页面渲染__  \nhtml解析成DOM树，CSS解析成CSSOM树，DOM树和CSSOM树结合生成渲染树（Render Tree）,生成布局，将布局绘制在屏幕上  \n\n### 二、状态码分析\n200：响应成功，301：永久重定向，302：临时重定向，304：资源缓存，403：服务器禁止访问，404：服务器资源未找到，500-502：服务器内部错误，504：服务器繁忙  \n1xx 信息状态码 接收请求正在处理  \n2xx 成功状态码 请求正常处理完毕  \n3xx 重定向状态码 需要附加操作已完成请求  \n4xx 客户端错误状态码 服务器无法处理请求  \n5xx 服务器错误状态码 服务器处理请求出错  \n\n### 三、HTTP四次挥手\n第一次：当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求；  \n第二次：主机B收到FIN后对其作出响应，确认这一方向上的TCP的连接将关闭，将ACK置1；  \n第三次：由主机B再提出反方向的关闭请求，将FIN置1；  \n第四次：主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。  \n\n### 四、http和https区别\n1、http的URL是以http://开头，而https的URL是以https://开头  \n2、http是不安全的，而https是安全的  \n3、http标准端口80，而https的标准端口是443  \n4、在OSI网络模型中，http工作于应用层，而https的安全传输机制工作在传输层  \n5、http无法加密，而https对传输的数据进行加密  \n6、http无需证书，而https需要CA机构颁发的SSL证书  \n\n### 五、GET和POST的区别\n1、GET在浏览器回退不会再次请求，POST会再次请求  \n2、GET请求会被浏览器主动缓存，POST不会，要手动设置  \n3、GET请求在URL中传递的参数有长度限制的，而POST中的参数不会  \n4、GET参数通过URL传递，POST放在Request body中  \n5、GET参数暴露在地址栏不安全，POST放在报文内部更安全  \n6、GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作  \n7、GET产生一个TCP数据包，POST产生两个TCP数据包  \n\n### 六、理解xss、csrf、ddos攻击原理以及避免方式\n1、XSS，跨站脚本攻击，是一种代码注入攻击。攻击者在网络上注入恶意代码，当被攻击者登录网站时\n就会执行这些恶意代码，这些脚本可以读取cookie,session或者其他敏感的网络信息，对用户发起欺诈，甚至发起蠕虫攻击等。  \n\nXSS避免的方式：  \n1、URL参数使用encodeURIComponent方式转义  \n2、尽量不使用InnerHtml插入HTML内容  \n3、使用特殊符号、标签转义符  \n\n2、CSRF，跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台\n的用户验证，达到冒充用户对被攻击的网站进行某项操作的目的。  \n\nCSRF避免的方式：\n1、添加验证码  \n2、使用token\n\n3、DDos又叫分布式拒绝服务，原理就是利用大量的请求造成资源过载，导致服务器不可用。  \n\nDDos避免的方式：  \n1、限制单IP的请求评率  \n2、防火墙等防护设置禁止ICMP  \n3、检查特权端口的开放  \n\n### 七、http如何实现缓存\n先去内存（from memory cache）找，有直接加载，没有去硬盘找（from disk cache），如果有加载，没有则进行网络请求。  \n\nmemory cache在浏览器关闭后会清除，disk cache不会。  \n\n__web服务器通过2种方式判断浏览器缓存是否是最新的：__  \n1、浏览器把缓存文件的最后修改时间通过header中“if-Modified-Since”来告诉web服务器。  \n2、浏览器把缓存文件的ETag,通过header ”if-None-Match“,来告诉web服务器  \n\n__通过最后修改时间来判断缓存新鲜度__  \nLast-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。  \n1、浏览器客户端想请求一个文档，首先检查本地缓存，发现存在这个文档的缓存，获取缓存文件的最后修改时间，通过：if-Modified-Since,发送request给web服务器。  \n2、web服务器收到Request,将服务器的文档修改时间（Last-Modified）:跟request header中的，if-Modified-Since相对比较，如果时间一样的，说明缓存还是最新的，web\n服务器将发送304 Not Modified给浏览器客户端，告诉客户端直接使用缓存里的版本。  \n3、假如该文档已经更新了，web服务器将发送该文档的最新版本给浏览器客户端。\n\n__通过Etag来判断缓存新鲜度__  \nEtag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。  \n1、当资源过期时，（使用Cache-Control标识的max-age）,发现资源具有Etag声明，则再次想web服务器请求时带上If-None-Match(Etag的值)。  \n2、web服务器收到请求后发现header中有If-None-Match则与被请求资源的相应校验串(etag)进行比对，决定返回200或者304  \n\n__为何有Last-Modified，还需要Etag？__  \n1 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间  \n2 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存  \n3 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形  \n4、Last-Modified与Etag一起使用时，服务器会优先验证Etag  \n\n__cache-control和Expires__  \nExpires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间(绝对时间)前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  \n\nCache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期（相对时间），控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。  \n\n__cache-control的值__  \n1 Public指示响应可被任何缓存区缓存。\n2 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\n3 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~\n4 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\n5 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\n6 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n7 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n__浏览器缓存流程__  \n![](https://s4.ax1x.com/2022/02/14/H6nSFP.png)\n\n### 八、同源策略\n同源是指“协议+域名+端口”三种相同，同源策略就是一个域下的js脚本未经允许的情况下，不允许访问另一个域下的内容，只允许访问同源下的内容。\n\n跨域通信的几种方式：  \n1、jsonp(利用script标签没有跨域限制的漏洞实现，缺点：只支持get请求)  \n2、CORS(设置Access-Control-Allow-Origin,指定可访问资源的域名)  \n3、postMessage(页面内嵌iframe消息传递，通过onMessage监听传递过来的数据)  \n4、websocket通信  \n5、Node中间件代理  \n6、Nginx反向代理  \n7、document.domain + iframe跨域\n\n### 九、本地存储的共同点和不同点\n共同点：都是保存在浏览器端，且同源的  \n\n不同点：  \n1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅本地保存。  \n2、储存大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M。\n3、有效期不同，sessionStorage仅在当前浏览器窗口关闭之前有效，localStorage始终有效，cookie只在过期时间之前有效，即使窗口关闭或浏览器关闭。\n4、作用域不同，sessionStorage在当前浏览器窗口共享，localStorage在所有同源窗口中共享，cookie也是在所有同源窗口中共享\n\n\n","source":"_posts/network.md","raw":"---\ntitle: network\ndate: 2022-01-26 14:18:12\ncover: https://s4.ax1x.com/2022/01/26/7LPKsg.png\ntags: \n- 网络\n- JS\n---\n\n## 网络基本知识\n\n### 一、从输入URL到浏览器显示页面发生了什么\n三个方面  \n一、网络篇  \n互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方法进行通信。分层由高到底分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接受端从数据链路层往上走。如图所示\n![](https://s4.ax1x.com/2022/01/26/7LMBv9.png)\n__1、输入URL__  \n__2、应用层DNS解析域名(找到域名对应IP)__\n客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直到找到活到根节点。  \n__3、应用层客户端发送HTTP请求__\nHTTP请求包括请求头和请求体，其中请求头包含了请求方法、目标URL、协议、cookie、缓存等  \n__4、传输层TCP传输报文__  \n位于传输层的TCP协议为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文\n段为单位的数据包进行管理，并为他们编号，方便服务器接收时能准确地还原报文信息。TCP\n协议通过\"三次握手\"等方法保证传输的安全可靠。  \n“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复，接收端\n收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有\nACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内\n没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。  \n![](https://s4.ax1x.com/2022/02/14/Hy3DWq.png)\n__5、网络层IP协议查询MAC地址__  \nIP协议的作用是把TCP分割好的各种数据包发送给接收方。而要保证确实能闯到接收方还需要接收方的MAC地址，也就是物理地址。IP地址\n和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议\n可以将IP地址解析成对应的MAC地址。  \n__6、数据到达数据链路层__  \n在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束  \n__7、服务器接收数据__  \n接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据\n包重新组成原来的HTTP请求报文  \n__8、服务器响应请求__  \n服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息-状态码。状态码\n由三位数字组成。  \n__9、服务器返回相应的文件__  \n请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。  \n__10、页面渲染__  \nhtml解析成DOM树，CSS解析成CSSOM树，DOM树和CSSOM树结合生成渲染树（Render Tree）,生成布局，将布局绘制在屏幕上  \n\n### 二、状态码分析\n200：响应成功，301：永久重定向，302：临时重定向，304：资源缓存，403：服务器禁止访问，404：服务器资源未找到，500-502：服务器内部错误，504：服务器繁忙  \n1xx 信息状态码 接收请求正在处理  \n2xx 成功状态码 请求正常处理完毕  \n3xx 重定向状态码 需要附加操作已完成请求  \n4xx 客户端错误状态码 服务器无法处理请求  \n5xx 服务器错误状态码 服务器处理请求出错  \n\n### 三、HTTP四次挥手\n第一次：当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求；  \n第二次：主机B收到FIN后对其作出响应，确认这一方向上的TCP的连接将关闭，将ACK置1；  \n第三次：由主机B再提出反方向的关闭请求，将FIN置1；  \n第四次：主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。  \n\n### 四、http和https区别\n1、http的URL是以http://开头，而https的URL是以https://开头  \n2、http是不安全的，而https是安全的  \n3、http标准端口80，而https的标准端口是443  \n4、在OSI网络模型中，http工作于应用层，而https的安全传输机制工作在传输层  \n5、http无法加密，而https对传输的数据进行加密  \n6、http无需证书，而https需要CA机构颁发的SSL证书  \n\n### 五、GET和POST的区别\n1、GET在浏览器回退不会再次请求，POST会再次请求  \n2、GET请求会被浏览器主动缓存，POST不会，要手动设置  \n3、GET请求在URL中传递的参数有长度限制的，而POST中的参数不会  \n4、GET参数通过URL传递，POST放在Request body中  \n5、GET参数暴露在地址栏不安全，POST放在报文内部更安全  \n6、GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作  \n7、GET产生一个TCP数据包，POST产生两个TCP数据包  \n\n### 六、理解xss、csrf、ddos攻击原理以及避免方式\n1、XSS，跨站脚本攻击，是一种代码注入攻击。攻击者在网络上注入恶意代码，当被攻击者登录网站时\n就会执行这些恶意代码，这些脚本可以读取cookie,session或者其他敏感的网络信息，对用户发起欺诈，甚至发起蠕虫攻击等。  \n\nXSS避免的方式：  \n1、URL参数使用encodeURIComponent方式转义  \n2、尽量不使用InnerHtml插入HTML内容  \n3、使用特殊符号、标签转义符  \n\n2、CSRF，跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台\n的用户验证，达到冒充用户对被攻击的网站进行某项操作的目的。  \n\nCSRF避免的方式：\n1、添加验证码  \n2、使用token\n\n3、DDos又叫分布式拒绝服务，原理就是利用大量的请求造成资源过载，导致服务器不可用。  \n\nDDos避免的方式：  \n1、限制单IP的请求评率  \n2、防火墙等防护设置禁止ICMP  \n3、检查特权端口的开放  \n\n### 七、http如何实现缓存\n先去内存（from memory cache）找，有直接加载，没有去硬盘找（from disk cache），如果有加载，没有则进行网络请求。  \n\nmemory cache在浏览器关闭后会清除，disk cache不会。  \n\n__web服务器通过2种方式判断浏览器缓存是否是最新的：__  \n1、浏览器把缓存文件的最后修改时间通过header中“if-Modified-Since”来告诉web服务器。  \n2、浏览器把缓存文件的ETag,通过header ”if-None-Match“,来告诉web服务器  \n\n__通过最后修改时间来判断缓存新鲜度__  \nLast-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。  \n1、浏览器客户端想请求一个文档，首先检查本地缓存，发现存在这个文档的缓存，获取缓存文件的最后修改时间，通过：if-Modified-Since,发送request给web服务器。  \n2、web服务器收到Request,将服务器的文档修改时间（Last-Modified）:跟request header中的，if-Modified-Since相对比较，如果时间一样的，说明缓存还是最新的，web\n服务器将发送304 Not Modified给浏览器客户端，告诉客户端直接使用缓存里的版本。  \n3、假如该文档已经更新了，web服务器将发送该文档的最新版本给浏览器客户端。\n\n__通过Etag来判断缓存新鲜度__  \nEtag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。  \n1、当资源过期时，（使用Cache-Control标识的max-age）,发现资源具有Etag声明，则再次想web服务器请求时带上If-None-Match(Etag的值)。  \n2、web服务器收到请求后发现header中有If-None-Match则与被请求资源的相应校验串(etag)进行比对，决定返回200或者304  \n\n__为何有Last-Modified，还需要Etag？__  \n1 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间  \n2 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存  \n3 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形  \n4、Last-Modified与Etag一起使用时，服务器会优先验证Etag  \n\n__cache-control和Expires__  \nExpires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间(绝对时间)前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  \n\nCache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期（相对时间），控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。  \n\n__cache-control的值__  \n1 Public指示响应可被任何缓存区缓存。\n2 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。\n3 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~\n4 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\n5 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。\n6 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n7 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n__浏览器缓存流程__  \n![](https://s4.ax1x.com/2022/02/14/H6nSFP.png)\n\n### 八、同源策略\n同源是指“协议+域名+端口”三种相同，同源策略就是一个域下的js脚本未经允许的情况下，不允许访问另一个域下的内容，只允许访问同源下的内容。\n\n跨域通信的几种方式：  \n1、jsonp(利用script标签没有跨域限制的漏洞实现，缺点：只支持get请求)  \n2、CORS(设置Access-Control-Allow-Origin,指定可访问资源的域名)  \n3、postMessage(页面内嵌iframe消息传递，通过onMessage监听传递过来的数据)  \n4、websocket通信  \n5、Node中间件代理  \n6、Nginx反向代理  \n7、document.domain + iframe跨域\n\n### 九、本地存储的共同点和不同点\n共同点：都是保存在浏览器端，且同源的  \n\n不同点：  \n1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅本地保存。  \n2、储存大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M。\n3、有效期不同，sessionStorage仅在当前浏览器窗口关闭之前有效，localStorage始终有效，cookie只在过期时间之前有效，即使窗口关闭或浏览器关闭。\n4、作用域不同，sessionStorage在当前浏览器窗口共享，localStorage在所有同源窗口中共享，cookie也是在所有同源窗口中共享\n\n\n","slug":"network","published":1,"updated":"2022-02-16T08:21:11.338Z","_id":"ckyv5ueae0000mkv4gcor537u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"网络基本知识\"><a href=\"#网络基本知识\" class=\"headerlink\" title=\"网络基本知识\"></a>网络基本知识</h2><h3 id=\"一、从输入URL到浏览器显示页面发生了什么\"><a href=\"#一、从输入URL到浏览器显示页面发生了什么\" class=\"headerlink\" title=\"一、从输入URL到浏览器显示页面发生了什么\"></a>一、从输入URL到浏览器显示页面发生了什么</h3><p>三个方面<br>一、网络篇<br>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方法进行通信。分层由高到底分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接受端从数据链路层往上走。如图所示<br><img src=\"https://s4.ax1x.com/2022/01/26/7LMBv9.png\"><br><strong>1、输入URL</strong><br><strong>2、应用层DNS解析域名(找到域名对应IP)</strong><br>客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直到找到活到根节点。<br><strong>3、应用层客户端发送HTTP请求</strong><br>HTTP请求包括请求头和请求体，其中请求头包含了请求方法、目标URL、协议、cookie、缓存等<br><strong>4、传输层TCP传输报文</strong><br>位于传输层的TCP协议为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文<br>段为单位的数据包进行管理，并为他们编号，方便服务器接收时能准确地还原报文信息。TCP<br>协议通过”三次握手”等方法保证传输的安全可靠。<br>“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复，接收端<br>收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有<br>ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内<br>没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。<br><img src=\"https://s4.ax1x.com/2022/02/14/Hy3DWq.png\"><br><strong>5、网络层IP协议查询MAC地址</strong><br>IP协议的作用是把TCP分割好的各种数据包发送给接收方。而要保证确实能闯到接收方还需要接收方的MAC地址，也就是物理地址。IP地址<br>和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议<br>可以将IP地址解析成对应的MAC地址。<br><strong>6、数据到达数据链路层</strong><br>在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束<br><strong>7、服务器接收数据</strong><br>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据<br>包重新组成原来的HTTP请求报文<br><strong>8、服务器响应请求</strong><br>服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息-状态码。状态码<br>由三位数字组成。<br><strong>9、服务器返回相应的文件</strong><br>请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。<br><strong>10、页面渲染</strong><br>html解析成DOM树，CSS解析成CSSOM树，DOM树和CSSOM树结合生成渲染树（Render Tree）,生成布局，将布局绘制在屏幕上  </p>\n<h3 id=\"二、状态码分析\"><a href=\"#二、状态码分析\" class=\"headerlink\" title=\"二、状态码分析\"></a>二、状态码分析</h3><p>200：响应成功，301：永久重定向，302：临时重定向，304：资源缓存，403：服务器禁止访问，404：服务器资源未找到，500-502：服务器内部错误，504：服务器繁忙<br>1xx 信息状态码 接收请求正在处理<br>2xx 成功状态码 请求正常处理完毕<br>3xx 重定向状态码 需要附加操作已完成请求<br>4xx 客户端错误状态码 服务器无法处理请求<br>5xx 服务器错误状态码 服务器处理请求出错  </p>\n<h3 id=\"三、HTTP四次挥手\"><a href=\"#三、HTTP四次挥手\" class=\"headerlink\" title=\"三、HTTP四次挥手\"></a>三、HTTP四次挥手</h3><p>第一次：当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求；<br>第二次：主机B收到FIN后对其作出响应，确认这一方向上的TCP的连接将关闭，将ACK置1；<br>第三次：由主机B再提出反方向的关闭请求，将FIN置1；<br>第四次：主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。  </p>\n<h3 id=\"四、http和https区别\"><a href=\"#四、http和https区别\" class=\"headerlink\" title=\"四、http和https区别\"></a>四、http和https区别</h3><p>1、http的URL是以http://开头，而https的URL是以https://开头<br>2、http是不安全的，而https是安全的<br>3、http标准端口80，而https的标准端口是443<br>4、在OSI网络模型中，http工作于应用层，而https的安全传输机制工作在传输层<br>5、http无法加密，而https对传输的数据进行加密<br>6、http无需证书，而https需要CA机构颁发的SSL证书  </p>\n<h3 id=\"五、GET和POST的区别\"><a href=\"#五、GET和POST的区别\" class=\"headerlink\" title=\"五、GET和POST的区别\"></a>五、GET和POST的区别</h3><p>1、GET在浏览器回退不会再次请求，POST会再次请求<br>2、GET请求会被浏览器主动缓存，POST不会，要手动设置<br>3、GET请求在URL中传递的参数有长度限制的，而POST中的参数不会<br>4、GET参数通过URL传递，POST放在Request body中<br>5、GET参数暴露在地址栏不安全，POST放在报文内部更安全<br>6、GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作<br>7、GET产生一个TCP数据包，POST产生两个TCP数据包  </p>\n<h3 id=\"六、理解xss、csrf、ddos攻击原理以及避免方式\"><a href=\"#六、理解xss、csrf、ddos攻击原理以及避免方式\" class=\"headerlink\" title=\"六、理解xss、csrf、ddos攻击原理以及避免方式\"></a>六、理解xss、csrf、ddos攻击原理以及避免方式</h3><p>1、XSS，跨站脚本攻击，是一种代码注入攻击。攻击者在网络上注入恶意代码，当被攻击者登录网站时<br>就会执行这些恶意代码，这些脚本可以读取cookie,session或者其他敏感的网络信息，对用户发起欺诈，甚至发起蠕虫攻击等。  </p>\n<p>XSS避免的方式：<br>1、URL参数使用encodeURIComponent方式转义<br>2、尽量不使用InnerHtml插入HTML内容<br>3、使用特殊符号、标签转义符  </p>\n<p>2、CSRF，跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台<br>的用户验证，达到冒充用户对被攻击的网站进行某项操作的目的。  </p>\n<p>CSRF避免的方式：<br>1、添加验证码<br>2、使用token</p>\n<p>3、DDos又叫分布式拒绝服务，原理就是利用大量的请求造成资源过载，导致服务器不可用。  </p>\n<p>DDos避免的方式：<br>1、限制单IP的请求评率<br>2、防火墙等防护设置禁止ICMP<br>3、检查特权端口的开放  </p>\n<h3 id=\"七、http如何实现缓存\"><a href=\"#七、http如何实现缓存\" class=\"headerlink\" title=\"七、http如何实现缓存\"></a>七、http如何实现缓存</h3><p>先去内存（from memory cache）找，有直接加载，没有去硬盘找（from disk cache），如果有加载，没有则进行网络请求。  </p>\n<p>memory cache在浏览器关闭后会清除，disk cache不会。  </p>\n<p><strong>web服务器通过2种方式判断浏览器缓存是否是最新的：</strong><br>1、浏览器把缓存文件的最后修改时间通过header中“if-Modified-Since”来告诉web服务器。<br>2、浏览器把缓存文件的ETag,通过header ”if-None-Match“,来告诉web服务器  </p>\n<p><strong>通过最后修改时间来判断缓存新鲜度</strong><br>Last-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。<br>1、浏览器客户端想请求一个文档，首先检查本地缓存，发现存在这个文档的缓存，获取缓存文件的最后修改时间，通过：if-Modified-Since,发送request给web服务器。<br>2、web服务器收到Request,将服务器的文档修改时间（Last-Modified）:跟request header中的，if-Modified-Since相对比较，如果时间一样的，说明缓存还是最新的，web<br>服务器将发送304 Not Modified给浏览器客户端，告诉客户端直接使用缓存里的版本。<br>3、假如该文档已经更新了，web服务器将发送该文档的最新版本给浏览器客户端。</p>\n<p><strong>通过Etag来判断缓存新鲜度</strong><br>Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。<br>1、当资源过期时，（使用Cache-Control标识的max-age）,发现资源具有Etag声明，则再次想web服务器请求时带上If-None-Match(Etag的值)。<br>2、web服务器收到请求后发现header中有If-None-Match则与被请求资源的相应校验串(etag)进行比对，决定返回200或者304  </p>\n<p><strong>为何有Last-Modified，还需要Etag？</strong><br>1 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>2 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>3 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形<br>4、Last-Modified与Etag一起使用时，服务器会优先验证Etag  </p>\n<p><strong>cache-control和Expires</strong><br>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间(绝对时间)前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  </p>\n<p>Cache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期（相对时间），控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。  </p>\n<p><strong>cache-control的值</strong><br>1 Public指示响应可被任何缓存区缓存。<br>2 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。<br>3 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~<br>4 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。<br>5 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。<br>6 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。<br>7 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>\n<p><strong>浏览器缓存流程</strong><br><img src=\"https://s4.ax1x.com/2022/02/14/H6nSFP.png\"></p>\n<h3 id=\"八、同源策略\"><a href=\"#八、同源策略\" class=\"headerlink\" title=\"八、同源策略\"></a>八、同源策略</h3><p>同源是指“协议+域名+端口”三种相同，同源策略就是一个域下的js脚本未经允许的情况下，不允许访问另一个域下的内容，只允许访问同源下的内容。</p>\n<p>跨域通信的几种方式：<br>1、jsonp(利用script标签没有跨域限制的漏洞实现，缺点：只支持get请求)<br>2、CORS(设置Access-Control-Allow-Origin,指定可访问资源的域名)<br>3、postMessage(页面内嵌iframe消息传递，通过onMessage监听传递过来的数据)<br>4、websocket通信<br>5、Node中间件代理<br>6、Nginx反向代理<br>7、document.domain + iframe跨域</p>\n<h3 id=\"九、本地存储的共同点和不同点\"><a href=\"#九、本地存储的共同点和不同点\" class=\"headerlink\" title=\"九、本地存储的共同点和不同点\"></a>九、本地存储的共同点和不同点</h3><p>共同点：都是保存在浏览器端，且同源的  </p>\n<p>不同点：<br>1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅本地保存。<br>2、储存大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M。<br>3、有效期不同，sessionStorage仅在当前浏览器窗口关闭之前有效，localStorage始终有效，cookie只在过期时间之前有效，即使窗口关闭或浏览器关闭。<br>4、作用域不同，sessionStorage在当前浏览器窗口共享，localStorage在所有同源窗口中共享，cookie也是在所有同源窗口中共享</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"网络基本知识\"><a href=\"#网络基本知识\" class=\"headerlink\" title=\"网络基本知识\"></a>网络基本知识</h2><h3 id=\"一、从输入URL到浏览器显示页面发生了什么\"><a href=\"#一、从输入URL到浏览器显示页面发生了什么\" class=\"headerlink\" title=\"一、从输入URL到浏览器显示页面发生了什么\"></a>一、从输入URL到浏览器显示页面发生了什么</h3><p>三个方面<br>一、网络篇<br>互联网内各网络设备间的通信都遵循TCP/IP协议，利用TCP/IP协议进行网络通信时，会通过分层顺序与对方法进行通信。分层由高到底分别为：应用层、传输层、网络层、数据链路层。发送端从应用层往下走，接受端从数据链路层往上走。如图所示<br><img src=\"https://s4.ax1x.com/2022/01/26/7LMBv9.png\"><br><strong>1、输入URL</strong><br><strong>2、应用层DNS解析域名(找到域名对应IP)</strong><br>客户端先检查本地是否有对应的IP地址，若找到则返回响应的IP地址。若没找到则请求上级DNS服务器，直到找到活到根节点。<br><strong>3、应用层客户端发送HTTP请求</strong><br>HTTP请求包括请求头和请求体，其中请求头包含了请求方法、目标URL、协议、cookie、缓存等<br><strong>4、传输层TCP传输报文</strong><br>位于传输层的TCP协议为传输报文提供可靠的字节流服务，它为了方便传输，将大块的数据分割成以报文<br>段为单位的数据包进行管理，并为他们编号，方便服务器接收时能准确地还原报文信息。TCP<br>协议通过”三次握手”等方法保证传输的安全可靠。<br>“三次握手”的过程是，发送端先发送一个带有SYN标志的数据包给接收端，在一定的延迟时间内等待接收的回复，接收端<br>收到数据包后，传回一个带有SYN/ACK标志的数据包以示传达确认信息。接收方收到后再发送一个带有<br>ACK标志的数据包给接收端以示握手成功。在这个过程中，如果发送端在规定延迟时间内<br>没有收到回复则默认接收方没有收到请求，而再次发送，直到收到回复为止。<br><img src=\"https://s4.ax1x.com/2022/02/14/Hy3DWq.png\"><br><strong>5、网络层IP协议查询MAC地址</strong><br>IP协议的作用是把TCP分割好的各种数据包发送给接收方。而要保证确实能闯到接收方还需要接收方的MAC地址，也就是物理地址。IP地址<br>和MAC地址是一一对应的关系，一个网络设备的IP地址可以更换，但是MAC地址一般是固定不变的。ARP协议<br>可以将IP地址解析成对应的MAC地址。<br><strong>6、数据到达数据链路层</strong><br>在找到对方的MAC地址后，就将数据发送到数据链路层传输。这时，客户端发送请求的阶段结束<br><strong>7、服务器接收数据</strong><br>接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议将分段的数据<br>包重新组成原来的HTTP请求报文<br><strong>8、服务器响应请求</strong><br>服务器接收到客户端发送的HTTP请求后，查找客户端请求的资源，并返回响应报文，响应报文中包括一个重要的信息-状态码。状态码<br>由三位数字组成。<br><strong>9、服务器返回相应的文件</strong><br>请求成功后，服务器会返回相应的HTML文件。接下来就到了页面的渲染阶段了。<br><strong>10、页面渲染</strong><br>html解析成DOM树，CSS解析成CSSOM树，DOM树和CSSOM树结合生成渲染树（Render Tree）,生成布局，将布局绘制在屏幕上  </p>\n<h3 id=\"二、状态码分析\"><a href=\"#二、状态码分析\" class=\"headerlink\" title=\"二、状态码分析\"></a>二、状态码分析</h3><p>200：响应成功，301：永久重定向，302：临时重定向，304：资源缓存，403：服务器禁止访问，404：服务器资源未找到，500-502：服务器内部错误，504：服务器繁忙<br>1xx 信息状态码 接收请求正在处理<br>2xx 成功状态码 请求正常处理完毕<br>3xx 重定向状态码 需要附加操作已完成请求<br>4xx 客户端错误状态码 服务器无法处理请求<br>5xx 服务器错误状态码 服务器处理请求出错  </p>\n<h3 id=\"三、HTTP四次挥手\"><a href=\"#三、HTTP四次挥手\" class=\"headerlink\" title=\"三、HTTP四次挥手\"></a>三、HTTP四次挥手</h3><p>第一次：当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求；<br>第二次：主机B收到FIN后对其作出响应，确认这一方向上的TCP的连接将关闭，将ACK置1；<br>第三次：由主机B再提出反方向的关闭请求，将FIN置1；<br>第四次：主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。  </p>\n<h3 id=\"四、http和https区别\"><a href=\"#四、http和https区别\" class=\"headerlink\" title=\"四、http和https区别\"></a>四、http和https区别</h3><p>1、http的URL是以http://开头，而https的URL是以https://开头<br>2、http是不安全的，而https是安全的<br>3、http标准端口80，而https的标准端口是443<br>4、在OSI网络模型中，http工作于应用层，而https的安全传输机制工作在传输层<br>5、http无法加密，而https对传输的数据进行加密<br>6、http无需证书，而https需要CA机构颁发的SSL证书  </p>\n<h3 id=\"五、GET和POST的区别\"><a href=\"#五、GET和POST的区别\" class=\"headerlink\" title=\"五、GET和POST的区别\"></a>五、GET和POST的区别</h3><p>1、GET在浏览器回退不会再次请求，POST会再次请求<br>2、GET请求会被浏览器主动缓存，POST不会，要手动设置<br>3、GET请求在URL中传递的参数有长度限制的，而POST中的参数不会<br>4、GET参数通过URL传递，POST放在Request body中<br>5、GET参数暴露在地址栏不安全，POST放在报文内部更安全<br>6、GET一般用于查询信息，POST一般用于提交某种信息进行某些修改操作<br>7、GET产生一个TCP数据包，POST产生两个TCP数据包  </p>\n<h3 id=\"六、理解xss、csrf、ddos攻击原理以及避免方式\"><a href=\"#六、理解xss、csrf、ddos攻击原理以及避免方式\" class=\"headerlink\" title=\"六、理解xss、csrf、ddos攻击原理以及避免方式\"></a>六、理解xss、csrf、ddos攻击原理以及避免方式</h3><p>1、XSS，跨站脚本攻击，是一种代码注入攻击。攻击者在网络上注入恶意代码，当被攻击者登录网站时<br>就会执行这些恶意代码，这些脚本可以读取cookie,session或者其他敏感的网络信息，对用户发起欺诈，甚至发起蠕虫攻击等。  </p>\n<p>XSS避免的方式：<br>1、URL参数使用encodeURIComponent方式转义<br>2、尽量不使用InnerHtml插入HTML内容<br>3、使用特殊符号、标签转义符  </p>\n<p>2、CSRF，跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台<br>的用户验证，达到冒充用户对被攻击的网站进行某项操作的目的。  </p>\n<p>CSRF避免的方式：<br>1、添加验证码<br>2、使用token</p>\n<p>3、DDos又叫分布式拒绝服务，原理就是利用大量的请求造成资源过载，导致服务器不可用。  </p>\n<p>DDos避免的方式：<br>1、限制单IP的请求评率<br>2、防火墙等防护设置禁止ICMP<br>3、检查特权端口的开放  </p>\n<h3 id=\"七、http如何实现缓存\"><a href=\"#七、http如何实现缓存\" class=\"headerlink\" title=\"七、http如何实现缓存\"></a>七、http如何实现缓存</h3><p>先去内存（from memory cache）找，有直接加载，没有去硬盘找（from disk cache），如果有加载，没有则进行网络请求。  </p>\n<p>memory cache在浏览器关闭后会清除，disk cache不会。  </p>\n<p><strong>web服务器通过2种方式判断浏览器缓存是否是最新的：</strong><br>1、浏览器把缓存文件的最后修改时间通过header中“if-Modified-Since”来告诉web服务器。<br>2、浏览器把缓存文件的ETag,通过header ”if-None-Match“,来告诉web服务器  </p>\n<p><strong>通过最后修改时间来判断缓存新鲜度</strong><br>Last-Modified/If-Modified-Since：Last-Modified/If-Modified-Since要配合Cache-Control使用。<br>1、浏览器客户端想请求一个文档，首先检查本地缓存，发现存在这个文档的缓存，获取缓存文件的最后修改时间，通过：if-Modified-Since,发送request给web服务器。<br>2、web服务器收到Request,将服务器的文档修改时间（Last-Modified）:跟request header中的，if-Modified-Since相对比较，如果时间一样的，说明缓存还是最新的，web<br>服务器将发送304 Not Modified给浏览器客户端，告诉客户端直接使用缓存里的版本。<br>3、假如该文档已经更新了，web服务器将发送该文档的最新版本给浏览器客户端。</p>\n<p><strong>通过Etag来判断缓存新鲜度</strong><br>Etag/If-None-Match：Etag/If-None-Match也要配合Cache-Control使用。<br>1、当资源过期时，（使用Cache-Control标识的max-age）,发现资源具有Etag声明，则再次想web服务器请求时带上If-None-Match(Etag的值)。<br>2、web服务器收到请求后发现header中有If-None-Match则与被请求资源的相应校验串(etag)进行比对，决定返回200或者304  </p>\n<p><strong>为何有Last-Modified，还需要Etag？</strong><br>1 Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>2 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>3 有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形<br>4、Last-Modified与Etag一起使用时，服务器会优先验证Etag  </p>\n<p><strong>cache-control和Expires</strong><br>Expires策略：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间(绝对时间)前浏览器可以直接从浏览器缓存取数据，而无需再次请求。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。  </p>\n<p>Cache-control策略（重点关注）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期（相对时间），控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。  </p>\n<p><strong>cache-control的值</strong><br>1 Public指示响应可被任何缓存区缓存。<br>2 Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。<br>3 no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~<br>4 no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。<br>5 max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。<br>6 min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。<br>7 max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</p>\n<p><strong>浏览器缓存流程</strong><br><img src=\"https://s4.ax1x.com/2022/02/14/H6nSFP.png\"></p>\n<h3 id=\"八、同源策略\"><a href=\"#八、同源策略\" class=\"headerlink\" title=\"八、同源策略\"></a>八、同源策略</h3><p>同源是指“协议+域名+端口”三种相同，同源策略就是一个域下的js脚本未经允许的情况下，不允许访问另一个域下的内容，只允许访问同源下的内容。</p>\n<p>跨域通信的几种方式：<br>1、jsonp(利用script标签没有跨域限制的漏洞实现，缺点：只支持get请求)<br>2、CORS(设置Access-Control-Allow-Origin,指定可访问资源的域名)<br>3、postMessage(页面内嵌iframe消息传递，通过onMessage监听传递过来的数据)<br>4、websocket通信<br>5、Node中间件代理<br>6、Nginx反向代理<br>7、document.domain + iframe跨域</p>\n<h3 id=\"九、本地存储的共同点和不同点\"><a href=\"#九、本地存储的共同点和不同点\" class=\"headerlink\" title=\"九、本地存储的共同点和不同点\"></a>九、本地存储的共同点和不同点</h3><p>共同点：都是保存在浏览器端，且同源的  </p>\n<p>不同点：<br>1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器来回传递。sessionStorage和localStorage不会自动把数据发给服务器，仅本地保存。<br>2、储存大小限制也不同，cookie数据不能超过4K，sessionStorage和localStorage可以达到5M。<br>3、有效期不同，sessionStorage仅在当前浏览器窗口关闭之前有效，localStorage始终有效，cookie只在过期时间之前有效，即使窗口关闭或浏览器关闭。<br>4、作用域不同，sessionStorage在当前浏览器窗口共享，localStorage在所有同源窗口中共享，cookie也是在所有同源窗口中共享</p>\n"},{"title":"code","date":"2022-02-16T07:33:35.000Z","cover":"https://s4.ax1x.com/2022/02/16/Hf746f.png","_content":"\n## 手撕代码\n\n### 防抖节流\n防抖：n秒内多次触发，会重新计时，最终只执行一次\n```javascript\nfunction fd(fn, wait, immediate) {\n    let timer = null;\n    return function () {\n        let args = Array.from(arguments);\n        if (immediate && !timer) {\n            fn.call(this, ...args)\n        }\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            fn.call(this, ...args)\n        }, wait)\n    }\n}\n\nfunction handler() {\n    console.log('我是防抖的，我1s内只执行一次')\n}\n\nlet say = fd(handler, 1000, true);\n\nwindow.addEventListener('mousemove', say)\n```\n\n节流：n秒内执行一次\n```javascript\n//不使用setTimeout\nfunction jl_pre(fn, wait) {\n    let pre = 0;\n    return function () {\n        let args = Array.from(arguments);\n        let now = new Date().getTime();\n        if (now - pre >= wait) {\n            pre = now;\n            fn.call(this, ...args);\n        }\n    }\n}\n\n// 使用setTimeout\nfunction jl_timer(fn, wait) {\n    let lock = false;\n    return function () {\n        if (lock) return;\n        let args = Array.from(arguments);\n        lock = true;\n        setTimeout(() => {\n            lock = false;\n            fn.call(this, ...args);\n        }, wait)\n    }\n}\n\nfunction handler() {\n    console.log('我是节流的，持续触发，我每1s内只执行一次')\n}\n\nlet say = jl_pre(handler, 1000);\n\nlet sayTime = jl_timer(handler, 1000)\n\nwindow.addEventListener('mousemove', sayTime)\n\n```\n\n### 深拷贝\n```javascript\nfunction deepClone(obj) {\n    let deepObj = Array.isArray(obj) ? [] : {};\n    if (typeof obj === 'object') {\n        for (let key in obj) {\n            deepObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];\n        }\n    } else {\n        deepObj = obj;\n    }\n    return deepObj;\n}\nlet a = {\n    name: 'zs',\n    age: 30,\n    son: {\n        name: 'zw',\n        age: 1\n    }\n}\nlet b = deepClone(a);\n```\n\n### 数组去重\n```javascript\nlet arr = [1,2,3,3,5,8,2,1,8,2,6];\n// 方法1 使用set特性\nlet arr1 = [...new set(arr)];\n\n// 方法2 使用reduce方法\nlet arr2 = arr.reduce((prev, cur) => {\n    if (prev.includes(cur)) {\n        return prev\n    } else {\n        return prev.concat(cur);\n    }\n}, [])\n\n// 方法3 使用循环\nlet arr3 = [];\nfor (let key in arr) {\n    if (!arr3.includes(arr[key])) {\n        arr3.push(arr[key]);\n    }\n}\n```\n\n### 计算数组每个元素出现的次数\n```javascript\nlet arr = ['tom', 'mick', 'josn', 'tom', 'a', 1, 1, 'a', 'tom']\n\nlet obj = arr.reduce((prev, cur) => {\n    if (prev[cur]) {\n        prev[cur]++;\n    } else {\n        prev[cur] = 1\n    }\n    return prev;\n}, {})\n\nconsole.log(obj)\n```\n\n### 将二维数组拍平成一维数组\n```javascript\nlet arr = [[1,2],[3,4],[5,6]]\n\nlet arr1 = arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n}, [])\n\nconsole.log(arr1)\n```\n\n### 将多维数组拍平成一维数组\n```javascript\nlet arr = [1,[1,2],[1,[1,2,3,[4,5]]]]\n\nlet newArr = function (arr) {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(Array.isArray(cur) ? newArr(cur) : cur);\n    }, [])\n}\n\nconsole.log(newArr(arr))\n```","source":"_posts/code.md","raw":"---\ntitle: code\ndate: 2022-02-16 15:33:35\ncover: https://s4.ax1x.com/2022/02/16/Hf746f.png\ntags:\n- js\n---\n\n## 手撕代码\n\n### 防抖节流\n防抖：n秒内多次触发，会重新计时，最终只执行一次\n```javascript\nfunction fd(fn, wait, immediate) {\n    let timer = null;\n    return function () {\n        let args = Array.from(arguments);\n        if (immediate && !timer) {\n            fn.call(this, ...args)\n        }\n        if (timer) {\n            clearTimeout(timer);\n        }\n        timer = setTimeout(() => {\n            fn.call(this, ...args)\n        }, wait)\n    }\n}\n\nfunction handler() {\n    console.log('我是防抖的，我1s内只执行一次')\n}\n\nlet say = fd(handler, 1000, true);\n\nwindow.addEventListener('mousemove', say)\n```\n\n节流：n秒内执行一次\n```javascript\n//不使用setTimeout\nfunction jl_pre(fn, wait) {\n    let pre = 0;\n    return function () {\n        let args = Array.from(arguments);\n        let now = new Date().getTime();\n        if (now - pre >= wait) {\n            pre = now;\n            fn.call(this, ...args);\n        }\n    }\n}\n\n// 使用setTimeout\nfunction jl_timer(fn, wait) {\n    let lock = false;\n    return function () {\n        if (lock) return;\n        let args = Array.from(arguments);\n        lock = true;\n        setTimeout(() => {\n            lock = false;\n            fn.call(this, ...args);\n        }, wait)\n    }\n}\n\nfunction handler() {\n    console.log('我是节流的，持续触发，我每1s内只执行一次')\n}\n\nlet say = jl_pre(handler, 1000);\n\nlet sayTime = jl_timer(handler, 1000)\n\nwindow.addEventListener('mousemove', sayTime)\n\n```\n\n### 深拷贝\n```javascript\nfunction deepClone(obj) {\n    let deepObj = Array.isArray(obj) ? [] : {};\n    if (typeof obj === 'object') {\n        for (let key in obj) {\n            deepObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];\n        }\n    } else {\n        deepObj = obj;\n    }\n    return deepObj;\n}\nlet a = {\n    name: 'zs',\n    age: 30,\n    son: {\n        name: 'zw',\n        age: 1\n    }\n}\nlet b = deepClone(a);\n```\n\n### 数组去重\n```javascript\nlet arr = [1,2,3,3,5,8,2,1,8,2,6];\n// 方法1 使用set特性\nlet arr1 = [...new set(arr)];\n\n// 方法2 使用reduce方法\nlet arr2 = arr.reduce((prev, cur) => {\n    if (prev.includes(cur)) {\n        return prev\n    } else {\n        return prev.concat(cur);\n    }\n}, [])\n\n// 方法3 使用循环\nlet arr3 = [];\nfor (let key in arr) {\n    if (!arr3.includes(arr[key])) {\n        arr3.push(arr[key]);\n    }\n}\n```\n\n### 计算数组每个元素出现的次数\n```javascript\nlet arr = ['tom', 'mick', 'josn', 'tom', 'a', 1, 1, 'a', 'tom']\n\nlet obj = arr.reduce((prev, cur) => {\n    if (prev[cur]) {\n        prev[cur]++;\n    } else {\n        prev[cur] = 1\n    }\n    return prev;\n}, {})\n\nconsole.log(obj)\n```\n\n### 将二维数组拍平成一维数组\n```javascript\nlet arr = [[1,2],[3,4],[5,6]]\n\nlet arr1 = arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n}, [])\n\nconsole.log(arr1)\n```\n\n### 将多维数组拍平成一维数组\n```javascript\nlet arr = [1,[1,2],[1,[1,2,3,[4,5]]]]\n\nlet newArr = function (arr) {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(Array.isArray(cur) ? newArr(cur) : cur);\n    }, [])\n}\n\nconsole.log(newArr(arr))\n```","slug":"code","published":1,"updated":"2022-02-16T10:10:50.626Z","_id":"ckzp8s1ga0000o4v4dixvavnv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"手撕代码\"><a href=\"#手撕代码\" class=\"headerlink\" title=\"手撕代码\"></a>手撕代码</h2><h3 id=\"防抖节流\"><a href=\"#防抖节流\" class=\"headerlink\" title=\"防抖节流\"></a>防抖节流</h3><p>防抖：n秒内多次触发，会重新计时，最终只执行一次</p>\n<pre><code class=\"javascript\">function fd(fn, wait, immediate) &#123;\n    let timer = null;\n    return function () &#123;\n        let args = Array.from(arguments);\n        if (immediate &amp;&amp; !timer) &#123;\n            fn.call(this, ...args)\n        &#125;\n        if (timer) &#123;\n            clearTimeout(timer);\n        &#125;\n        timer = setTimeout(() =&gt; &#123;\n            fn.call(this, ...args)\n        &#125;, wait)\n    &#125;\n&#125;\n\nfunction handler() &#123;\n    console.log(&#39;我是防抖的，我1s内只执行一次&#39;)\n&#125;\n\nlet say = fd(handler, 1000, true);\n\nwindow.addEventListener(&#39;mousemove&#39;, say)\n</code></pre>\n<p>节流：n秒内执行一次</p>\n<pre><code class=\"javascript\">//不使用setTimeout\nfunction jl_pre(fn, wait) &#123;\n    let pre = 0;\n    return function () &#123;\n        let args = Array.from(arguments);\n        let now = new Date().getTime();\n        if (now - pre &gt;= wait) &#123;\n            pre = now;\n            fn.call(this, ...args);\n        &#125;\n    &#125;\n&#125;\n\n// 使用setTimeout\nfunction jl_timer(fn, wait) &#123;\n    let lock = false;\n    return function () &#123;\n        if (lock) return;\n        let args = Array.from(arguments);\n        lock = true;\n        setTimeout(() =&gt; &#123;\n            lock = false;\n            fn.call(this, ...args);\n        &#125;, wait)\n    &#125;\n&#125;\n\nfunction handler() &#123;\n    console.log(&#39;我是节流的，持续触发，我每1s内只执行一次&#39;)\n&#125;\n\nlet say = jl_pre(handler, 1000);\n\nlet sayTime = jl_timer(handler, 1000)\n\nwindow.addEventListener(&#39;mousemove&#39;, sayTime)\n</code></pre>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><pre><code class=\"javascript\">function deepClone(obj) &#123;\n    let deepObj = Array.isArray(obj) ? [] : &#123;&#125;;\n    if (typeof obj === &#39;object&#39;) &#123;\n        for (let key in obj) &#123;\n            deepObj[key] = typeof obj[key] === &#39;object&#39; ? deepClone(obj[key]) : obj[key];\n        &#125;\n    &#125; else &#123;\n        deepObj = obj;\n    &#125;\n    return deepObj;\n&#125;\nlet a = &#123;\n    name: &#39;zs&#39;,\n    age: 30,\n    son: &#123;\n        name: &#39;zw&#39;,\n        age: 1\n    &#125;\n&#125;\nlet b = deepClone(a);\n</code></pre>\n<h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><pre><code class=\"javascript\">let arr = [1,2,3,3,5,8,2,1,8,2,6];\n// 方法1 使用set特性\nlet arr1 = [...new set(arr)];\n\n// 方法2 使用reduce方法\nlet arr2 = arr.reduce((prev, cur) =&gt; &#123;\n    if (prev.includes(cur)) &#123;\n        return prev\n    &#125; else &#123;\n        return prev.concat(cur);\n    &#125;\n&#125;, [])\n\n// 方法3 使用循环\nlet arr3 = [];\nfor (let key in arr) &#123;\n    if (!arr3.includes(arr[key])) &#123;\n        arr3.push(arr[key]);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"计算数组每个元素出现的次数\"><a href=\"#计算数组每个元素出现的次数\" class=\"headerlink\" title=\"计算数组每个元素出现的次数\"></a>计算数组每个元素出现的次数</h3><pre><code class=\"javascript\">let arr = [&#39;tom&#39;, &#39;mick&#39;, &#39;josn&#39;, &#39;tom&#39;, &#39;a&#39;, 1, 1, &#39;a&#39;, &#39;tom&#39;]\n\nlet obj = arr.reduce((prev, cur) =&gt; &#123;\n    if (prev[cur]) &#123;\n        prev[cur]++;\n    &#125; else &#123;\n        prev[cur] = 1\n    &#125;\n    return prev;\n&#125;, &#123;&#125;)\n\nconsole.log(obj)\n</code></pre>\n<h3 id=\"将二维数组拍平成一维数组\"><a href=\"#将二维数组拍平成一维数组\" class=\"headerlink\" title=\"将二维数组拍平成一维数组\"></a>将二维数组拍平成一维数组</h3><pre><code class=\"javascript\">let arr = [[1,2],[3,4],[5,6]]\n\nlet arr1 = arr.reduce((prev, cur) =&gt; &#123;\n    return prev.concat(cur);\n&#125;, [])\n\nconsole.log(arr1)\n</code></pre>\n<h3 id=\"将多维数组拍平成一维数组\"><a href=\"#将多维数组拍平成一维数组\" class=\"headerlink\" title=\"将多维数组拍平成一维数组\"></a>将多维数组拍平成一维数组</h3><pre><code class=\"javascript\">let arr = [1,[1,2],[1,[1,2,3,[4,5]]]]\n\nlet newArr = function (arr) &#123;\n    return arr.reduce((prev, cur) =&gt; &#123;\n        return prev.concat(Array.isArray(cur) ? newArr(cur) : cur);\n    &#125;, [])\n&#125;\n\nconsole.log(newArr(arr))\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"手撕代码\"><a href=\"#手撕代码\" class=\"headerlink\" title=\"手撕代码\"></a>手撕代码</h2><h3 id=\"防抖节流\"><a href=\"#防抖节流\" class=\"headerlink\" title=\"防抖节流\"></a>防抖节流</h3><p>防抖：n秒内多次触发，会重新计时，最终只执行一次</p>\n<pre><code class=\"javascript\">function fd(fn, wait, immediate) &#123;\n    let timer = null;\n    return function () &#123;\n        let args = Array.from(arguments);\n        if (immediate &amp;&amp; !timer) &#123;\n            fn.call(this, ...args)\n        &#125;\n        if (timer) &#123;\n            clearTimeout(timer);\n        &#125;\n        timer = setTimeout(() =&gt; &#123;\n            fn.call(this, ...args)\n        &#125;, wait)\n    &#125;\n&#125;\n\nfunction handler() &#123;\n    console.log(&#39;我是防抖的，我1s内只执行一次&#39;)\n&#125;\n\nlet say = fd(handler, 1000, true);\n\nwindow.addEventListener(&#39;mousemove&#39;, say)\n</code></pre>\n<p>节流：n秒内执行一次</p>\n<pre><code class=\"javascript\">//不使用setTimeout\nfunction jl_pre(fn, wait) &#123;\n    let pre = 0;\n    return function () &#123;\n        let args = Array.from(arguments);\n        let now = new Date().getTime();\n        if (now - pre &gt;= wait) &#123;\n            pre = now;\n            fn.call(this, ...args);\n        &#125;\n    &#125;\n&#125;\n\n// 使用setTimeout\nfunction jl_timer(fn, wait) &#123;\n    let lock = false;\n    return function () &#123;\n        if (lock) return;\n        let args = Array.from(arguments);\n        lock = true;\n        setTimeout(() =&gt; &#123;\n            lock = false;\n            fn.call(this, ...args);\n        &#125;, wait)\n    &#125;\n&#125;\n\nfunction handler() &#123;\n    console.log(&#39;我是节流的，持续触发，我每1s内只执行一次&#39;)\n&#125;\n\nlet say = jl_pre(handler, 1000);\n\nlet sayTime = jl_timer(handler, 1000)\n\nwindow.addEventListener(&#39;mousemove&#39;, sayTime)\n</code></pre>\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><pre><code class=\"javascript\">function deepClone(obj) &#123;\n    let deepObj = Array.isArray(obj) ? [] : &#123;&#125;;\n    if (typeof obj === &#39;object&#39;) &#123;\n        for (let key in obj) &#123;\n            deepObj[key] = typeof obj[key] === &#39;object&#39; ? deepClone(obj[key]) : obj[key];\n        &#125;\n    &#125; else &#123;\n        deepObj = obj;\n    &#125;\n    return deepObj;\n&#125;\nlet a = &#123;\n    name: &#39;zs&#39;,\n    age: 30,\n    son: &#123;\n        name: &#39;zw&#39;,\n        age: 1\n    &#125;\n&#125;\nlet b = deepClone(a);\n</code></pre>\n<h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><pre><code class=\"javascript\">let arr = [1,2,3,3,5,8,2,1,8,2,6];\n// 方法1 使用set特性\nlet arr1 = [...new set(arr)];\n\n// 方法2 使用reduce方法\nlet arr2 = arr.reduce((prev, cur) =&gt; &#123;\n    if (prev.includes(cur)) &#123;\n        return prev\n    &#125; else &#123;\n        return prev.concat(cur);\n    &#125;\n&#125;, [])\n\n// 方法3 使用循环\nlet arr3 = [];\nfor (let key in arr) &#123;\n    if (!arr3.includes(arr[key])) &#123;\n        arr3.push(arr[key]);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"计算数组每个元素出现的次数\"><a href=\"#计算数组每个元素出现的次数\" class=\"headerlink\" title=\"计算数组每个元素出现的次数\"></a>计算数组每个元素出现的次数</h3><pre><code class=\"javascript\">let arr = [&#39;tom&#39;, &#39;mick&#39;, &#39;josn&#39;, &#39;tom&#39;, &#39;a&#39;, 1, 1, &#39;a&#39;, &#39;tom&#39;]\n\nlet obj = arr.reduce((prev, cur) =&gt; &#123;\n    if (prev[cur]) &#123;\n        prev[cur]++;\n    &#125; else &#123;\n        prev[cur] = 1\n    &#125;\n    return prev;\n&#125;, &#123;&#125;)\n\nconsole.log(obj)\n</code></pre>\n<h3 id=\"将二维数组拍平成一维数组\"><a href=\"#将二维数组拍平成一维数组\" class=\"headerlink\" title=\"将二维数组拍平成一维数组\"></a>将二维数组拍平成一维数组</h3><pre><code class=\"javascript\">let arr = [[1,2],[3,4],[5,6]]\n\nlet arr1 = arr.reduce((prev, cur) =&gt; &#123;\n    return prev.concat(cur);\n&#125;, [])\n\nconsole.log(arr1)\n</code></pre>\n<h3 id=\"将多维数组拍平成一维数组\"><a href=\"#将多维数组拍平成一维数组\" class=\"headerlink\" title=\"将多维数组拍平成一维数组\"></a>将多维数组拍平成一维数组</h3><pre><code class=\"javascript\">let arr = [1,[1,2],[1,[1,2,3,[4,5]]]]\n\nlet newArr = function (arr) &#123;\n    return arr.reduce((prev, cur) =&gt; &#123;\n        return prev.concat(Array.isArray(cur) ? newArr(cur) : cur);\n    &#125;, [])\n&#125;\n\nconsole.log(newArr(arr))\n</code></pre>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cksipd6qb00036cvmfdc54s6o","category_id":"cksipd6qg00066cvmhp8we2tb","_id":"cksipd6qi00096cvmammaf1b7"}],"PostTag":[{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qd00046cvmdqkocyb1","_id":"cksipd6qk000b6cvmgqgd6lsq"},{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qh00076cvmhr7t6j01","_id":"cksipd6qk000c6cvm8ehx4ijz"},{"post_id":"cksipd6q700016cvmclixdteq","tag_id":"cksipd6qi00086cvmgb3r9av0","_id":"cksipd6qk000e6cvm9tn12ikz"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qd00046cvmdqkocyb1","_id":"ckssmzt2g001hb0vmbkeufe88"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qk000d6cvm1ftv1q54","_id":"ckssmzt2g001ib0vm5rp92ll4"},{"post_id":"ckssmzt2e001gb0vm6vxo5nyw","tag_id":"cksipd6qk000f6cvm5rdy2kxg","_id":"ckssmzt2h001jb0vmdf5m31fk"},{"post_id":"cksspqlja001kb0vm992ncjf5","tag_id":"cksk3oveu0001cwvmcrak8r91","_id":"cksspqljb001lb0vm88whahsz"},{"post_id":"cky8bbvpt00008wv4742mb6jl","tag_id":"cky8bdzpt00018wv4cjk034dr","_id":"cky8bdzpt00028wv4hf5j5yvq"},{"post_id":"cky9ii5eu0000bcv4cqh3ckht","tag_id":"cky9ii5ez0001bcv44z4ma5w3","_id":"cky9ii5f10002bcv4hheu69p3"},{"post_id":"ckycpspqf00006sv48i763yh4","tag_id":"ckycpspqj00016sv40jz94wgo","_id":"ckycpspql00026sv42jt22tu6"},{"post_id":"ckycpspqf00006sv48i763yh4","tag_id":"cky9ii5ez0001bcv44z4ma5w3","_id":"ckycpspqm00036sv4glf0diba"},{"post_id":"ckyv5ueae0000mkv4gcor537u","tag_id":"ckyv5ueaj0001mkv4hol1dj4k","_id":"ckyv5ueal0003mkv4afk34v4i"},{"post_id":"ckyv5ueae0000mkv4gcor537u","tag_id":"ckyv5ueak0002mkv43010gota","_id":"ckyv5ueal0004mkv4b568efom"},{"post_id":"ckzp8s1ga0000o4v4dixvavnv","tag_id":"cky9ii5ez0001bcv44z4ma5w3","_id":"ckzp8s1gf0001o4v46qdt05yc"}],"Tag":[{"name":"vue","_id":"cksipd6qd00046cvmdqkocyb1"},{"name":"双向绑定","_id":"cksipd6qh00076cvmhr7t6j01"},{"name":"观察者模式","_id":"cksipd6qi00086cvmgb3r9av0"},{"name":"单页面","_id":"cksipd6qk000d6cvm1ftv1q54"},{"name":"路由","_id":"cksipd6qk000f6cvm5rdy2kxg"},{"name":"promise","_id":"cksk3oveu0001cwvmcrak8r91"},{"name":"html","_id":"cky8bdzpt00018wv4cjk034dr"},{"name":"js","_id":"cky9ii5ez0001bcv44z4ma5w3"},{"name":"es6","_id":"ckycpspqj00016sv40jz94wgo"},{"name":"网络","_id":"ckyv5ueaj0001mkv4hol1dj4k"},{"name":"JS","_id":"ckyv5ueak0002mkv43010gota"}]}}